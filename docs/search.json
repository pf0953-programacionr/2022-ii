[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "PF 0953 Programación en R 2022-II",
    "section": "",
    "text": "Este curso trata sobre el manejo, visualización y análisis de datos geoespaciales mediante el lenguaje de programación R. Se imparte en la Maestría Académica en Gestión Integrada del Recurso Hídrico para Latinoamérica y El Caribe de la Universidad de Costa Rica.\nSe estudian los fundamentos de R, sus bibliotecas geoespaciales y sus capacidades para generar gráficos estadísticos. También se utilizan herramientas para facilitar la reproducibilidad de los procedimientos y su comunicación a través de la Internet y otros medios.\nEl enfoque del curso es teórico-práctico, con lecciones teóricas combinadas con ejercicios de programación en los cuales los estudiantes aplican en diversos escenarios de procesamiento de datos los conocimientos y habilidades aprendidas.\nEste sitio web corresponde al curso impartido durante el segundo lectivo de 2022. Para más información sobre los contenidos, metodología, evaluación y otros temas, puede consultar el programa del curso.\nInformación de contacto\nSi tiene alguna pregunta o comentario sobre este curso, por favor contacte a:\n\nManuel Vargas - manuel.vargas_d@ucr.ac.cr\nProfesor\nUniversidad de Costa Rica,\nCiudad Universitaria Rodrigo Facio,\nSan Pedro de Montes de Oca,\nCosta Rica.\n\nLos contenidos de este curso, a menos que se especifique de otra forma, se comparten mediante una licencia de Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional."
  },
  {
    "objectID": "01-introduccion-ciencia-datos-geoespaciales.html",
    "href": "01-introduccion-ciencia-datos-geoespaciales.html",
    "title": "1  Introducción a la ciencia de datos geoespaciales",
    "section": "",
    "text": "Bartomeus Lab. (2016). A reproducible workflow. https://www.youtube.com/watch?v=s3JldKoA0zw\nFOSS4G. (2021). FOSS4G2021—Open source for open spatial data science—Anita Graser. https://www.youtube.com/watch?v=ZjXb53pOor0\nKrugman, P. (2013). Opinion | The Excel Depression. The New York Times. https://www.nytimes.com/2013/04/19/opinion/krugman-the-excel-depression.html\nPeng, R. D. (2011). Reproducible Research in Computational Science. Science, 334(6060), 1226-1227. https://doi.org/10.1126/science.1213847\nSingleton, A. D., Spielman, S., & Brunsdon, C. (2016). Establishing a framework for Open Geographic Information science. International Journal of Geographical Information Science, 30(8), 1507-1521. https://doi.org/10.1080/13658816.2015.1137579\nWu, Q. (2021, octubre 25). A streamlit app for creating timelapse of annual Landsat imagery (1984–2021). Medium. https://giswqs.medium.com/a-streamlit-app-for-creating-timelapse-of-annual-landsat-imagery-1984-2021-3db407a8ac32"
  },
  {
    "objectID": "01-introduccion-ciencia-datos-geoespaciales.html#el-componente-geoespacial-de-los-datos",
    "href": "01-introduccion-ciencia-datos-geoespaciales.html#el-componente-geoespacial-de-los-datos",
    "title": "1  Introducción a la ciencia de datos geoespaciales",
    "section": "1.2 El componente geoespacial de los datos",
    "text": "1.2 El componente geoespacial de los datos\nUna gran parte de los datos disponibles contiene algún tipo de componente geográfico o espacial 1. Este componente puede expresarse de varias formas. Por ejemplo:\n\nCon nombres de lugares: El sapo dorado (Incilius periglenes) era una especie de anfibio, endémica de los bosques nubosos de altitud de Monteverde, Costa Rica.\nCon direcciones: La sede de la Organización de las Naciones Unidas (ONU) está ubicada en la ciudad de Nueva York, Estados Unidos, en la Primera Avenida, 750.\nCon coordenadas: *La cima del Monte Everest se localiza en las coordenadas geográficas 86°55′31″ E y 27°59′17″ N, como se muestra en la Figure 1.1.\n\n\n\n\n\n\nFigure 1.1: Mapa de Nepal que muestra la ubicación del Monte Everest en el sistema de coordenadas geográficas. Imagen de https://www.mapsofworld.com/.\n\n\n\n\nLas coordenadas correspondientes a lugares y direcciones pueden obtenerse a través de un proceso denominado georreferenciación, mediante el cual, en general, se determina la posición espacial de alguna entidad en un sistema de coordenadas. La georreferenciación puede emplearse también para obtener las coordenadas de, por ejemplo, fotografías aéreas o mapas antiguos. Es un proceso que puede resultar complejo y costoso y para el que se han desarrollado metodologías y plataformas especializadas (ej. Chapman AD & Wieczorek JR (2020) Georeferencing Best Practices, GEOLocate, Nominatim).\nEn la actualidad, hay una gran cantidad de fuentes que generan datos georreferenciados (i.e. ubicados en un sistema de coordenadas). Entre estas pueden mencionarse las tecnologías de observación de la Tierra (Earth Observation) (ej. imágenes satelitales), los dispositivos móviles y los sensores remotos, entre muchas otras.\nSeguidamente, se describen dos enfoques tecnológicos para el procesamiento de datos geoespaciales: el de los sistemas de información geográfica y el de ciencia de datos geoespaciales."
  },
  {
    "objectID": "01-introduccion-ciencia-datos-geoespaciales.html#sistemas-de-información-geográfica",
    "href": "01-introduccion-ciencia-datos-geoespaciales.html#sistemas-de-información-geográfica",
    "title": "1  Introducción a la ciencia de datos geoespaciales",
    "section": "1.3 Sistemas de información geográfica",
    "text": "1.3 Sistemas de información geográfica\nA principios de la década de 1960, el geógrafo inglés Roger Tomlinson desarrolló en Canadá el que se considera el primer sistema de información geográfica. Se trataba del Canada Geographic Information System (CGIS) y su objetivo fue manejar los datos del inventario geográfico canadiense y su análisis para la gestión del territorio rural. De manera casi simultánea al trabajo de Tomlinson, surgieron desarrollos similares en Estados Unidos y en el Reino Unido. El surgimiento de los sistemas de información geográfica no implicó solo el surgimiento de nuevas herramientas de software, sino también el desarrollo de técnicas que hasta entonces no habían sido necesarias (Olaya 2020) como, por ejemplo, la manipulación de nuevos tipos de datos geométricos (ej. puntos, líneas, polígonos).\nEn general, un sistema de información geográfica (SIG) maneja datos georreferenciados y los asocia con datos convencionales (ej. textos, números), como se muestra en la Figure 1.2.\n\n\n\n\n\nFigure 1.2: Mapa elaborado en QGIS que muestra la ubicación de los aeródromos de Costa Rica.\n\n\n\n\nLos SIG presentan los datos en capas (layers). Por ejemplo, el mapa de la Figure 1.2 contiene una capa base raster (la que muestra el mar y el continente), una capa de polígonos correspondiente a las provincias de Costa Rica y una capa de puntos correspondiente a los aeródromos. A la izquierda puede apreciarse la lista de esas capas y a la derecha un cuadro con información detallada sobre uno de los aeródromos.\nLos SIG de escritorio (ej. ArcGIS Desktop, QGIS) son herramientas con interfaces de usuario muy gráficas e intuitivas, que no requieren de conocimientos de programación de computadoras y que permiten generar cartografía de alta calidad. Sin embargo, son poco flexibles y los resultados que producen son difícilmente reproducibles."
  },
  {
    "objectID": "01-introduccion-ciencia-datos-geoespaciales.html#ciencia-de-datos-geoespaciales",
    "href": "01-introduccion-ciencia-datos-geoespaciales.html#ciencia-de-datos-geoespaciales",
    "title": "1  Introducción a la ciencia de datos geoespaciales",
    "section": "1.4 Ciencia de datos geoespaciales",
    "text": "1.4 Ciencia de datos geoespaciales\nDurante la última década, el uso de SIG se ha complementado con el de ciencia de datos, lo que posibilitado enriquecer la visualización y el análisis de datos geoespaciales mediante lenguajes de programación como Python, R o JavaScript, entre otros.\nEl uso de técnicas de ciencia de datos y de otros campos relacionados (ej. aprendizaje automatizado, big data) ha permitido aplicar a los datos geoespaciales técnicas y metodologías como análisis de regresión y clasificación estadística."
  },
  {
    "objectID": "01-introduccion-ciencia-datos-geoespaciales.html#reproducibilidad",
    "href": "01-introduccion-ciencia-datos-geoespaciales.html#reproducibilidad",
    "title": "1  Introducción a la ciencia de datos geoespaciales",
    "section": "1.5 Reproducibilidad",
    "text": "1.5 Reproducibilidad\nUna de las principales características que distingue al enfoque de ciencia de datos del enfoque de SIG es la reproducibilidad. En general, la reproducibilidad es la capacidad de un ensayo o experimento de ser reproducido por otros. Más formalmente, en investigación cuantitativa, un análisis se considera reproducible si “el código fuente y los datos utilizados por un investigador para llegar a un resultado están disponibles y son suficientes para que otro investigador, trabajando de manera independiente, pueda llegar al mismo resultado” (Gandrud 2020).\nLa reproducibilidad, junto con la falsabilidad, es uno de los pilares del método científico. Sin embargo, en años recientes, se ha generado una creciente preocupación debido a que muchos estudios científicos publicados fallan las pruebas de reproducibilidad (véase, por ejemplo, The Excel Depression, de Paul Krugman), dando lugar a una crisis de reproducibilidad o replicabilidad en varias ciencias.\nEl concepto de reproducibilidad es cada vez más importante debido, entre otras razones, al aumento exponencial de datos disponibles y a la aplicación de la programación de computadoras, para procesar estos datos, por parte de especialistas de muchas disciplinas.\nAlex Singleton y otros autores (Singleton, Spielman, and Brunsdon 2016) han identificado los siguientes retos para la reproducibilidad en ciencia de datos geoespaciales:\n\nLos datos deben ser de dominio público y estar disponibles para los investigadores.\nEl software utilizado debe ser de código abierto (open source) y estar disponible para ser revisado.\nSiempre que sea posible, los flujos de trabajo deben ser públicos y con enlaces a los datos, software y métodos de análisis, junto con la documentación necesaria.\nEl proceso de revisión por pares (peer review process) y la publicación académica deben requerir la presentación de un modelo de flujo de trabajo e idealmente la disponibilidad de los materiales necesarios para la replicación.\nEn los casos en los que la reproducibilidad total no sea posible (ej. datos sensibles), los investigadores deben esforzarse por incluir todos los aspectos que puedan de un marco de trabajo abierto.\n\nEn general, el estándar mínimo de reproducibilidad requiere que los datos y el código fuente estén disponibles para otros investigadores (Peng 2011). Sin embargo, dependiendo de las circunstancias y recursos disponibles, existe todo un espectro de posibilidades, que se ilustra en la Figure 1.3.\n\n\n\n\n\nFigure 1.3: Espectro de reproducibilidad. Imagen de Anita Graser, con base en (Peng, 2001).\n\n\n\n\n\n1.5.1 Herramientas para facilitar la reproducibilidad\nEn esta sección se destacan dos tipos de herramientas que en la actualidad se consideran esenciales para apoyar la reproducibilidad de una investigación: los lenguajes de marcado y los sistemas de control de versiones.\nLa documentación es vital durante todo el ciclo de vida de una investigación reproducible. Para documentar, se recomienda utilizar mecanismos estandarizados y abiertos como el lenguaje de marcado de hipertexto (HTML, en inglés, HyperText Markup Language) o Markdown, con los cuales pueden crearse documentos mediante editores de texto simples (i.e. no se requiere de software propietario), y exportables a varios formatos (ej. LaTeX, PDF).\nPara dar mantenimiento, tanto al código fuente como a la documentación, es necesario un sistema de control de versiones como Git, el cual permite llevar el registro de los cambios en archivos y también facilita el trabajo colaborativo al reunir las modificaciones hechas por varias personas. Git es usado en varias plataformas que comparten código fuente (ej. GitHub, GitLab) y que ofrecen servicios relacionados, como hospedaje de sitios web.\n\n\n\n\nGandrud, Christopher. 2020. Reproducible Research with R and RStudio. Third edition. The R Series. Boca Raton, FL: CRC Press.\n\n\nLongley, Paul A., Michael F. Goodchild, David J. Maguire, and David W. Rhind. 2005. Geographic Information Systems and Science. 2nd edition. Chichester ; Hoboken, NJ: Wiley.\n\n\nOlaya, Víctor. 2020. “Sistemas de Información Geográfica.” https://volaya.github.io/libro-sig/.\n\n\nPeng, Roger D. 2011. “Reproducible Research in Computational Science.” Science 334 (6060): 1226–27. https://doi.org/10.1126/science.1213847.\n\n\nSingleton, Alex David, Seth Spielman, and Chris Brunsdon. 2016. “Establishing a Framework for Open Geographic Information Science.” International Journal of Geographical Information Science 30 (8): 1507–21. https://doi.org/10.1080/13658816.2015.1137579."
  },
  {
    "objectID": "02-markdown.html",
    "href": "02-markdown.html",
    "title": "2  Markdown - lenguaje de marcado",
    "section": "",
    "text": "Markdown Tutorial. (s. f.). Recuperado 19 de marzo de 2022, de https://www.markdowntutorial.com/\n\n\n\n\nInstale en su computadora el sistema base del lenguaje R y luego el ambiente integrado de desarrollo RStudio Desktop.\nCree una cuenta gratuita en la plataforma de desarrollo colaborativo GitHub."
  },
  {
    "objectID": "02-markdown.html#resumen",
    "href": "02-markdown.html#resumen",
    "title": "2  Markdown - lenguaje de marcado",
    "section": "2.2 Resumen",
    "text": "2.2 Resumen\nMarkdown es un lenguaje de marcado ligero ampliamente utilizado en comunicación científica, documentación de programas e investigación reproducible."
  },
  {
    "objectID": "02-markdown.html#descripción-general",
    "href": "02-markdown.html#descripción-general",
    "title": "2  Markdown - lenguaje de marcado",
    "section": "2.3 Descripción general",
    "text": "2.3 Descripción general\nMarkdown es un lenguaje de marcado creado en 2004 por John Gruber. Las “marcas” se utilizan para brindar información acerca de la presentación (ej. negritas, itálicas) o la estructura (ej. títulos, encabezados) de un documento. Se caracteriza por ser más sencillo de leer y de usar que otros lenguajes de marcado (ej. Lenguaje de marcado de Hipertexto o HTML), por lo que se considera un lenguaje de marcado ligero. Los documentos escritos en Markdown pueden exportarse a una gran variedad de formatos (ej. HTML, DOC, PDF, LaTex) para ser usados en libros, presentaciones o páginas web, entre otros. Markdown es ampliamente utilizado en comunicación científica, documentación de programas e investigación reproducible."
  },
  {
    "objectID": "02-markdown.html#variaciones",
    "href": "02-markdown.html#variaciones",
    "title": "2  Markdown - lenguaje de marcado",
    "section": "2.4 Variaciones",
    "text": "2.4 Variaciones\nLas variaciones de Markdown, también llamadas flavors, son extensiones o modificaciones de la especificación original. Entre las más populares están:\n\nR Markdown: para el lenguaje R.\nGitHub Flavored Markdown: para la plataforma GitHub.\nPython Markdown: para el lenguaje Python.\nPandoc’s Markdown: para el programa Pandoc de conversión entre formatos.\nKramdown: para el lenguaje Ruby.\n\nPuede verse una lista más extensa en https://github.com/commonmark/commonmark-spec/wiki/markdown-flavors."
  },
  {
    "objectID": "02-markdown.html#sintaxis",
    "href": "02-markdown.html#sintaxis",
    "title": "2  Markdown - lenguaje de marcado",
    "section": "2.5 Sintaxis",
    "text": "2.5 Sintaxis\nLa sintaxis de Markdown permite especificar diferentes componentes de un documento, entre los que están:\n\nEncabezados.\nEstilos (ej. negritas, itálicas).\nCitas textuales.\nEnlaces a otros documentos (ej. páginas web).\nImágenes.\nListas.\n\n\n2.5.1 Encabezados\nPueden definirse seis niveles de encabezados, mediante símbolos de numeral (#) antes del texto. El primer nivel es el de tamaño de texto más grande y el sexto el más pequeño. En la parte izquierda de la Figure 2.1 se muestra la sintaxis Markdown de los encabezados y a la derecha la forma en que se despliegan en un documento.\n\n\n\n\n\nFigure 2.1: Sintaxis de Markdown - encabezados.\n\n\n\n\n\n\n2.5.2 Itálicas\nSe definen con un asterisco (*) antes y después del texto o con un guión bajo (_) antes y después del texto.\n\n\n\n\n\nFigure 2.2: Sintaxis de Markdown - itálicas.\n\n\n\n\n\n\n2.5.3 Negritas\nSe definen con dos asteriscos (**) antes y después del texto o con dos guiones bajos (__) antes y después del texto.\n\n\n\n\n\nFigure 2.3: Sintaxis de Markdown - negritas.\n\n\n\n\n\n\n2.5.4 Citas textuales\nSe definen con un símbolo de “mayor que” (>) antes de cada línea.\n\n\n\n\n\nFigure 2.4: Sintaxis de Markdown - citas textuales.\n\n\n\n\n\n\n2.5.5 Enlaces (hipervínculos)\nSe definen con paréntesis cuadrados ([]) seguidos de paréntesis redondos (()). En los paréntesis cuadrados se coloca (opcionalmente) el texto del enlace y en los redondos la dirección del documento.\n\n\n\n\n\nFigure 2.5: Sintaxis de Markdown - enlaces.\n\n\n\n\n\n\n2.5.6 Imágenes\nSe definen con un signo de admiración de cierre (!), paréntesis cuadrados ([]) y paréntesis redondos (()). En los paréntesis cuadrados se coloca (opcionalmente) un texto alternativo de la imagen y en los redondos la dirección de la imagen, ya sea local o remota.\n\n\n\n\n\nFigure 2.6: Sintaxis de Markdown - imágenes.\n\n\n\n\n\n\n2.5.7 Listas numeradas\nSe definen con números (1. 2. 3. ...) antes de cada elemento.\n\n\n\n\n\nFigure 2.7: Sintaxis de Markdown - listas numeradas.\n\n\n\n\n\n\n2.5.8 Listas no numeradas\nSe definen con guiones (-) o asteriscos (*) antes de cada elemento.\n\n\n\n\n\nFigure 2.8: Sintaxis de Markdown - listas no numeradas.\n\n\n\n\n\n\n2.5.9 Otros elementos de sintaxis\nPara conocer otros elementos de la sintaxis de Markdown, se recomienda revisar en detalle la Guía de referencia de Markdown."
  },
  {
    "objectID": "02-markdown.html#ejercicios",
    "href": "02-markdown.html#ejercicios",
    "title": "2  Markdown - lenguaje de marcado",
    "section": "2.6 Ejercicios",
    "text": "2.6 Ejercicios\n\nCree un documento Markdown llamado README.md, en RStudio, y escriba en este un breve perfil académico (curriculum académico).\n\nIncluya información como: nombre, fotografía, datos de contacto, áreas de interés, carrera, cursos aprobados, publicaciones, etc.\nPuede usar información ficticia (no incluya datos confidenciales o sensibles).\nEspecifique la fuente de las imágenes (y de cualquier otra información para la que sea necesario) y no utilice imágenes para las que no tiene autorización. Considere utilizar sitios con imágenes con licencias abiertas (ej. Wikimedia Commons, Unsplash, FreeImages).\nAsegúrese de utilizar los siguientes elementos de sintaxis Markdown:\n\nVarios niveles de encabezados.\nNegritas e itálicas.\nListas.\nEnlaces a sitios web.\nImágenes (al menos una local y una remota).\n\n\nCree un repositorio en GitHub llamado perfil-academico y suba a este el documento que creó en el paso 1.\nCree un sitio web en GitHub Pages con el repositorio creado en el paso 2."
  },
  {
    "objectID": "02-markdown.html#recursos-de-interés",
    "href": "02-markdown.html#recursos-de-interés",
    "title": "2  Markdown - lenguaje de marcado",
    "section": "2.7 Recursos de interés",
    "text": "2.7 Recursos de interés\nCarrera Arias, F. J. (2020). How to Install R on Windows, Mac OS X, and Ubuntu Tutorial. DataCamp Community. https://www.datacamp.com/community/tutorials/installing-R-windows-mac-ubuntu\nMarkdown Guide. (s. f.). Recuperado 10 de abril de 2022, de https://www.markdownguide.org/"
  },
  {
    "objectID": "03-git.html",
    "href": "03-git.html",
    "title": "3  Git - sistema de control de versiones",
    "section": "",
    "text": "Abba, I. V. (2021). Git and GitHub Tutorial – Version Control for Beginners. FreeCodeCamp.Org. https://www.freecodecamp.org/news/git-and-github-for-beginners/\n\n\n\nInstale en su computadora el sistema de control de versiones Git."
  },
  {
    "objectID": "03-git.html#resumen",
    "href": "03-git.html#resumen",
    "title": "3  Git - sistema de control de versiones",
    "section": "3.2 Resumen",
    "text": "3.2 Resumen\nGit es un sistema para administrar versiones de código fuente o, en general, de cualquier conjunto de archivos."
  },
  {
    "objectID": "03-git.html#descripción-general",
    "href": "03-git.html#descripción-general",
    "title": "3  Git - sistema de control de versiones",
    "section": "3.3 Descripción general",
    "text": "3.3 Descripción general\nGit es un sistema de control de versiones diseñado para “rastrear” cambios en el código fuente durante el proceso de desarrollo de software. Sin embargo, puede ser utilizado para llevar el control de los cambios en cualquier conjunto de archivos (ej. documentación, música).\nUn sistema de control de versiones proporciona, entre otras ventajas:\n\nLa capacidad de recuperar versiones anteriores de los archivos.\nLa capacidad de integrar modificaciones efectuadas por varias personas en el mismo conjunto de archivos.\nLa capacidad de mantener varias “ramas” (branches) de un producto (ej. “estable”, “evaluación”, “inestable”, como en el caso de Debian Linux, GRASS GIS y muchos otros proyectos de software libre).\nFacilidades para mantener redundancia y respaldos de los archivos (ej. Programa de respaldos de GitHub). Esta es una facilidad que implementan algunos servicios en la nube.\n\nGit fue diseñado por Linus Torvalds en 2005 durante del desarrollo del kernel del sistema operativo Linux. Se caracteriza por ser un sistema de control de versiones distribuido, lo que significa que el código fuente puede estar alojado en la estación de trabajo de cualquier miembro del equipo de desarrollo. No se requiere de un repositorio “central”, pero también se puede trabajar de esa forma.\nEl protocolo de Git es utilizado en varios sitios que proveen servicios de alojamiento de software, entre los que están SourceForge, Bitbucket, GitLab y GitHub."
  },
  {
    "objectID": "03-git.html#funcionamiento-de-git",
    "href": "03-git.html#funcionamiento-de-git",
    "title": "3  Git - sistema de control de versiones",
    "section": "3.4 Funcionamiento de Git",
    "text": "3.4 Funcionamiento de Git\nDesde el punto de vista de un usuario de Git (ej. un programador), Git se utiliza para sincronizar la versión local (i.e. en una computadora personal) de un conjunto de archivos, llamado proyecto o repositorio, con la versión que está alojada en un sistema remoto (ej. GitHub). Cada repositorio se almacena en un directorio (carpeta) del sistema operativo. La sincronización se realiza principalmente a través de dos operaciones:\n\npush: para “subir” al repositorio remoto los cambios realizados en el repositorio local. Esta operación se realiza mediante el comando git push. Es probable que el sistema remoto le solicite al usuario algún tipo de autenticación (ej. nombre de usuario y clave).\npull: para “bajar” al repositorio local los cambios realizados en el repositorio remoto. Esta operación se realiza mediante el comando git pull.\n\nLas operaciones push y pull se ilustran en la Figure 3.1.\n\n\n\n\n\nFigure 3.1: Operaciones push y pull. Imagen de Melinda Higgins.\n\n\n\n\nAntes de un push, el usuario debe seleccionar los archivos que desea subir mediante el comando git add, el cual pasa los archivos a un “área de espera” (staging area). Luego debe usarse el comando git commit para “guardar” los cambios pendientes en el área de espera. Cada commit guarda el estado del conjunto de archivos en un momento específico (snapshot).\nLa relación entre estas operaciones de Git, se ilustra en la Figure 3.2.\n\n\n\n\n\nFigure 3.2: Operaciones de Git. Imagen de Steven Klavins.\n\n\n\n\nEn la Figure 3.3, se muestra el funcionamiento de Git mediante una comparación con el procesamiento de una compra en línea.\n\n\n\n\n\nFigure 3.3: Operaciones de Git y compras en línea. Imagen de Melinda Higgins.\n\n\n\n\nOtras operaciones de Git de uso frecuente son:\n\ngit config: para especificar opciones globales de la sesión de Git (ej. nombre del usuario, dirección de correo electrónico).\ngit init: para inicializar un repositorio git.\ngit clone: para clonar (i.e. copiar) un repositorio remoto en la computadora local.\ngit status: para revisar el estado de los archivos y, por ejemplo, saber cuales deben pasarse al área de espera.\ngit log: para revisar el historial de commits.\ngit show: para visualizar los cambios efectuados en los commits.\ngit reset: para regresar al estado correspondiente a un commit anterior."
  },
  {
    "objectID": "03-git.html#ejemplos-de-uso",
    "href": "03-git.html#ejemplos-de-uso",
    "title": "3  Git - sistema de control de versiones",
    "section": "3.5 Ejemplos de uso",
    "text": "3.5 Ejemplos de uso\n\n3.5.1 Clonación de un repositorio remoto y sincronización de los cambios efectuados localmente\nPara seguir este ejemplo:\n\nObtenga un token de GitHub en la siguiente opción de menú de su perfil de usuario: Settings - Developer settings - Personal access tokens. Seleccione las operaciones de tipo “repo”. Copie el token en un lugar seguro, ya que lo necesitará para autenticarse en GitHub.\nRealice un fork a su cuenta en GitHub del repositorio localizado en la dirección https://github.com/pf0953-programacionr/2022-ii-tutorial-git-repo-ejemplo. Obtendrá un repositorio llamado “https://github.com/[nombre-usuario]/2022-ii-tutorial-git-repo-ejemplo”, en donde [nombre-usuario] es su nombre de usuario en GitHub.\nCon la opción File - New Project - Version Control - Git de RStudio, clone a su computadora el repositorio que acaba de bifurcar.\nCon el editor de RStudio, abra el archivo README.md, agregue una línea y guarde el archivo.\nLuego, ejecute los siguientes comandos desde la la ventana Terminal de RStudio. Nota: las líneas que empiezan con # son comentarios.\n\n# a. Parámetros de configuración: nombre y dirección de correo del usuario.\n#    Debe cambiar [email-usuario] y [nombre-usuario] por sus propios datos.\ngit config --global user.email [email-usuario]\ngit config --global user.name [nombre-usuario]\n# Para revisar los parámetros de configuración:\ngit config --global --list\n\n# b. Revisión de los archivos con modificaciones.\ngit status\n\n# c. Adición (add) de los archivos modificados al \"área de espera\".\n#    El punto (.) indica que se agregarán todos los archivos modificados.\ngit add .\n\n# d. Grabado (commit) del conjunto de archivos modificados,\n#    junto con un mensaje explicativo:\ngit commit -m \"Agregar línea 2\"\n\n# e. \"Subida\" (push) de las modificaciones al repositorio remoto.\n#    En este paso, es posible que deba utilizar su nombre de usuario/clave\n#    o su token de GitHub para autenticarse.\ngit push\n\nRevise los cambios aplicados en el repositorio remoto en GitHub.\nAgregue más líneas al archivo del repositorio local y sincronícelo con el remoto, realizando nuevamente los pasos del b al e para cada commit. Recuerde que los comentarios de cada commit deben reflejar los cambios que están siendo aplicados."
  },
  {
    "objectID": "03-git.html#recursos-de-interés",
    "href": "03-git.html#recursos-de-interés",
    "title": "3  Git - sistema de control de versiones",
    "section": "3.6 Recursos de interés",
    "text": "3.6 Recursos de interés\nGit. (s. f.). Recuperado 28 de agosto de 2022, de https://git-scm.com/\nGitHub Archive Program. (s. f.). GitHub Archive Program. Recuperado 10 de abril de 2022, de https://archiveprogram.github.com/\nHiggins, M. (s. f.). Reproducible Templates for Analysis and Dissemination. Coursera. Recuperado 11 de abril de 2022, de https://www.coursera.org/learn/reproducible-templates-analysis\nKlavins, S. (2020). Version Control part 1. Medium. https://stevenklavins94.medium.com/version-control-part-1-c5f1b43127f6"
  },
  {
    "objectID": "04-pensamiento_computacional-arquitectura_computadoras.html",
    "href": "04-pensamiento_computacional-arquitectura_computadoras.html",
    "title": "4  Pensamiento computacional y arquitectura de computadoras",
    "section": "",
    "text": "Wing, J. M. (2006). Computational thinking. Communications of the ACM, 49(3), 33-35. https://doi.org/10.1145/1118178.1118215"
  },
  {
    "objectID": "04-pensamiento_computacional-arquitectura_computadoras.html#resumen",
    "href": "04-pensamiento_computacional-arquitectura_computadoras.html#resumen",
    "title": "4  Pensamiento computacional y arquitectura de computadoras",
    "section": "4.2 Resumen",
    "text": "4.2 Resumen\nEl pensamiento computacional es un enfoque para la resolución de problemas basado en conceptos y métodos de las ciencias de la computación. Los principios fundamentales del pensamiento computacional son:\n\nDescomposición: división de un problema en subproblemas más pequeños.\nReconocimiento de patrones: búsqueda de similitudes en los problemas.\nAbstracción: identificación de la información que se necesita y filtrado de la que no se necesita para resolver un problema.\nAlgoritmos: descripción, paso por paso, de la solución a un problema.\n\nLas computadoras modernas están construídas con base en circuitos integrados (CI), también llamados chips o microchips. Los CI procesan información digital (que usa valores discretos), la cual generalmente es binaria (i.e. de dos valores). Los CI de una computadora procesan dos estados correspondientes a dos niveles de tensión eléctrica: alto y bajo. Estos estados se representan con 0 y 1. Esto facilita la aplicación de la lógica binaria y de la aritmética binaria.\nDurante el período entre las guerras mundiales, Allan Turing desarrolló la máquina de Turing, un dispositivo teórico que manipula símbolos de una cinta de acuerdo con una tabla de reglas. La máquina de Turing simula el funcionamiento de un algoritmo y los conceptos de entrada, procesamiento y salida. En 1945, John von Neumann propuso un concepto conocido como programa almacenado, en el cual los datos y los programas se almacenan en una estructura llamada memoria, separada del hardware que ejecuta las instrucciones. Este modelo permite que las computadoras sean más fáciles de reprogramar y es conocido actualmente como arquitectura de von Neumann.\nEl lenguaje máquina es un conjunto de instrucciones binarias interpretables por un CPU. Las instrucciones representan acciones a ser ejecutadas por la computadora. Cada CPU tiene su propio lenguaje máquina. Un programa consiste de una secuencia de instrucciones en lenguaje máquina.\nDebido a que programar una computadora en lenguaje máquina es excesivamente lento y complicado, en la década de 1950 comenzaron a crearse lenguajes de programación que, en lugar de unos y ceros, consisten de instrucciones formadas por palabras, usualmente en idioma inglés. Existe una gran variedad de lenguajes de programación que han sido creados con diversos fines: científicos, comerciales, educacionales, etc."
  },
  {
    "objectID": "04-pensamiento_computacional-arquitectura_computadoras.html#diapositivas",
    "href": "04-pensamiento_computacional-arquitectura_computadoras.html#diapositivas",
    "title": "4  Pensamiento computacional y arquitectura de computadoras",
    "section": "4.3 Diapositivas",
    "text": "4.3 Diapositivas\nPensamiento computacional y arquitectura de computadoras"
  },
  {
    "objectID": "05-r-conceptos_basicos.html",
    "href": "05-r-conceptos_basicos.html",
    "title": "5  R - conceptos básicos",
    "section": "",
    "text": "Grolemund, G., & Wickham, H. (2014). Hands-On Programming with R: Write Your Own Functions And Simulations (capítulos 1 - 12). O’Reilly Media. https://rstudio-education.github.io/hopr/"
  },
  {
    "objectID": "05-r-conceptos_basicos.html#resumen",
    "href": "05-r-conceptos_basicos.html#resumen",
    "title": "5  R - conceptos básicos",
    "section": "5.2 Resumen",
    "text": "5.2 Resumen\nEn esta lección, se estudiarán los conceptos básicos del lenguaje de programación R, incluyendo:\n\nCaracterísticas generales de R.\nEl ambiente de desarrollo RStudio.\nFunciones y paquetes.\nTipos de datos.\nDefinición de funciones.\nCondicionales.\nCiclos."
  },
  {
    "objectID": "05-r-conceptos_basicos.html#características-generales",
    "href": "05-r-conceptos_basicos.html#características-generales",
    "title": "5  R - conceptos básicos",
    "section": "5.3 Características generales",
    "text": "5.3 Características generales\nR es un lenguaje de programación enfocado en análisis estadístico. Es ampliamente utilizado en diversas áreas de investigación, entre las que pueden mencionarse aprendizaje automático (machine learning), ciencia de datos (data science) y big data, con aplicaciones en campos como biomedicina, bioinformática y finanzas, entre muchos otros. Fue creado por Ross Ihaka y Robert Gentleman en la Universidad de Auckland, Nueva Zelanda, en 1993.\nAlgunas de las principales características de este lenguaje son:\n\nEs interpretado: las instrucciones se traducen una por una a lenguaje máquina, a diferencia de los lenguajes compilados, que traducen de manera conjunta las instrucciones de una unidad completa (ej. un programa o una biblioteca). Los lenguajes interpretados tienden a ser más lentos que los compilados, pero también son más flexibles.\nEs multiplataforma: puede ejecutarse en los sistemas operativos más populares (ej. Microsoft Windows, macOS, Linux).\nTiene un sistema de tipos de datos dinámico: las variables pueden tomar diferentes tipos de datos (ej. textuales, numéricos) durante la ejecución del programa, a diferencia del caso de un sistema de tipos de datos estático, en el que las variables solo pueden tener un tipo de datos.\nSoporta varios paradigmas de programación: los paradigmas son estilos o enfoques teóricos de programación. R soporta los paradigmas de programación funcional, programación orientada a objetos, programación imperativa y programación procedimental.\n\nR es un proyecto de software libre que se comparte mediante una licencia GNU General Public Licence (GNU GPL). Esta característica permite que la funcionalidad original de R pueda ser ampliada mediante bibliotecas o paquetes desarrollados por la comunidad de programadores.\nPara programar en R, puede utilizarse una interfaz de línea de comandos, editores de texto (ej. Visual Studio Code, Vim) y también ambientes de desarrollo integrados (IDE, integrated development environment) como Jupyter o RStudio."
  },
  {
    "objectID": "05-r-conceptos_basicos.html#el-ambiente-de-desarrollo-integrado-rstudio",
    "href": "05-r-conceptos_basicos.html#el-ambiente-de-desarrollo-integrado-rstudio",
    "title": "5  R - conceptos básicos",
    "section": "5.4 El ambiente de desarrollo integrado RStudio",
    "text": "5.4 El ambiente de desarrollo integrado RStudio\nRStudio es el IDE más popular para el lenguaje R. Está disponible en una versión de escritorio (RStudio Desktop) y en una versión para servidor (RStudio Server). Esta última permite la conexión de varios usuarios a través de un navegador web. RStudio se ofrece también como un servicio en la nube, a través de RStudio Cloud.\nLa Figure 5.1 muestra la interfaz de RStudio.\n\n\n\n\n\nFigure 5.1: Interfaz del ambiente de desarrollo integrado RStudio.\n\n\n\n\nAdemás de edición de código fuente en R (y otros lenguajes), RStudio contiene capacidades para depurar código y visualizar datos en formatos tabulares, gráficos y de mapas."
  },
  {
    "objectID": "05-r-conceptos_basicos.html#conjuntos-de-datos-para-pruebas",
    "href": "05-r-conceptos_basicos.html#conjuntos-de-datos-para-pruebas",
    "title": "5  R - conceptos básicos",
    "section": "5.5 Conjuntos de datos para pruebas",
    "text": "5.5 Conjuntos de datos para pruebas\nPara efectos de pruebas y ejemplos, la distribución base de R incorpora varios conjuntos de datos que pueden listarse con la función data(). Para obtener información acerca de un conjunto de datos en particular, puede utilizarse el operador ?.\n\n# Información sobre todos los conjuntos de datos incorporados en la distribución base de R\ndata()\n\n# Información sobre el cojunto de datos \"cars\"\n?cars\n\n# Información sobre el cojunto de datos \"mtcars\"\n?mtcars\n\n# Información sobre el cojunto de datos \"Iris\"\n?iris"
  },
  {
    "objectID": "05-r-conceptos_basicos.html#funciones",
    "href": "05-r-conceptos_basicos.html#funciones",
    "title": "5  R - conceptos básicos",
    "section": "5.6 Funciones",
    "text": "5.6 Funciones\nR, al igual que otros lenguajes de programación, estructura su funcionalidad en unidades de código fuente llamadas funciones. Cada función realiza una tarea específica como, por ejemplo, un cálculo matemático y, por lo general, retorna un valor como salida. Todas las funciones tienen un nombre y, opcionalmente, un conjunto de argumentos que especifican los datos de entrada que procesa la función. Los argumentos se escriben entre paréntesis redondos (()) y estos siempre deben incluirse, aún en el caso de que la función no tenga ningún argumento. Si la función tiene varios argumentos, deben separarse mediante comas (,).\n\n5.6.1 Ejemplos\nLa función print() recibe como argumento un valor (ej. un texto o un número) para imprimirlo en la pantalla. En el siguiente fragmento de código en R, se utiliza print() para imprimir la hilera “Hola mundo”. Nótese el uso del símbolo # para comentarios (i.e. texto que no es código ejecutable).\n\n# Impresión de una hilera de caracteres\nprint(\"Hola mundo\")\n\n[1] \"Hola mundo\"\n\n\nLa función mean() retorna la media aritmética del argumento de entrada. En el siguiente ejemplo, se calcula la media de los números de un vector creado a su vez con la función c().\n\n# Media aritmética\nmean(c(2, 4, 5, 9))\n\n[1] 5\n\n\nLa función getwd() (get working directory) retorna la ruta del directorio de trabajo de la sesión actual de R. Este es el directorio en el cual R espera encontrar, por ejemplo, archivos de datos.\n\n# Impresión del directorio de trabajo\ngetwd()\n\n[1] \"/home/mfvargas/pf0953-programacionr/2022-ii/github/2022-ii\"\n\n\nLa función setwd() (set working directory) establece la ruta del directorio de trabajo de la sesión actual de R. Como argumento, recibe una hilera de texto con la ruta.\nNote las barras utilizadas para separar los subdirectorios: / (no \\)\n\n# Especificación del directorio de trabajo (la ruta debe existir)\nsetwd(\"C:/Users/mfvargas\")\n\n\n\n5.6.2 Ejercicios\n\nObtenga la ruta de su directorio de trabajo con la función getwd().\n\nSi lo desea, cambie la ruta de su directorio de trabajo con la función setwd(). Verifique el cambio usando nuevamente getwd().\n\n\n\n5.6.3 Argumentos\nLos argumentos de las funciones tienen nombres que pueden especificarse, en caso de ser necesario. En algunos casos, el orden y el tipo de datos de los argumentos permiten que el interpretador de R conozca cuál es cada uno, sin necesidad de escribir sus nombres.\nEn el siguiente ejemplo, se utilizan los argumentos x, xlab y ylab de la función plot(), para especificar la fuente de datos y las etiquetas de los ejes x e y de un gráfico de dispersión.\n\n# Gráfico de dispersón del conjunto de datos \"cars\" con etiquetas en los ejes x e y\nplot(\n  x=cars, \n  xlab=\"Velocidad (mph)\", \n  ylab=\"Distancia requerida para frenar (pies)\"\n)\n\n\n\n\n\n\n5.6.4 Ejercicios\n\nEstudie la documentación de la función plot() y agregue al gráfico anterior:\n\nUn título.\nUn subtítulo.\n\n\n\n\n5.6.5 Ayuda\nPara obtener ayuda sobre una función desde la línea de comandos de R, puede utilizarse un signo de pregunta (?) seguido del nombre de la función o bien la función help(). Por ejemplo:\n\n# Ayuda de la función setwd()\n?setwd\nhelp(setwd)\n\nTambién puede utilizarse la función apropos(), para buscar funciones por palabras clave.\n\n# Búsqueda, por palabras clave, de funciones relacionadas con \"mean\" (media aritmética). Note las comillas (\"\").\napropos(\"mean\")\n\n [1] \".colMeans\"     \".rowMeans\"     \"colMeans\"      \"kmeans\"       \n [5] \"mean\"          \"mean.Date\"     \"mean.default\"  \"mean.difftime\"\n [9] \"mean.POSIXct\"  \"mean.POSIXlt\"  \"rowMeans\"      \"weighted.mean\"\n\n\nLa función example() presenta ejemplos sobre el uso de una función.\n\n# Ejemplos de uso de la función mean()\nexample(\"mean\")\n\n\nmean> x <- c(0:10, 50)\n\nmean> xm <- mean(x)\n\nmean> c(xm, mean(x, trim = 0.10))\n[1] 8.75 5.50\n\n\nPor otra parte, el sitio All R Documentation reúne documentación de funciones de una gran cantidad de paquetes de R. También puede obtenerse ayuda sobre una función en los buscadores de Internet (ej. Google), además de ejemplos, tutoriales y otros materiales de apoyo."
  },
  {
    "objectID": "05-r-conceptos_basicos.html#paquetes",
    "href": "05-r-conceptos_basicos.html#paquetes",
    "title": "5  R - conceptos básicos",
    "section": "5.7 Paquetes",
    "text": "5.7 Paquetes\nLas funciones de R se distribuyen en paquetes. Cada paquete contiene un conjunto de funciones y estructuras de datos relacionadas entre sí. También hay paquetes que contienen datos.\nPara utilizar un paquete, primero debe cargarse (en la memoria del computador) con la función library().\n\n# Carga del paquete stats\nlibrary(stats)\n\nAlgunos paquetes están contenidos en la distribución base de R. Otros deben instalarse con la función install.packages().\nEn el siguiente ejemplo, se instala el paquete PASWR2, el cual contiene el conjunto de datos TITANIC3 con una lista de pasajeros del Titanic.\n\n# Instalación del paquete PASWR2 (note las comillas)\ninstall.packages(\"PASWR2\")\n\nSeguidamente, el paquete PASWR2 se carga con la función library().\n\n# Carga de PASWR2\nlibrary(PASWR2)\n\nEl conjunto de datos TITANIC3 puede visualizarse con la función View().\n\n# Visualización del conjunto de datos TITANIC3\nView(TITANIC3)\n\nEl siguiente gráfico de barras muestra la distribución de pasajeros por clase, mediante la función barplot(). También se utiliza la función table() para generar una tabla con las cantidades de pasajeros que viajaban en cada clase.\n\n# Cantidades de pasajeros por clase\ntable(TITANIC3$pclass)\n## \n## 1st 2nd 3rd \n## 323 277 709\n\n# Gráfico de barras por clase de pasajero\nbarplot(\n  height=table(TITANIC3$pclass),\n  main=\"Distribución de pasajeros del Titanic por clase\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\"  \n)\n\n\n\n\nLa distribución por cada clase puede dividirse en fallecidos y sobrevivientes.\n\n# Cantidades de pasajeros fallecidos y sobrevivientes por clase\n# (0 corresponde a fallecidos y 1 a sobrevivientes)\ntable(TITANIC3$survived, TITANIC3$pclass)\n##    \n##     1st 2nd 3rd\n##   0 123 158 528\n##   1 200 119 181\n\nEl siguiente gráfico muestra en un gráfico de barras apiladas la distribución de pasajeros sobrevivientes y fallecidos en cada clase.\n\n# Gráfico de barras apiladas\nbarplot(\n  height = table(TITANIC3$survived, TITANIC3$pclass),\n  main = \"Distribución de pasajeros fallecidos y sobrevivientes por clase\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\",\n  col = topo.colors(2)\n)\n\n# Leyenda\nlegend(\n  x = \"topleft\",\n  inset = 0.03,\n  legend = c(\"Fallecidos\", \"Sobrevivientes\"),\n  fill = topo.colors(2),\n  horiz = TRUE\n)\n\n\n\n\nLa misma información se muestra seguidamente en un gráfico de barras agrupadas. Note el uso del argumento beside.\n\n# Gráfico de barras agrupadas\nbarplot(\n  height = table(TITANIC3$survived, TITANIC3$pclass),\n  main = \"Distribución de pasajeros fallecidos y sobrevivientes por clase\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\",  \n  col = topo.colors(2),\n  beside = TRUE\n)\n\n# Leyenda\nlegend(\n  x = \"topleft\",\n  inset = 0.03,\n  legend = c(\"Fallecidos\", \"Sobrevivientes\"),\n  fill = topo.colors(2),\n  horiz = TRUE\n)\n\n\n\n\n\n5.7.1 Ejercicios\n\nMuestre la distribución de pasajeros fallecidos y sobrevivientes por sexo en un gráfico de barras apiladas.\nMuestre la distribución de pasajeros fallecidos y sobrevivientes por sexo en un gráfico de barras agrupadas."
  },
  {
    "objectID": "05-r-conceptos_basicos.html#tipos-de-datos",
    "href": "05-r-conceptos_basicos.html#tipos-de-datos",
    "title": "5  R - conceptos básicos",
    "section": "5.8 Tipos de datos",
    "text": "5.8 Tipos de datos\nR puede trabajar con varios tipos de datos básicos, entre los que están números, caracteres (i.e. textos) y lógicos. También puede trabajar con tipos compuestos, como factores y data frames.\nR proporciona acceso a los datos a través de objetos. Un objeto es una entidad que tiene asociadas propiedades (i.e. datos) y métodos (i.e. funciones) para manipular esas propiedades. Un objeto puede ser, por ejemplo, un número, una hilera de texto, un vector o una matriz. R también permite que el programador defina sus propios objetos.\nHay muchas formas de crear objetos en R. Una de las más sencillas es con los operadores de asignación. Estos son = y <- (o ->). Por ejemplo, las siguientes sentencias crean un número, un texto y un vector.\n\n# Número\nx <- 10\nx\n## [1] 10\n\n# Otro número\n20 -> y\ny\n## [1] 20\n\n# Hilera de caracteres\nnombre <- 'Manuel'\nnombre\n## [1] \"Manuel\"\n\n# Vector de hileras de caracteres\ndias <- c('Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado')\ndias\n## [1] \"Domingo\"   \"Lunes\"     \"Martes\"    \"Miércoles\" \"Jueves\"    \"Viernes\"  \n## [7] \"Sábado\"\n\nTanto x, como nombre como dias son variables. Una variable es una etiqueta que se le asigna a un objeto. Una variable debe comenzar con una letra.\nEl tipo de un objeto puede consultarse con la función typeof(). Por ejemplo:\n\ntypeof(x)\n## [1] \"double\"\ntypeof(y)\n## [1] \"double\"\ntypeof(nombre)\n## [1] \"character\"\ntypeof(dias)\n## [1] \"character\"\n\nA continuación, se describen con más detalle algunos de los tipos de datos utilizados en el lenguaje R.\n\n5.8.1 Tipos básicos\nR define seis tipos de datos básicos. En esta sección, se describen los más utilizados durante este curso.\n\n5.8.1.1 Números\nPueden ser enteros (integer) o decimales (double). Se utilizan en diversos tipos de operaciones, incluyendo las aritméticas (ej. suma, resta, multiplicación, división).\n\n# Declaración de variables numéricas\nx <- 5\ny <- 0.5\n\n# Suma\nx + y\n## [1] 5.5\n\n# Tipos de datos numéricos\ntypeof(x)\n## [1] \"double\"\ntypeof(y)\n## [1] \"double\"\ntypeof(x + y)\n## [1] \"double\"\n\nNótese que al declararse una variable numérica, ya sea que tenga o no punto decimal, R la considera por defecto de tipo double. Para que se considere de tipo integer, debe utilizarse el sufijo L o la función as.integer().\n\n# Números enteros\nx <- 10L\ny <- as.integer(15)\n\n# Multiplicación\nx * y\n## [1] 150\n\n# Tipos de datos enteros\ntypeof(x)\n## [1] \"integer\"\ntypeof(y)\n## [1] \"integer\"\ntypeof(x * y)\n## [1] \"integer\"\n\n\n\n5.8.1.2 Caracteres\nSe utilizan para representar textos. Deben estar entre comillas simples ('') o dobles (\"\").\n\n# Hileras de caracteres\nnombre <- \"María\"\napellido <- \"Pérez\"\n\n# Concatenación mediante la función paste()\npaste(nombre, apellido)\n## [1] \"María Pérez\"\n\n\n\n5.8.1.3 Lógicos\nLos objetos lógicos (también llamados booleanos) tienen dos posibles valores: verdadero (TRUE) o falso (FALSE).\n\n# Variable lógica\na <- 1 < 2\na\n## [1] TRUE\n\n# Variable lógica\nb <- 1 > 2\nb\n## [1] FALSE\n\nLas expresiones lógicas pueden combinarse con operadores como:\n\n& (Y, en inglés AND)\n| (O, en inglés OR)\n! (NO, en inglés NOT)\n\n\n# Operador lógico AND\n(1 < 2) & (3 < 4)\n## [1] TRUE\n\n# Operador lógico OR\n(2 + 2 == 5) | (20 <= 10)\n## [1] FALSE\n\n# Operador lógico NOT\n!(2 + 2 == 5)\n## [1] TRUE\n\n\n\n5.8.1.4 Vectores\nUn vector es una estructura unidimensional que combina objetos del mismo tipo.\n\n5.8.1.4.1 Definición\nLos vectores pueden definirse de varias formas como, por ejemplo, con la función c() (del inglés combine):\n\n# Definición de un vector de números\nvector_numeros <- c(1, 7, 32, 45, 57)\nvector_numeros\n## [1]  1  7 32 45 57\n\n# Definición de un vector de hileras de caracteres\nvector_nombres <- c(\"Álvaro\", \"Ana\", \"Berta\", \"Bernardo\")\nvector_nombres\n## [1] \"Álvaro\"   \"Ana\"      \"Berta\"    \"Bernardo\"\n\nLos vectores también pueden crearse con el operador :, el cual especifica una secuencia (i.e. una lista ordenada):\n\n# Definición de un vector de números con la secuencia de 1 a 10\nvector_secuencia <- 1:10\nvector_secuencia\n##  [1]  1  2  3  4  5  6  7  8  9 10\n\n# Definición de un vector de números con la secuencia de -5 a 5\nvector_secuencia <- -5:5\nvector_secuencia\n##  [1] -5 -4 -3 -2 -1  0  1  2  3  4  5\n\n# Definición de un vector de números con la secuencia de -0.5 a 3.7\nvector_secuencia <- -0.5:3.7\nvector_secuencia\n## [1] -0.5  0.5  1.5  2.5  3.5\n\nLa función seq() también crea un vector con base en una secuencia y permite especificar argumentos como un valor de incremento y la longitud de la secuencia.\n\n# Definición de un vector de números en secuencia de 1 a 10\nvector_secuencia <- seq(1, 10)\nvector_secuencia\n##  [1]  1  2  3  4  5  6  7  8  9 10\n\n# Definición de un vector de números en secuencia de 0.5 a 15.3, con incremento de 2\nvector_secuencia <- seq(from=0.5, to=15.3, by=2)\nvector_secuencia\n## [1]  0.5  2.5  4.5  6.5  8.5 10.5 12.5 14.5\n\n# Definición de un vector de números en secuencia de 1.5 a 9.4, con longitud de 4\nvector_secuencia <- seq(from=1.5, to=9.4, length.out=4)\nvector_secuencia\n## [1] 1.500000 4.133333 6.766667 9.400000\n\n\n\n5.8.1.4.2 Indexación\nLos elementos de un vector se acceden a través de sus índices (i.e. posiciones). La primera posición corresponde al índice 1, la segunda al índice 2 y así sucesivamente. Los índices se especifican entre paréntesis cuadrados ([]), ya sea para una posición específica o para un rango de posiciones. También es posible especificar los índices que se desea excluir.\n\n# Vector de nombres de países\npaises <- c(\"Argentina\", \"Francia\", \"China\", \"Australia\", \"México\")\npaises\n## [1] \"Argentina\" \"Francia\"   \"China\"     \"Australia\" \"México\"\n\n# Elemento en el índice 3\npaises[3]\n## [1] \"China\"\n\nEl operador : puede utilizarse para especificar un rango de índices:\n\n# Elementos entre los índices 2 y 4 (2, 3 y 4)\npaises[2:4]\n## [1] \"Francia\"   \"China\"     \"Australia\"\n\nCon la función c(), es posible especificar un conjunto de índices particulares:\n\n# Elementos entre los índices 1, 4 y 5\npaises[c(1, 4, 5)]\n## [1] \"Argentina\" \"Australia\" \"México\"\n\nLos números negativos pueden usarse para excluir índices:\n\n# Exclusión de los índices 3 y 4\npaises[c(-3, -4)]\n## [1] \"Argentina\" \"Francia\"   \"México\"\n\nLos valores lógicos TRUE y FALSE también pueden usarse para incluir y excluir índices de un vector:\n\n# Se incluyen los índices 1, 2 y 4; y se excluyen los índices 3 y 5\npaises[c(TRUE, TRUE, FALSE, TRUE, FALSE)]\n## [1] \"Argentina\" \"Francia\"   \"Australia\"\n\n\n\n5.8.1.4.3 Operaciones\nEn los vectores pueden aplicarse operaciones aritméticas:\n\na <- c(1, 3, 5, 7)\nb <- c(2, 4, 6, 8)\n\n# Suma de vectores\na + b\n## [1]  3  7 11 15\n\n# Multiplicación de vectores\na * b\n## [1]  2 12 30 56\n\nY también pueden realizarse operaciones relacionales:\n\n# Comparación con el operador <\na < b\n## [1] TRUE TRUE TRUE TRUE\n\n\n\n\n5.8.1.5 Matrices\nUna matriz es una estructura bidimensional de filas y columnas.\n\n5.8.1.5.1 Definición\nLas matrices se definen mediante la función matrix().\n\n# Definición de una matriz de 3 x 3 con elementos de la secuencia 1:9 distribuidos en las columnas\nm <- matrix(1:9, nrow=3, ncol=3)\nm\n##      [,1] [,2] [,3]\n## [1,]    1    4    7\n## [2,]    2    5    8\n## [3,]    3    6    9\n\n# Definición de una matriz de 3 x 3 con elementos de la secuencia 1:9 distribuidos en las filas\nm <- matrix(1:9, nrow=3, ncol=3, byrow=TRUE)\nm\n##      [,1] [,2] [,3]\n## [1,]    1    2    3\n## [2,]    4    5    6\n## [3,]    7    8    9\n\n# Definición de una matriz de 3 x 2 con nombres para las filas y las columnas\ndatos <- c(18, 500, 25, 1000, 30, 2000)\nfilas <- c(\"Ana\", \"Mario\", \"Laura\")\ncolumnas <- c(\"Edad\", \"Salario\")\n\nm <- matrix(datos, nrow=3, ncol=2, byrow=TRUE, dimnames=list(filas, columnas))\nm\n##       Edad Salario\n## Ana     18     500\n## Mario   25    1000\n## Laura   30    2000\n\nLa función list() se utiliza, en este caso, para combinar vectores. En general, se usa para combinar datos de cualquier tipo.\n\n\n5.8.1.5.2 Indexación\nLa indexación de matrices es similar a la de vectores, pero deben especificarse índices tanto para filas como para columnas.\n\n# Elemento en la posición [2,2] (segunda fila, segunda columna)\nm[2, 2]\n## [1] 1000\n\n# Elementos de la primera fila\nm[1,]\n##    Edad Salario \n##      18     500\n\n# Elementos de la segunda columna\nm[, 2]\n##   Ana Mario Laura \n##   500  1000  2000\n\n# Elementos de las filas 1 y 2\nm[1:2, ]\n##       Edad Salario\n## Ana     18     500\n## Mario   25    1000\n\n# Elementos de la fila \"Mario\"\nm[\"Mario\", ]\n##    Edad Salario \n##      25    1000\n\n# Elementos de la columna \"Salario\"\nm[, \"Salario\"]\n##   Ana Mario Laura \n##   500  1000  2000\n\n\n\n5.8.1.5.3 Operaciones\nDe manera similar a los vectores, en las matrices pueden realizarse operaciones aritméticas y relacionales.\n\na <- matrix(1:4, nrow=2, ncol=2)\na\n##      [,1] [,2]\n## [1,]    1    3\n## [2,]    2    4\n\nb <- matrix(5:8, nrow=2, ncol=2)\nb\n##      [,1] [,2]\n## [1,]    5    7\n## [2,]    6    8\n\n# Suma de matrices\na + b\n##      [,1] [,2]\n## [1,]    6   10\n## [2,]    8   12\n\n# Multiplicación de matrices\na * b\n##      [,1] [,2]\n## [1,]    5   21\n## [2,]   12   32\n\n# Comparación de matrices con el operador >\na > b\n##       [,1]  [,2]\n## [1,] FALSE FALSE\n## [2,] FALSE FALSE\n\n\n\n\n\n5.8.2 Tipos compuestos\n\n5.8.2.1 Factores\nLos factores se utilizan para representar datos categóricos. Un factor corresponde a un conjunto de categorías correspondientes a un concepto (ej. [“Sí”, “No”], [“Casado”, “Soltero”], [“Alto”, “Medio”, “Bajo”]).\nInternamente, los factores se representan en R como números enteros con etiquetas asociadas. A pesar de que los factores parecen (y pueden funcionar como) hileras de caracteres, en realidad son números y debe tenerse cuidado de no manejarlos como caracteres.\nLos elementos de un factor se denominan niveles (levels) y, por defecto, se almacenan en orden alfabético.\n\n5.8.2.1.1 Definición\nUn factor se crea con la función factor().\n\n# Factor de valores de sexo\nsexo <- factor(c(\"Masculino\", \"Femenino\", \"Femenino\", \"Masculino\"))\n\n\n\n5.8.2.1.2 Operaciones\nR proporciona una gran variedad de funciones para manejar factores. Seguidamente, se ejemplifican algunas de estas.\n\n# Etiquetas de los niveles\nlevels(sexo)\n## [1] \"Femenino\"  \"Masculino\"\n\n# Cantidad de niveles\nnlevels(sexo)\n## [1] 2\n\n# Conteo de elementos de cada uno de los niveles del factor\ntable(sexo)\n## sexo\n##  Femenino Masculino \n##         2         2\n\n\n\n\n5.8.2.2 Data Frames\nUn data frame es una estructura bidimensional similar a lo que comúnmente se conoce como una tabla. Sus filas corresponden a las observaciones de un conjunto de datos y sus columnas a las variables. Internamente, se componen de varios vectores, factores y/o matrices de la misma longitud. La definición de un data frame puede incluir nombres para cada observación y para cada variable. Los data frames implementan un conjunto de funciones similares a las de una hoja electrónica o una tabla de una base de datos relacional. Son fundamentales para el manejo de datos en R.\n\n5.8.2.2.1 Definición\nLa función data.frame() crea un data frame a partir de vectores que serán las columnas del data frame.\n\n# Vector de nombres de países\npaises <-\n  c(\"Panamá\",\n    \"Costa Rica\",\n    \"Nicaragua\",\n    \"El Salvador\",\n    \"Honduras\",\n    \"Guatemala\",\n    \"Belice\")\n\n# Vector de cantidades de habitantes de cada país (en millones)\npoblaciones <- c(4.1, 5.0, 6.2, 6.4, 9.2, 16.9, 0.3)\n\n# Creación de un data frame a partir de los dos vectores\npoblaciones_paises <- \n  data.frame(\n    pais = paises, \n    poblacion = poblaciones\n  )\n\n# Impresión del data frame\npoblaciones_paises\n##          pais poblacion\n## 1      Panamá       4.1\n## 2  Costa Rica       5.0\n## 3   Nicaragua       6.2\n## 4 El Salvador       6.4\n## 5    Honduras       9.2\n## 6   Guatemala      16.9\n## 7      Belice       0.3\n\n\n\n5.8.2.2.2 Indexación\nLos datos de un data frame pueden accederse principalmente de dos formas. La primera es mediante la misma sintaxis [fila, columna] que se utiliza en las matrices.\n\n# Fila 1\npoblaciones_paises[1, ]\n##     pais poblacion\n## 1 Panamá       4.1\n\n# Filas 1, 5 y 7\npoblaciones_paises[c(1, 5, 7), ]\n##       pais poblacion\n## 1   Panamá       4.1\n## 5 Honduras       9.2\n## 7   Belice       0.3\n\n# Columna 2\npoblaciones_paises[, 2]\n## [1]  4.1  5.0  6.2  6.4  9.2 16.9  0.3\n\n# Fila 1, columna 2\npoblaciones_paises[1, 2]\n## [1] 4.1\n\n# Filas 1:4, columna 2\npoblaciones_paises[1:4, 2]\n## [1] 4.1 5.0 6.2 6.4\n\nAdemás, mediante el operador $, es posible acceder a las columnas (i.e. variables) del data frame.\n\n# Columna de nombres de países\npoblaciones_paises$pais\n## [1] \"Panamá\"      \"Costa Rica\"  \"Nicaragua\"   \"El Salvador\" \"Honduras\"   \n## [6] \"Guatemala\"   \"Belice\"\n\n# Modificación de los valores de toda una columna\npoblaciones_paises$poblacion = poblaciones_paises$poblacion*2\npoblaciones_paises\n##          pais poblacion\n## 1      Panamá       8.2\n## 2  Costa Rica      10.0\n## 3   Nicaragua      12.4\n## 4 El Salvador      12.8\n## 5    Honduras      18.4\n## 6   Guatemala      33.8\n## 7      Belice       0.6\n\n\n\n5.8.2.2.3 Operaciones\nR proporciona una gran variedad de funciones para manejar data frames. Las siguientes son algunas de las más utilizadas.\nLa función read.table() lee los datos contenidos en un archivo de texto y los retorna en un data frame. read.csv() es una función derivada, con valores por defecto orientados a los archivos de valores separados por comas (CSV, Comma Separated Values). Como argumento principal, read.csv() recibe la ruta del archivo CSV, el cual puede encontrarse en un disco local, en la Web o en otra ubicación.\n\n# Lectura de archivo CSV ubicado en la Web\ncovid <-\n  read.csv(\n    \"https://raw.githubusercontent.com/pf0953-programacionr/2022-ii/main/datos/cepredenac/covid/covid-20210422.csv\"\n  )\n\n# Despliegue de los datos del data frame\ncovid\n##          pais fallecidos recuperados activos positivos\n## 1      Panamá       6198      351949    3845    361992\n## 2  Costa Rica       3125      199779   32370    235274\n## 3   Guatemala       7345      194075   16725    218145\n## 4    Honduras       4981       77020  121358    203359\n## 5 El Salvador       2089       64208    1864     68161\n## 6      Belice        318       12164     114     12596\n## 7   Nicaragua        181        5212      57      5450\n\nLa función str() despliega la estructura de un data frame u otro objeto R.\n\n# Estructura del data frame\nstr(poblaciones_paises)\n\n'data.frame':   7 obs. of  2 variables:\n $ pais     : chr  \"Panamá\" \"Costa Rica\" \"Nicaragua\" \"El Salvador\" ...\n $ poblacion: num  8.2 10 12.4 12.8 18.4 33.8 0.6\n\n\nLa función summary() proporciona un resumen de los contenidos de un data frame:\n\n# Resumen de los contenidos del data frame\nsummary(poblaciones_paises)\n\n     pais             poblacion    \n Length:7           Min.   : 0.60  \n Class :character   1st Qu.: 9.10  \n Mode  :character   Median :12.40  \n                    Mean   :13.74  \n                    3rd Qu.:15.60  \n                    Max.   :33.80  \n\n\nLa función View() invoca un visor de datos que permite visualizar un objeto R en un formato de tabla en una hoja de cálculo. Ejecute en su computadora la siguiente línea de código para apreciar el funcionamiento de View().\n\n# Vista de los casos de COVID-19\nView(covid, \"Casos de COVID-19 en Centramérica\")\n\n\n5.8.2.2.3.1 Ejercicios\n\nDescargue el archivo de datos de covid de Centroamérica (https://raw.githubusercontent.com/pf0953-programacionr/2022-ii/main/datos/cepredenac/covid/covid-20210422.csv) en su computadora y cárguelo en otro data frame mediante read.csv(), accediendo a la dirección en su disco (ej. C:/Usuarios/…).\n\n\n\n\n\n\n5.8.3 Otros\n\n5.8.3.1 Fechas\nLas fechas se manejan en R mediante un tipo especial que permite realizar operaciones como diferencias, agrupamientos y otras. Internamente, una fecha en R se almacena como un número que representa la cantidad de días transcurridos desde el 1 de enero de 1970 (1970-01-01).\n\n5.8.3.1.1 Operaciones\nLa función Sys.Date() retorna la fecha actual.\n\n# Fecha actual\nfecha_actual <- Sys.Date()\nfecha_actual\n## [1] \"2022-09-10\"\n\n# Tipo de datos\ntypeof(fecha_actual)\n## [1] \"double\"\n\n# Clase\nclass(fecha_actual)\n## [1] \"Date\"\n\nLa función as.Date() convierte datos entre los tipos fecha y carácter, de acuerdo con un formato. El formato que se usa por defecto (y el recomendado) es el que corresponde a la norma ISO 8601 (ej. 2023-12-03).\n\n# Conversión de fecha en formato año-mes-día\nfecha_caracter_01 <- \"2020-01-01\"\nfecha_01 <- as.Date(fecha_caracter_01, format=\"%Y-%m-%d\")\nfecha_01\n\n[1] \"2020-01-01\"\n\n# Conversión de fecha en formato día/mes/año\nfecha_caracter_02 <- \"31/01/2020\"\nfecha_02 <- as.Date(fecha_caracter_02, format=\"%d/%m/%Y\")\nfecha_02\n\n[1] \"2020-01-31\"\n\n# Diferencia entre fechas\nfecha_02 - fecha_01\n\nTime difference of 30 days\n\n\nHay una lista de formatos de fechas en Date Formats in R - R-bloggers."
  },
  {
    "objectID": "examen_corto-01.html",
    "href": "examen_corto-01.html",
    "title": "Examen corto 01",
    "section": "",
    "text": "Lunes 5 de setiembre de 2022"
  },
  {
    "objectID": "examen_corto-01.html#temas-a-evaluar",
    "href": "examen_corto-01.html#temas-a-evaluar",
    "title": "Examen corto 01",
    "section": "Temas a evaluar",
    "text": "Temas a evaluar\n\nIntroducción a la ciencia de datos geoespaciales\nMarkdown - lenguaje de marcado\nGit - sistema de control de versiones"
  },
  {
    "objectID": "tarea-01.html",
    "href": "tarea-01.html",
    "title": "Tarea 01",
    "section": "",
    "text": "Lunes 12 de setiembre de 2022, 02:59 p.m."
  },
  {
    "objectID": "tarea-01.html#entregables",
    "href": "tarea-01.html#entregables",
    "title": "Tarea 01",
    "section": "Entregables",
    "text": "Entregables\n\nDirección de un repositorio en GitHub llamado notas-investigacion-reproducible (ej. https://github.com/mfvargas/notas-investigacion-reproducible) que contenga un documento escrito en Markdown llamado README.md, con el contenido especificado en la sección Desarrollo.\nDirección de un sitio web publicado en GitHub Pages generado a partir del repositorio especificado en el punto anterior (ej. https://mfvargas.github.io/notas-investigacion-reproducible/).\n\nLa entrega debe realizarse a través de la plataforma Mediación Virtual."
  },
  {
    "objectID": "tarea-01.html#objetivos",
    "href": "tarea-01.html#objetivos",
    "title": "Tarea 01",
    "section": "Objetivos",
    "text": "Objetivos\nCada estudiante debe mostrar que es capaz de:\n\nEscribir documentos en el lenguaje de marcado Markdown.\nManejar repositorios en GitHub.\nPublicar repositorios en GitHub como sitios web en GitHub Pages."
  },
  {
    "objectID": "tarea-01.html#consideraciones-adicionales",
    "href": "tarea-01.html#consideraciones-adicionales",
    "title": "Tarea 01",
    "section": "Consideraciones adicionales",
    "text": "Consideraciones adicionales\nEsta tarea es estrictamente individual."
  },
  {
    "objectID": "tarea-01.html#desarrollo",
    "href": "tarea-01.html#desarrollo",
    "title": "Tarea 01",
    "section": "Desarrollo",
    "text": "Desarrollo\nEl sitio web debe tener los contenidos y formatos que se muestran en las siguientes imágenes. Deben reproducirse los encabezados, negritas, itálicas, citas textuales, imágenes e hipervínculos a otros documentos.\n\n\n\n\n\n\n\n\n\n\nLos textos están disponibles en este enlace."
  },
  {
    "objectID": "tarea-01.html#calificación",
    "href": "tarea-01.html#calificación",
    "title": "Tarea 01",
    "section": "Calificación",
    "text": "Calificación\nEntre paréntesis, se muestra el porcentaje correspondiente a cada aspecto que se calificará:\nRevisión de las direcciones entregadas:\n- (5%) Dirección del repositorio en GitHub.\n- (5%) Dirección del sitio web publicado en GitHub Pages.\nRevisión de los elementos del documento escrito en Markdown:\n- (10%) Encabezados.\n- (20%) Negritas e itálicas.\n- (20%) Citas textuales.\n- (20%) Imagen de la figura 1 (el archivo está en ZiemannEtAlFig1.png.\n- (20%) Hipervínculos (además de los dos de la bibliografía, incluya uno al sitio web de la FDA en https://www.fda.gov/, en donde se mencionan las siglas)."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Referencias bibliográficas",
    "section": "",
    "text": "Gandrud, Christopher. 2020. Reproducible Research with\nR and RStudio. Third edition. The\nR Series. Boca Raton, FL: CRC Press.\n\n\nLongley, Paul A., Michael F. Goodchild, David J. Maguire, and David W.\nRhind. 2005. Geographic Information\nSystems and Science. 2nd edition.\nChichester ; Hoboken, NJ: Wiley.\n\n\nOlaya, Víctor. 2020. “Sistemas de Información\nGeográfica.” https://volaya.github.io/libro-sig/.\n\n\nPeng, Roger D. 2011. “Reproducible Research in\nComputational Science.”\nScience 334 (6060): 1226–27. https://doi.org/10.1126/science.1213847.\n\n\nSingleton, Alex David, Seth Spielman, and Chris Brunsdon. 2016.\n“Establishing a Framework for Open\nGeographic Information Science.”\nInternational Journal of Geographical Information Science 30\n(8): 1507–21. https://doi.org/10.1080/13658816.2015.1137579."
  }
]