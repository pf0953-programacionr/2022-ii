[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "PF 0953 Programación en R 2022-II",
    "section": "",
    "text": "Este curso trata sobre el manejo, visualización y análisis de datos geoespaciales mediante el lenguaje de programación R. Se imparte en la Maestría Académica en Gestión Integrada del Recurso Hídrico para Latinoamérica y El Caribe de la Universidad de Costa Rica.\nSe estudian los fundamentos de R, sus bibliotecas geoespaciales y sus capacidades para generar gráficos estadísticos. También se utilizan herramientas para facilitar la reproducibilidad de los procedimientos y su comunicación a través de la Internet y otros medios.\nEl enfoque del curso es teórico-práctico, con lecciones teóricas combinadas con ejercicios de programación en los cuales los estudiantes aplican en diversos escenarios de procesamiento de datos los conocimientos y habilidades aprendidas.\nEste sitio web corresponde al curso impartido durante el segundo lectivo de 2022. Para más información sobre los contenidos, metodología, evaluación y otros temas, puede consultar el programa del curso.\nInformación de contacto\nSi tiene alguna pregunta o comentario sobre este curso, por favor contacte a:\n\nManuel Vargas - manuel.vargas_d@ucr.ac.cr\nProfesor\nUniversidad de Costa Rica,\nCiudad Universitaria Rodrigo Facio,\nSan Pedro de Montes de Oca,\nCosta Rica.\n\nLos contenidos de este curso, a menos que se especifique de otra forma, se comparten mediante una licencia de Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional."
  },
  {
    "objectID": "01-introduccion-ciencia-datos-geoespaciales.html",
    "href": "01-introduccion-ciencia-datos-geoespaciales.html",
    "title": "1  Introducción a la ciencia de datos geoespaciales",
    "section": "",
    "text": "Bartomeus Lab. (2016). A reproducible workflow. https://www.youtube.com/watch?v=s3JldKoA0zw\nFOSS4G. (2021). FOSS4G2021—Open source for open spatial data science—Anita Graser. https://www.youtube.com/watch?v=ZjXb53pOor0\nKrugman, P. (2013). Opinion | The Excel Depression. The New York Times. https://www.nytimes.com/2013/04/19/opinion/krugman-the-excel-depression.html\nPeng, R. D. (2011). Reproducible Research in Computational Science. Science, 334(6060), 1226-1227. https://doi.org/10.1126/science.1213847\nSingleton, A. D., Spielman, S., & Brunsdon, C. (2016). Establishing a framework for Open Geographic Information science. International Journal of Geographical Information Science, 30(8), 1507-1521. https://doi.org/10.1080/13658816.2015.1137579\nWu, Q. (2021, octubre 25). A streamlit app for creating timelapse of annual Landsat imagery (1984–2021). Medium. https://giswqs.medium.com/a-streamlit-app-for-creating-timelapse-of-annual-landsat-imagery-1984-2021-3db407a8ac32"
  },
  {
    "objectID": "01-introduccion-ciencia-datos-geoespaciales.html#el-componente-geoespacial-de-los-datos",
    "href": "01-introduccion-ciencia-datos-geoespaciales.html#el-componente-geoespacial-de-los-datos",
    "title": "1  Introducción a la ciencia de datos geoespaciales",
    "section": "1.2 El componente geoespacial de los datos",
    "text": "1.2 El componente geoespacial de los datos\nUna gran parte de los datos disponibles contiene algún tipo de componente geográfico o espacial 1. Este componente puede expresarse de varias formas. Por ejemplo:\n\nCon nombres de lugares: El sapo dorado (Incilius periglenes) era una especie de anfibio, endémica de los bosques nubosos de altitud de Monteverde, Costa Rica.\nCon direcciones: La sede de la Organización de las Naciones Unidas (ONU) está ubicada en la ciudad de Nueva York, Estados Unidos, en la Primera Avenida, 750.\nCon coordenadas: *La cima del Monte Everest se localiza en las coordenadas geográficas 86°55′31″ E y 27°59′17″ N, como se muestra en la Figure 1.1.\n\n\n\n\n\n\nFigure 1.1: Mapa de Nepal que muestra la ubicación del Monte Everest en el sistema de coordenadas geográficas. Imagen de https://www.mapsofworld.com/.\n\n\n\n\nLas coordenadas correspondientes a lugares y direcciones pueden obtenerse a través de un proceso denominado georreferenciación, mediante el cual, en general, se determina la posición espacial de alguna entidad en un sistema de coordenadas. La georreferenciación puede emplearse también para obtener las coordenadas de, por ejemplo, fotografías aéreas o mapas antiguos. Es un proceso que puede resultar complejo y costoso y para el que se han desarrollado metodologías y plataformas especializadas (ej. Chapman AD & Wieczorek JR (2020) Georeferencing Best Practices, GEOLocate, Nominatim).\nEn la actualidad, hay una gran cantidad de fuentes que generan datos georreferenciados (i.e. ubicados en un sistema de coordenadas). Entre estas pueden mencionarse las tecnologías de observación de la Tierra (Earth Observation) (ej. imágenes satelitales), los dispositivos móviles y los sensores remotos, entre muchas otras.\nSeguidamente, se describen dos enfoques tecnológicos para el procesamiento de datos geoespaciales: el de los sistemas de información geográfica y el de ciencia de datos geoespaciales."
  },
  {
    "objectID": "01-introduccion-ciencia-datos-geoespaciales.html#sistemas-de-información-geográfica",
    "href": "01-introduccion-ciencia-datos-geoespaciales.html#sistemas-de-información-geográfica",
    "title": "1  Introducción a la ciencia de datos geoespaciales",
    "section": "1.3 Sistemas de información geográfica",
    "text": "1.3 Sistemas de información geográfica\nA principios de la década de 1960, el geógrafo inglés Roger Tomlinson desarrolló en Canadá el que se considera el primer sistema de información geográfica. Se trataba del Canada Geographic Information System (CGIS) y su objetivo fue manejar los datos del inventario geográfico canadiense y su análisis para la gestión del territorio rural. De manera casi simultánea al trabajo de Tomlinson, surgieron desarrollos similares en Estados Unidos y en el Reino Unido. El surgimiento de los sistemas de información geográfica no implicó solo el surgimiento de nuevas herramientas de software, sino también el desarrollo de técnicas que hasta entonces no habían sido necesarias (Olaya 2020) como, por ejemplo, la manipulación de nuevos tipos de datos geométricos (ej. puntos, líneas, polígonos).\nEn general, un sistema de información geográfica (SIG) maneja datos georreferenciados y los asocia con datos convencionales (ej. textos, números), como se muestra en la Figure 1.2.\n\n\n\n\n\nFigure 1.2: Mapa elaborado en QGIS que muestra la ubicación de los aeródromos de Costa Rica.\n\n\n\n\nLos SIG presentan los datos en capas (layers). Por ejemplo, el mapa de la Figure 1.2 contiene una capa base raster (la que muestra el mar y el continente), una capa de polígonos correspondiente a las provincias de Costa Rica y una capa de puntos correspondiente a los aeródromos. A la izquierda puede apreciarse la lista de esas capas y a la derecha un cuadro con información detallada sobre uno de los aeródromos.\nLos SIG de escritorio (ej. ArcGIS Desktop, QGIS) son herramientas con interfaces de usuario muy gráficas e intuitivas, que no requieren de conocimientos de programación de computadoras y que permiten generar cartografía de alta calidad. Sin embargo, son poco flexibles y los resultados que producen son difícilmente reproducibles."
  },
  {
    "objectID": "01-introduccion-ciencia-datos-geoespaciales.html#ciencia-de-datos-geoespaciales",
    "href": "01-introduccion-ciencia-datos-geoespaciales.html#ciencia-de-datos-geoespaciales",
    "title": "1  Introducción a la ciencia de datos geoespaciales",
    "section": "1.4 Ciencia de datos geoespaciales",
    "text": "1.4 Ciencia de datos geoespaciales\nDurante la última década, el uso de SIG se ha complementado con el de ciencia de datos, lo que posibilitado enriquecer la visualización y el análisis de datos geoespaciales mediante lenguajes de programación como Python, R o JavaScript, entre otros.\nEl uso de técnicas de ciencia de datos y de otros campos relacionados (ej. aprendizaje automatizado, big data) ha permitido aplicar a los datos geoespaciales técnicas y metodologías como análisis de regresión y clasificación estadística."
  },
  {
    "objectID": "01-introduccion-ciencia-datos-geoespaciales.html#reproducibilidad",
    "href": "01-introduccion-ciencia-datos-geoespaciales.html#reproducibilidad",
    "title": "1  Introducción a la ciencia de datos geoespaciales",
    "section": "1.5 Reproducibilidad",
    "text": "1.5 Reproducibilidad\nUna de las principales características que distingue al enfoque de ciencia de datos del enfoque de SIG es la reproducibilidad. En general, la reproducibilidad es la capacidad de un ensayo o experimento de ser reproducido por otros. Más formalmente, en investigación cuantitativa, un análisis se considera reproducible si “el código fuente y los datos utilizados por un investigador para llegar a un resultado están disponibles y son suficientes para que otro investigador, trabajando de manera independiente, pueda llegar al mismo resultado” (Gandrud 2020).\nLa reproducibilidad, junto con la falsabilidad, es uno de los pilares del método científico. Sin embargo, en años recientes, se ha generado una creciente preocupación debido a que muchos estudios científicos publicados fallan las pruebas de reproducibilidad (véase, por ejemplo, The Excel Depression, de Paul Krugman), dando lugar a una crisis de reproducibilidad o replicabilidad en varias ciencias.\nEl concepto de reproducibilidad es cada vez más importante debido, entre otras razones, al aumento exponencial de datos disponibles y a la aplicación de la programación de computadoras, para procesar estos datos, por parte de especialistas de muchas disciplinas.\nAlex Singleton y otros autores (Singleton, Spielman, and Brunsdon 2016) han identificado los siguientes retos para la reproducibilidad en ciencia de datos geoespaciales:\n\nLos datos deben ser de dominio público y estar disponibles para los investigadores.\nEl software utilizado debe ser de código abierto (open source) y estar disponible para ser revisado.\nSiempre que sea posible, los flujos de trabajo deben ser públicos y con enlaces a los datos, software y métodos de análisis, junto con la documentación necesaria.\nEl proceso de revisión por pares (peer review process) y la publicación académica deben requerir la presentación de un modelo de flujo de trabajo e idealmente la disponibilidad de los materiales necesarios para la replicación.\nEn los casos en los que la reproducibilidad total no sea posible (ej. datos sensibles), los investigadores deben esforzarse por incluir todos los aspectos que puedan de un marco de trabajo abierto.\n\nEn general, el estándar mínimo de reproducibilidad requiere que los datos y el código fuente estén disponibles para otros investigadores (Peng 2011). Sin embargo, dependiendo de las circunstancias y recursos disponibles, existe todo un espectro de posibilidades, que se ilustra en la Figure 1.3.\n\n\n\n\n\nFigure 1.3: Espectro de reproducibilidad. Imagen de Anita Graser, con base en (Peng, 2001).\n\n\n\n\n\n1.5.1 Herramientas para facilitar la reproducibilidad\nEn esta sección se destacan dos tipos de herramientas que en la actualidad se consideran esenciales para apoyar la reproducibilidad de una investigación: los lenguajes de marcado y los sistemas de control de versiones.\nLa documentación es vital durante todo el ciclo de vida de una investigación reproducible. Para documentar, se recomienda utilizar mecanismos estandarizados y abiertos como el lenguaje de marcado de hipertexto (HTML, en inglés, HyperText Markup Language) o Markdown, con los cuales pueden crearse documentos mediante editores de texto simples (i.e. no se requiere de software propietario), y exportables a varios formatos (ej. LaTeX, PDF).\nPara dar mantenimiento, tanto al código fuente como a la documentación, es necesario un sistema de control de versiones como Git, el cual permite llevar el registro de los cambios en archivos y también facilita el trabajo colaborativo al reunir las modificaciones hechas por varias personas. Git es usado en varias plataformas que comparten código fuente (ej. GitHub, GitLab) y que ofrecen servicios relacionados, como hospedaje de sitios web.\n\n\n\n\nGandrud, Christopher. 2020. Reproducible Research with R and RStudio. Third edition. The R Series. Boca Raton, FL: CRC Press.\n\n\nLongley, Paul A., Michael F. Goodchild, David J. Maguire, and David W. Rhind. 2005. Geographic Information Systems and Science. 2nd edition. Chichester ; Hoboken, NJ: Wiley.\n\n\nOlaya, Víctor. 2020. “Sistemas de Información Geográfica.” https://volaya.github.io/libro-sig/.\n\n\nPeng, Roger D. 2011. “Reproducible Research in Computational Science.” Science 334 (6060): 1226–27. https://doi.org/10.1126/science.1213847.\n\n\nSingleton, Alex David, Seth Spielman, and Chris Brunsdon. 2016. “Establishing a Framework for Open Geographic Information Science.” International Journal of Geographical Information Science 30 (8): 1507–21. https://doi.org/10.1080/13658816.2015.1137579."
  },
  {
    "objectID": "02-markdown.html",
    "href": "02-markdown.html",
    "title": "2  Markdown - lenguaje de marcado",
    "section": "",
    "text": "Markdown Tutorial. (s. f.). Recuperado 19 de marzo de 2022, de https://www.markdowntutorial.com/\n\n\n\n\nInstale en su computadora el sistema base del lenguaje R y luego el ambiente integrado de desarrollo RStudio Desktop.\nCree una cuenta gratuita en la plataforma de desarrollo colaborativo GitHub."
  },
  {
    "objectID": "02-markdown.html#resumen",
    "href": "02-markdown.html#resumen",
    "title": "2  Markdown - lenguaje de marcado",
    "section": "2.2 Resumen",
    "text": "2.2 Resumen\nMarkdown es un lenguaje de marcado ligero ampliamente utilizado en comunicación científica, documentación de programas e investigación reproducible."
  },
  {
    "objectID": "02-markdown.html#descripción-general",
    "href": "02-markdown.html#descripción-general",
    "title": "2  Markdown - lenguaje de marcado",
    "section": "2.3 Descripción general",
    "text": "2.3 Descripción general\nMarkdown es un lenguaje de marcado creado en 2004 por John Gruber. Las “marcas” se utilizan para brindar información acerca de la presentación (ej. negritas, itálicas) o la estructura (ej. títulos, encabezados) de un documento. Se caracteriza por ser más sencillo de leer y de usar que otros lenguajes de marcado (ej. Lenguaje de marcado de Hipertexto o HTML), por lo que se considera un lenguaje de marcado ligero. Los documentos escritos en Markdown pueden exportarse a una gran variedad de formatos (ej. HTML, DOC, PDF, LaTex) para ser usados en libros, presentaciones o páginas web, entre otros. Markdown es ampliamente utilizado en comunicación científica, documentación de programas e investigación reproducible."
  },
  {
    "objectID": "02-markdown.html#variaciones",
    "href": "02-markdown.html#variaciones",
    "title": "2  Markdown - lenguaje de marcado",
    "section": "2.4 Variaciones",
    "text": "2.4 Variaciones\nLas variaciones de Markdown, también llamadas flavors, son extensiones o modificaciones de la especificación original. Entre las más populares están:\n\nR Markdown: para el lenguaje R.\nGitHub Flavored Markdown: para la plataforma GitHub.\nPython Markdown: para el lenguaje Python.\nPandoc’s Markdown: para el programa Pandoc de conversión entre formatos.\nKramdown: para el lenguaje Ruby.\n\nPuede verse una lista más extensa en https://github.com/commonmark/commonmark-spec/wiki/markdown-flavors."
  },
  {
    "objectID": "02-markdown.html#sintaxis",
    "href": "02-markdown.html#sintaxis",
    "title": "2  Markdown - lenguaje de marcado",
    "section": "2.5 Sintaxis",
    "text": "2.5 Sintaxis\nLa sintaxis de Markdown permite especificar diferentes componentes de un documento, entre los que están:\n\nEncabezados.\nEstilos (ej. negritas, itálicas).\nCitas textuales.\nEnlaces a otros documentos (ej. páginas web).\nImágenes.\nListas.\n\n\n2.5.1 Encabezados\nPueden definirse seis niveles de encabezados, mediante símbolos de numeral (#) antes del texto. El primer nivel es el de tamaño de texto más grande y el sexto el más pequeño. En la parte izquierda de la Figure 2.1 se muestra la sintaxis Markdown de los encabezados y a la derecha la forma en que se despliegan en un documento.\n\n\n\n\n\nFigure 2.1: Sintaxis de Markdown - encabezados.\n\n\n\n\n\n\n2.5.2 Itálicas\nSe definen con un asterisco (*) antes y después del texto o con un guión bajo (_) antes y después del texto.\n\n\n\n\n\nFigure 2.2: Sintaxis de Markdown - itálicas.\n\n\n\n\n\n\n2.5.3 Negritas\nSe definen con dos asteriscos (**) antes y después del texto o con dos guiones bajos (__) antes y después del texto.\n\n\n\n\n\nFigure 2.3: Sintaxis de Markdown - negritas.\n\n\n\n\n\n\n2.5.4 Citas textuales\nSe definen con un símbolo de “mayor que” (>) antes de cada línea.\n\n\n\n\n\nFigure 2.4: Sintaxis de Markdown - citas textuales.\n\n\n\n\n\n\n2.5.5 Enlaces (hipervínculos)\nSe definen con paréntesis cuadrados ([]) seguidos de paréntesis redondos (()). En los paréntesis cuadrados se coloca (opcionalmente) el texto del enlace y en los redondos la dirección del documento.\n\n\n\n\n\nFigure 2.5: Sintaxis de Markdown - enlaces.\n\n\n\n\n\n\n2.5.6 Imágenes\nSe definen con un signo de admiración de cierre (!), paréntesis cuadrados ([]) y paréntesis redondos (()). En los paréntesis cuadrados se coloca (opcionalmente) un texto alternativo de la imagen y en los redondos la dirección de la imagen, ya sea local o remota.\n\n\n\n\n\nFigure 2.6: Sintaxis de Markdown - imágenes.\n\n\n\n\n\n\n2.5.7 Listas numeradas\nSe definen con números (1. 2. 3. ...) antes de cada elemento.\n\n\n\n\n\nFigure 2.7: Sintaxis de Markdown - listas numeradas.\n\n\n\n\n\n\n2.5.8 Listas no numeradas\nSe definen con guiones (-) o asteriscos (*) antes de cada elemento.\n\n\n\n\n\nFigure 2.8: Sintaxis de Markdown - listas no numeradas.\n\n\n\n\n\n\n2.5.9 Otros elementos de sintaxis\nPara conocer otros elementos de la sintaxis de Markdown, se recomienda revisar en detalle la Guía de referencia de Markdown."
  },
  {
    "objectID": "02-markdown.html#ejercicios",
    "href": "02-markdown.html#ejercicios",
    "title": "2  Markdown - lenguaje de marcado",
    "section": "2.6 Ejercicios",
    "text": "2.6 Ejercicios\n\nCree un documento Markdown llamado README.md, en RStudio, y escriba en este un breve perfil académico (curriculum académico).\n\nIncluya información como: nombre, fotografía, datos de contacto, áreas de interés, carrera, cursos aprobados, publicaciones, etc.\nPuede usar información ficticia (no incluya datos confidenciales o sensibles).\nEspecifique la fuente de las imágenes (y de cualquier otra información para la que sea necesario) y no utilice imágenes para las que no tiene autorización. Considere utilizar sitios con imágenes con licencias abiertas (ej. Wikimedia Commons, Unsplash, FreeImages).\nAsegúrese de utilizar los siguientes elementos de sintaxis Markdown:\n\nVarios niveles de encabezados.\nNegritas e itálicas.\nListas.\nEnlaces a sitios web.\nImágenes (al menos una local y una remota).\n\n\nCree un repositorio en GitHub llamado perfil-academico y suba a este el documento que creó en el paso 1.\nCree un sitio web en GitHub Pages con el repositorio creado en el paso 2."
  },
  {
    "objectID": "02-markdown.html#recursos-de-interés",
    "href": "02-markdown.html#recursos-de-interés",
    "title": "2  Markdown - lenguaje de marcado",
    "section": "2.7 Recursos de interés",
    "text": "2.7 Recursos de interés\nCarrera Arias, F. J. (2020). How to Install R on Windows, Mac OS X, and Ubuntu Tutorial. DataCamp Community. https://www.datacamp.com/community/tutorials/installing-R-windows-mac-ubuntu\nMarkdown Guide. (s. f.). Recuperado 10 de abril de 2022, de https://www.markdownguide.org/"
  },
  {
    "objectID": "03-git.html",
    "href": "03-git.html",
    "title": "3  Git - sistema de control de versiones",
    "section": "",
    "text": "Abba, I. V. (2021). Git and GitHub Tutorial – Version Control for Beginners. FreeCodeCamp.Org. https://www.freecodecamp.org/news/git-and-github-for-beginners/\n\n\n\nInstale en su computadora el sistema de control de versiones Git."
  },
  {
    "objectID": "03-git.html#resumen",
    "href": "03-git.html#resumen",
    "title": "3  Git - sistema de control de versiones",
    "section": "3.2 Resumen",
    "text": "3.2 Resumen\nGit es un sistema para administrar versiones de código fuente o, en general, de cualquier conjunto de archivos."
  },
  {
    "objectID": "03-git.html#descripción-general",
    "href": "03-git.html#descripción-general",
    "title": "3  Git - sistema de control de versiones",
    "section": "3.3 Descripción general",
    "text": "3.3 Descripción general\nGit es un sistema de control de versiones diseñado para “rastrear” cambios en el código fuente durante el proceso de desarrollo de software. Sin embargo, puede ser utilizado para llevar el control de los cambios en cualquier conjunto de archivos (ej. documentación, música).\nUn sistema de control de versiones proporciona, entre otras ventajas:\n\nLa capacidad de recuperar versiones anteriores de los archivos.\nLa capacidad de integrar modificaciones efectuadas por varias personas en el mismo conjunto de archivos.\nLa capacidad de mantener varias “ramas” (branches) de un producto (ej. “estable”, “evaluación”, “inestable”, como en el caso de Debian Linux, GRASS GIS y muchos otros proyectos de software libre).\nFacilidades para mantener redundancia y respaldos de los archivos (ej. Programa de respaldos de GitHub). Esta es una facilidad que implementan algunos servicios en la nube.\n\nGit fue diseñado por Linus Torvalds en 2005 durante del desarrollo del kernel del sistema operativo Linux. Se caracteriza por ser un sistema de control de versiones distribuido, lo que significa que el código fuente puede estar alojado en la estación de trabajo de cualquier miembro del equipo de desarrollo. No se requiere de un repositorio “central”, pero también se puede trabajar de esa forma.\nEl protocolo de Git es utilizado en varios sitios que proveen servicios de alojamiento de software, entre los que están SourceForge, Bitbucket, GitLab y GitHub."
  },
  {
    "objectID": "03-git.html#funcionamiento-de-git",
    "href": "03-git.html#funcionamiento-de-git",
    "title": "3  Git - sistema de control de versiones",
    "section": "3.4 Funcionamiento de Git",
    "text": "3.4 Funcionamiento de Git\nDesde el punto de vista de un usuario de Git (ej. un programador), Git se utiliza para sincronizar la versión local (i.e. en una computadora personal) de un conjunto de archivos, llamado proyecto o repositorio, con la versión que está alojada en un sistema remoto (ej. GitHub). Cada repositorio se almacena en un directorio (carpeta) del sistema operativo. La sincronización se realiza principalmente a través de dos operaciones:\n\npush: para “subir” al repositorio remoto los cambios realizados en el repositorio local. Esta operación se realiza mediante el comando git push. Es probable que el sistema remoto le solicite al usuario algún tipo de autenticación (ej. nombre de usuario y clave).\npull: para “bajar” al repositorio local los cambios realizados en el repositorio remoto. Esta operación se realiza mediante el comando git pull.\n\nLas operaciones push y pull se ilustran en la Figure 3.1.\n\n\n\n\n\nFigure 3.1: Operaciones push y pull. Imagen de Melinda Higgins.\n\n\n\n\nAntes de un push, el usuario debe seleccionar los archivos que desea subir mediante el comando git add, el cual pasa los archivos a un “área de espera” (staging area). Luego debe usarse el comando git commit para “guardar” los cambios pendientes en el área de espera. Cada commit guarda el estado del conjunto de archivos en un momento específico (snapshot).\nLa relación entre estas operaciones de Git, se ilustra en la Figure 3.2.\n\n\n\n\n\nFigure 3.2: Operaciones de Git. Imagen de Steven Klavins.\n\n\n\n\nEn la Figure 3.3, se muestra el funcionamiento de Git mediante una comparación con el procesamiento de una compra en línea.\n\n\n\n\n\nFigure 3.3: Operaciones de Git y compras en línea. Imagen de Melinda Higgins.\n\n\n\n\nOtras operaciones de Git de uso frecuente son:\n\ngit config: para especificar opciones globales de la sesión de Git (ej. nombre del usuario, dirección de correo electrónico).\ngit init: para inicializar un repositorio git.\ngit clone: para clonar (i.e. copiar) un repositorio remoto en la computadora local.\ngit status: para revisar el estado de los archivos y, por ejemplo, saber cuales deben pasarse al área de espera.\ngit log: para revisar el historial de commits.\ngit show: para visualizar los cambios efectuados en los commits.\ngit reset: para regresar al estado correspondiente a un commit anterior."
  },
  {
    "objectID": "03-git.html#ejemplos-de-uso",
    "href": "03-git.html#ejemplos-de-uso",
    "title": "3  Git - sistema de control de versiones",
    "section": "3.5 Ejemplos de uso",
    "text": "3.5 Ejemplos de uso\n\n3.5.1 Clonación de un repositorio remoto y sincronización de los cambios efectuados localmente\nPara seguir este ejemplo:\n\nObtenga un token de GitHub en la siguiente opción de menú de su perfil de usuario: Settings - Developer settings - Personal access tokens. Seleccione las operaciones de tipo “repo”. Copie el token en un lugar seguro, ya que lo necesitará para autenticarse en GitHub.\nRealice un fork a su cuenta en GitHub del repositorio localizado en la dirección https://github.com/pf0953-programacionr/2022-ii-tutorial-git-repo-ejemplo. Obtendrá un repositorio llamado “https://github.com/[nombre-usuario]/2022-ii-tutorial-git-repo-ejemplo”, en donde [nombre-usuario] es su nombre de usuario en GitHub.\nCon la opción File - New Project - Version Control - Git de RStudio, clone a su computadora el repositorio que acaba de bifurcar.\nCon el editor de RStudio, abra el archivo README.md, agregue una línea y guarde el archivo.\nLuego, ejecute los siguientes comandos desde la la ventana Terminal de RStudio. Nota: las líneas que empiezan con # son comentarios.\n\n# a. Parámetros de configuración: nombre y dirección de correo del usuario.\n#    Debe cambiar [email-usuario] y [nombre-usuario] por sus propios datos.\ngit config --global user.email [email-usuario]\ngit config --global user.name [nombre-usuario]\n# Para revisar los parámetros de configuración:\ngit config --global --list\n\n# b. Revisión de los archivos con modificaciones.\ngit status\n\n# c. Adición (add) de los archivos modificados al \"área de espera\".\n#    El punto (.) indica que se agregarán todos los archivos modificados.\ngit add .\n\n# d. Grabado (commit) del conjunto de archivos modificados,\n#    junto con un mensaje explicativo:\ngit commit -m \"Agregar línea 2\"\n\n# e. \"Subida\" (push) de las modificaciones al repositorio remoto.\n#    En este paso, es posible que deba utilizar su nombre de usuario/clave\n#    o su token de GitHub para autenticarse.\ngit push\n\nRevise los cambios aplicados en el repositorio remoto en GitHub.\nAgregue más líneas al archivo del repositorio local y sincronícelo con el remoto, realizando nuevamente los pasos del b al e para cada commit. Recuerde que los comentarios de cada commit deben reflejar los cambios que están siendo aplicados."
  },
  {
    "objectID": "03-git.html#recursos-de-interés",
    "href": "03-git.html#recursos-de-interés",
    "title": "3  Git - sistema de control de versiones",
    "section": "3.6 Recursos de interés",
    "text": "3.6 Recursos de interés\nGit. (s. f.). Recuperado 28 de agosto de 2022, de https://git-scm.com/\nGitHub Archive Program. (s. f.). GitHub Archive Program. Recuperado 10 de abril de 2022, de https://archiveprogram.github.com/\nHiggins, M. (s. f.). Reproducible Templates for Analysis and Dissemination. Coursera. Recuperado 11 de abril de 2022, de https://www.coursera.org/learn/reproducible-templates-analysis\nKlavins, S. (2020). Version Control part 1. Medium. https://stevenklavins94.medium.com/version-control-part-1-c5f1b43127f6"
  },
  {
    "objectID": "04-pensamiento_computacional-arquitectura_computadoras.html",
    "href": "04-pensamiento_computacional-arquitectura_computadoras.html",
    "title": "4  Pensamiento computacional y arquitectura de computadoras",
    "section": "",
    "text": "Wing, J. M. (2006). Computational thinking. Communications of the ACM, 49(3), 33-35. https://doi.org/10.1145/1118178.1118215"
  },
  {
    "objectID": "04-pensamiento_computacional-arquitectura_computadoras.html#resumen",
    "href": "04-pensamiento_computacional-arquitectura_computadoras.html#resumen",
    "title": "4  Pensamiento computacional y arquitectura de computadoras",
    "section": "4.2 Resumen",
    "text": "4.2 Resumen\nEl pensamiento computacional es un enfoque para la resolución de problemas basado en conceptos y métodos de las ciencias de la computación. Los principios fundamentales del pensamiento computacional son:\n\nDescomposición: división de un problema en subproblemas más pequeños.\nReconocimiento de patrones: búsqueda de similitudes en los problemas.\nAbstracción: identificación de la información que se necesita y filtrado de la que no se necesita para resolver un problema.\nAlgoritmos: descripción, paso por paso, de la solución a un problema.\n\nLas computadoras modernas están construídas con base en circuitos integrados (CI), también llamados chips o microchips. Los CI procesan información digital (que usa valores discretos), la cual generalmente es binaria (i.e. de dos valores). Los CI de una computadora procesan dos estados correspondientes a dos niveles de tensión eléctrica: alto y bajo. Estos estados se representan con 0 y 1. Esto facilita la aplicación de la lógica binaria y de la aritmética binaria.\nDurante el período entre las guerras mundiales, Allan Turing desarrolló la máquina de Turing, un dispositivo teórico que manipula símbolos de una cinta de acuerdo con una tabla de reglas. La máquina de Turing simula el funcionamiento de un algoritmo y los conceptos de entrada, procesamiento y salida. En 1945, John von Neumann propuso un concepto conocido como programa almacenado, en el cual los datos y los programas se almacenan en una estructura llamada memoria, separada del hardware que ejecuta las instrucciones. Este modelo permite que las computadoras sean más fáciles de reprogramar y es conocido actualmente como arquitectura de von Neumann.\nEl lenguaje máquina es un conjunto de instrucciones binarias interpretables por un CPU. Las instrucciones representan acciones a ser ejecutadas por la computadora. Cada CPU tiene su propio lenguaje máquina. Un programa consiste de una secuencia de instrucciones en lenguaje máquina.\nDebido a que programar una computadora en lenguaje máquina es excesivamente lento y complicado, en la década de 1950 comenzaron a crearse lenguajes de programación que, en lugar de unos y ceros, consisten de instrucciones formadas por palabras, usualmente en idioma inglés. Existe una gran variedad de lenguajes de programación que han sido creados con diversos fines: científicos, comerciales, educacionales, etc."
  },
  {
    "objectID": "04-pensamiento_computacional-arquitectura_computadoras.html#diapositivas",
    "href": "04-pensamiento_computacional-arquitectura_computadoras.html#diapositivas",
    "title": "4  Pensamiento computacional y arquitectura de computadoras",
    "section": "4.3 Diapositivas",
    "text": "4.3 Diapositivas\nPensamiento computacional y arquitectura de computadoras"
  },
  {
    "objectID": "05-r-conceptos_basicos.html",
    "href": "05-r-conceptos_basicos.html",
    "title": "5  R - conceptos básicos",
    "section": "",
    "text": "Grolemund, G., & Wickham, H. (2014). Hands-On Programming with R: Write Your Own Functions And Simulations (capítulos 1 - 12). O’Reilly Media. https://rstudio-education.github.io/hopr/"
  },
  {
    "objectID": "05-r-conceptos_basicos.html#resumen",
    "href": "05-r-conceptos_basicos.html#resumen",
    "title": "5  R - conceptos básicos",
    "section": "5.2 Resumen",
    "text": "5.2 Resumen\nEn esta lección, se estudiarán los conceptos básicos del lenguaje de programación R, incluyendo:\n\nCaracterísticas generales de R.\nEl ambiente de desarrollo RStudio.\nFunciones y paquetes.\nTipos de datos.\nDefinición de funciones.\nCondicionales.\nCiclos."
  },
  {
    "objectID": "05-r-conceptos_basicos.html#características-generales",
    "href": "05-r-conceptos_basicos.html#características-generales",
    "title": "5  R - conceptos básicos",
    "section": "5.3 Características generales",
    "text": "5.3 Características generales\nR es un lenguaje de programación enfocado en análisis estadístico. Es ampliamente utilizado en diversas áreas de investigación, entre las que pueden mencionarse aprendizaje automático (machine learning), ciencia de datos (data science) y big data, con aplicaciones en campos como biomedicina, bioinformática y finanzas, entre muchos otros. Fue creado por Ross Ihaka y Robert Gentleman en la Universidad de Auckland, Nueva Zelanda, en 1993.\nAlgunas de las principales características de este lenguaje son:\n\nEs interpretado: las instrucciones se traducen una por una a lenguaje máquina, a diferencia de los lenguajes compilados, que traducen de manera conjunta las instrucciones de una unidad completa (ej. un programa o una biblioteca). Los lenguajes interpretados tienden a ser más lentos que los compilados, pero también son más flexibles.\nEs multiplataforma: puede ejecutarse en los sistemas operativos más populares (ej. Microsoft Windows, macOS, Linux).\nTiene un sistema de tipos de datos dinámico: las variables pueden tomar diferentes tipos de datos (ej. textuales, numéricos) durante la ejecución del programa, a diferencia del caso de un sistema de tipos de datos estático, en el que las variables solo pueden tener un tipo de datos.\nSoporta varios paradigmas de programación: los paradigmas son estilos o enfoques teóricos de programación. R soporta los paradigmas de programación funcional, programación orientada a objetos, programación imperativa y programación procedimental.\n\nR es un proyecto de software libre que se comparte mediante una licencia GNU General Public Licence (GNU GPL). Esta característica permite que la funcionalidad original de R pueda ser ampliada mediante bibliotecas o paquetes desarrollados por la comunidad de programadores.\nPara programar en R, puede utilizarse una interfaz de línea de comandos, editores de texto (ej. Visual Studio Code, Vim) y también ambientes de desarrollo integrados (IDE, integrated development environment) como Jupyter o RStudio."
  },
  {
    "objectID": "05-r-conceptos_basicos.html#el-ambiente-de-desarrollo-integrado-rstudio",
    "href": "05-r-conceptos_basicos.html#el-ambiente-de-desarrollo-integrado-rstudio",
    "title": "5  R - conceptos básicos",
    "section": "5.4 El ambiente de desarrollo integrado RStudio",
    "text": "5.4 El ambiente de desarrollo integrado RStudio\nRStudio es el IDE más popular para el lenguaje R. Está disponible en una versión de escritorio (RStudio Desktop) y en una versión para servidor (RStudio Server). Esta última permite la conexión de varios usuarios a través de un navegador web. RStudio se ofrece también como un servicio en la nube, a través de RStudio Cloud.\nLa Figure 5.1 muestra la interfaz de RStudio.\n\n\n\n\n\nFigure 5.1: Interfaz del ambiente de desarrollo integrado RStudio.\n\n\n\n\nAdemás de edición de código fuente en R (y otros lenguajes), RStudio contiene capacidades para depurar código y visualizar datos en formatos tabulares, gráficos y de mapas."
  },
  {
    "objectID": "05-r-conceptos_basicos.html#conjuntos-de-datos-para-pruebas",
    "href": "05-r-conceptos_basicos.html#conjuntos-de-datos-para-pruebas",
    "title": "5  R - conceptos básicos",
    "section": "5.5 Conjuntos de datos para pruebas",
    "text": "5.5 Conjuntos de datos para pruebas\nPara efectos de pruebas y ejemplos, la distribución base de R incorpora varios conjuntos de datos que pueden listarse con la función data(). Para obtener información acerca de un conjunto de datos en particular, puede utilizarse el operador ?.\n\n# Información sobre todos los conjuntos de datos incorporados en la distribución base de R\ndata()\n\n# Información sobre el cojunto de datos \"cars\"\n?cars\n\n# Información sobre el cojunto de datos \"mtcars\"\n?mtcars\n\n# Información sobre el cojunto de datos \"Iris\"\n?iris\n\nAdemás, existen muchos sitios en Internet que brindan acceso a conjuntos de datos que pueden utilizarse para pruebas. Por ejemplo:\n\nKaggle - conjuntos de datos\nBanco Mundial - indicadores\nPapers with Code - conjuntos de datos"
  },
  {
    "objectID": "05-r-conceptos_basicos.html#funciones",
    "href": "05-r-conceptos_basicos.html#funciones",
    "title": "5  R - conceptos básicos",
    "section": "5.6 Funciones",
    "text": "5.6 Funciones\nR, al igual que otros lenguajes de programación, estructura su funcionalidad en unidades de código fuente llamadas funciones. Cada función realiza una tarea específica como, por ejemplo, un cálculo matemático y, por lo general, retorna un valor como salida. Todas las funciones tienen un nombre y, opcionalmente, un conjunto de argumentos que especifican los datos de entrada que procesa la función. Los argumentos se escriben entre paréntesis redondos (()) y estos siempre deben incluirse, aún en el caso de que la función no tenga ningún argumento. Si la función tiene varios argumentos, deben separarse mediante comas (,).\n\n5.6.1 Ejemplos\nLa función print() recibe como argumento un valor (ej. un texto o un número) para imprimirlo en la pantalla. En el siguiente fragmento de código en R, se utiliza print() para imprimir la hilera “Hola mundo”. Nótese el uso del símbolo # para comentarios (i.e. texto que no es código ejecutable).\n\n# Impresión de una hilera de caracteres\nprint(\"Hola mundo\")\n\n[1] \"Hola mundo\"\n\n\nLa función mean() retorna la media aritmética del argumento de entrada. En el siguiente ejemplo, se calcula la media de los números de un vector creado a su vez con la función c().\n\n# Media aritmética\nmean(c(2, 4, 5, 9))\n\n[1] 5\n\n\nLa función getwd() (get working directory) retorna la ruta del directorio de trabajo de la sesión actual de R. Este es el directorio en el cual R espera encontrar, por ejemplo, archivos de datos.\n\n# Impresión del directorio de trabajo\ngetwd()\n\n[1] \"/home/mfvargas/pf0953-programacionr/2022-ii/github/2022-ii\"\n\n\nLa función setwd() (set working directory) establece la ruta del directorio de trabajo de la sesión actual de R. Como argumento, recibe una hilera de texto con la ruta.\nNote las barras utilizadas para separar los subdirectorios: / (no \\)\n\n# Especificación del directorio de trabajo (la ruta debe existir)\nsetwd(\"C:/Users/mfvargas\")\n\n\n\n5.6.2 Ejercicios\n\nObtenga la ruta de su directorio de trabajo con la función getwd().\n\nSi lo desea, cambie la ruta de su directorio de trabajo con la función setwd(). Verifique el cambio usando nuevamente getwd().\n\n\n\n5.6.3 Argumentos\nLos argumentos de las funciones tienen nombres que pueden especificarse, en caso de ser necesario. En algunos casos, el orden y el tipo de datos de los argumentos permiten que el interpretador de R conozca cuál es cada uno, sin necesidad de escribir sus nombres.\nEn el siguiente ejemplo, se utilizan los argumentos x, xlab y ylab de la función plot(), para especificar la fuente de datos y las etiquetas de los ejes x e y de un gráfico de dispersión.\n\n# Gráfico de dispersón del conjunto de datos \"cars\" con etiquetas en los ejes x e y\nplot(\n  x=cars, \n  xlab=\"Velocidad (mph)\", \n  ylab=\"Distancia requerida para frenar (pies)\"\n)\n\n\n\n\n\n\n5.6.4 Ejercicios\n\nEstudie la documentación de la función plot() y agregue al gráfico anterior:\n\nUn título.\nUn subtítulo.\n\n\n\n\n5.6.5 Ayuda\nPara obtener ayuda sobre una función desde la línea de comandos de R, puede utilizarse un signo de pregunta (?) seguido del nombre de la función o bien la función help(). Por ejemplo:\n\n# Ayuda de la función setwd()\n?setwd\nhelp(setwd)\n\nTambién puede utilizarse la función apropos(), para buscar funciones por palabras clave.\n\n# Búsqueda, por palabras clave, de funciones relacionadas con \"mean\" (media aritmética). Note las comillas (\"\").\napropos(\"mean\")\n\n [1] \".colMeans\"     \".rowMeans\"     \"colMeans\"      \"kmeans\"       \n [5] \"mean\"          \"mean.Date\"     \"mean.default\"  \"mean.difftime\"\n [9] \"mean.POSIXct\"  \"mean.POSIXlt\"  \"rowMeans\"      \"weighted.mean\"\n\n\nLa función example() presenta ejemplos sobre el uso de una función.\n\n# Ejemplos de uso de la función mean()\nexample(\"mean\")\n\n\nmean> x <- c(0:10, 50)\n\nmean> xm <- mean(x)\n\nmean> c(xm, mean(x, trim = 0.10))\n[1] 8.75 5.50\n\n\nPor otra parte, el sitio All R Documentation reúne documentación de funciones de una gran cantidad de paquetes de R.\nTambién puede obtenerse ayuda en buscadores de Internet, como Google, o en sitios de preguntas y respuestas para programadores, como Stack Overflow."
  },
  {
    "objectID": "05-r-conceptos_basicos.html#paquetes",
    "href": "05-r-conceptos_basicos.html#paquetes",
    "title": "5  R - conceptos básicos",
    "section": "5.7 Paquetes",
    "text": "5.7 Paquetes\nLas funciones de R se distribuyen en paquetes. Cada paquete contiene un conjunto de funciones y estructuras de datos relacionadas entre sí. También hay paquetes que contienen datos.\nPara utilizar un paquete, primero debe cargarse (en la memoria del computador) con la función library().\n\n# Carga del paquete stats\nlibrary(stats)\n\nAlgunos paquetes están contenidos en la distribución base de R. Otros deben instalarse con la función install.packages().\nEn el siguiente ejemplo, se instala el paquete PASWR2, el cual contiene el conjunto de datos TITANIC3 con una lista de pasajeros del Titanic.\n\n# Instalación del paquete PASWR2 (note las comillas)\ninstall.packages(\"PASWR2\")\n\nSeguidamente, el paquete PASWR2 se carga con la función library().\n\n# Carga de PASWR2\nlibrary(PASWR2)\n\nEl conjunto de datos TITANIC3 puede visualizarse con la función View().\n\n# Visualización del conjunto de datos TITANIC3\nView(TITANIC3)\n\nEl siguiente gráfico de barras muestra la distribución de pasajeros por clase, mediante la función barplot(). También se utiliza la función table() para generar una tabla con las cantidades de pasajeros que viajaban en cada clase.\n\n# Cantidades de pasajeros por clase\ntable(TITANIC3$pclass)\n## \n## 1st 2nd 3rd \n## 323 277 709\n\n# Gráfico de barras por clase de pasajero\nbarplot(\n  height=table(TITANIC3$pclass),\n  main=\"Distribución de pasajeros del Titanic por clase\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\"  \n)\n\n\n\n\nLa distribución por cada clase puede dividirse en fallecidos y sobrevivientes.\n\n# Cantidades de pasajeros fallecidos y sobrevivientes por clase\n# (0 corresponde a fallecidos y 1 a sobrevivientes)\ntable(TITANIC3$survived, TITANIC3$pclass)\n##    \n##     1st 2nd 3rd\n##   0 123 158 528\n##   1 200 119 181\n\nEl siguiente gráfico muestra en un gráfico de barras apiladas la distribución de pasajeros sobrevivientes y fallecidos en cada clase.\n\n# Gráfico de barras apiladas\nbarplot(\n  height = table(TITANIC3$survived, TITANIC3$pclass),\n  main = \"Distribución de pasajeros fallecidos y sobrevivientes por clase\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\",\n  col = topo.colors(2)\n)\n\n# Leyenda\nlegend(\n  x = \"topleft\",\n  inset = 0.03,\n  legend = c(\"Fallecidos\", \"Sobrevivientes\"),\n  fill = topo.colors(2),\n  horiz = TRUE\n)\n\n\n\n\nLa misma información se muestra seguidamente en un gráfico de barras agrupadas. Note el uso del argumento beside.\n\n# Gráfico de barras agrupadas\nbarplot(\n  height = table(TITANIC3$survived, TITANIC3$pclass),\n  main = \"Distribución de pasajeros fallecidos y sobrevivientes por clase\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\",  \n  col = topo.colors(2),\n  beside = TRUE\n)\n\n# Leyenda\nlegend(\n  x = \"topleft\",\n  inset = 0.03,\n  legend = c(\"Fallecidos\", \"Sobrevivientes\"),\n  fill = topo.colors(2),\n  horiz = TRUE\n)\n\n\n\n\n\n5.7.1 Ejercicios\n\nMuestre la distribución de pasajeros fallecidos y sobrevivientes por sexo en un gráfico de barras apiladas.\nMuestre la distribución de pasajeros fallecidos y sobrevivientes por sexo en un gráfico de barras agrupadas."
  },
  {
    "objectID": "05-r-conceptos_basicos.html#tipos-de-datos",
    "href": "05-r-conceptos_basicos.html#tipos-de-datos",
    "title": "5  R - conceptos básicos",
    "section": "5.8 Tipos de datos",
    "text": "5.8 Tipos de datos\nR puede trabajar con varios tipos de datos básicos, entre los que están números, caracteres (i.e. textos) y lógicos. También puede trabajar con tipos compuestos, como factores y data frames.\nR proporciona acceso a los datos a través de objetos. Un objeto es una entidad que tiene asociadas propiedades (i.e. datos) y métodos (i.e. funciones) para manipular esas propiedades. Un objeto puede ser, por ejemplo, un número, una hilera de texto, un vector o una matriz. R también permite que el programador defina sus propios objetos.\nHay muchas formas de crear objetos en R. Una de las más sencillas es con los operadores de asignación. Estos son = y <- (o ->). Por ejemplo, las siguientes sentencias crean un número, un texto y un vector.\n\n# Número\nx <- 10\nx\n## [1] 10\n\n# Otro número\n20 -> y\ny\n## [1] 20\n\n# Hilera de caracteres\nnombre <- 'Manuel'\nnombre\n## [1] \"Manuel\"\n\n# Vector de hileras de caracteres\ndias <- c('Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado')\ndias\n## [1] \"Domingo\"   \"Lunes\"     \"Martes\"    \"Miércoles\" \"Jueves\"    \"Viernes\"  \n## [7] \"Sábado\"\n\nTanto x, como nombre como dias son variables. Una variable es una etiqueta que se le asigna a un objeto. Una variable debe comenzar con una letra.\nEl tipo de un objeto puede consultarse con la función typeof(). Por ejemplo:\n\ntypeof(x)\n## [1] \"double\"\ntypeof(y)\n## [1] \"double\"\ntypeof(nombre)\n## [1] \"character\"\ntypeof(dias)\n## [1] \"character\"\n\nA continuación, se describen con más detalle algunos de los tipos de datos utilizados en el lenguaje R.\n\n5.8.1 Tipos básicos\nR define seis tipos de datos básicos. En esta sección, se describen los más utilizados durante este curso.\n\n5.8.1.1 Números\nPueden ser enteros (integer) o decimales (double). Se utilizan en diversos tipos de operaciones, incluyendo las aritméticas (ej. suma, resta, multiplicación, división).\n\n# Declaración de variables numéricas\nx <- 5\ny <- 0.5\n\n# Suma\nx + y\n## [1] 5.5\n\n# Tipos de datos numéricos\ntypeof(x)\n## [1] \"double\"\ntypeof(y)\n## [1] \"double\"\ntypeof(x + y)\n## [1] \"double\"\n\nNótese que al declararse una variable numérica, ya sea que tenga o no punto decimal, R la considera por defecto de tipo double. Para que se considere de tipo integer, debe utilizarse el sufijo L o la función as.integer().\n\n# Números enteros\nx <- 10L\ny <- as.integer(15)\n\n# Multiplicación\nx * y\n## [1] 150\n\n# Tipos de datos enteros\ntypeof(x)\n## [1] \"integer\"\ntypeof(y)\n## [1] \"integer\"\ntypeof(x * y)\n## [1] \"integer\"\n\n\n\n5.8.1.2 Caracteres\nSe utilizan para representar textos. Deben estar entre comillas simples ('') o dobles (\"\").\n\n# Hileras de caracteres\nnombre <- \"María\"\napellido <- \"Pérez\"\n\n# Concatenación mediante la función paste()\npaste(nombre, apellido)\n## [1] \"María Pérez\"\n\n\n\n5.8.1.3 Lógicos\nLos objetos lógicos (también llamados booleanos) tienen dos posibles valores: verdadero (TRUE) o falso (FALSE).\n\n# Variable lógica\na <- 1 < 2\na\n## [1] TRUE\n\n# Variable lógica\nb <- 1 > 2\nb\n## [1] FALSE\n\nLas expresiones lógicas pueden combinarse con operadores como:\n\n& (Y, en inglés AND)\n| (O, en inglés OR)\n! (NO, en inglés NOT)\n\n\n# Operador lógico AND\n(1 < 2) & (3 < 4)\n## [1] TRUE\n\n# Operador lógico OR\n(2 + 2 == 5) | (20 <= 10)\n## [1] FALSE\n\n# Operador lógico NOT\n!(2 + 2 == 5)\n## [1] TRUE\n\n\n\n5.8.1.4 Vectores\nUn vector es una estructura unidimensional que combina objetos del mismo tipo.\n\n5.8.1.4.1 Definición\nLos vectores pueden definirse de varias formas como, por ejemplo, con la función c() (del inglés combine):\n\n# Definición de un vector de números\nvector_numeros <- c(1, 7, 32, 45, 57)\nvector_numeros\n## [1]  1  7 32 45 57\n\n# Definición de un vector de hileras de caracteres\nvector_nombres <- c(\"Álvaro\", \"Ana\", \"Berta\", \"Bernardo\")\nvector_nombres\n## [1] \"Álvaro\"   \"Ana\"      \"Berta\"    \"Bernardo\"\n\nLos vectores también pueden crearse con el operador :, el cual especifica una secuencia (i.e. una lista ordenada):\n\n# Definición de un vector de números con la secuencia de 1 a 10\nvector_secuencia <- 1:10\nvector_secuencia\n##  [1]  1  2  3  4  5  6  7  8  9 10\n\n# Definición de un vector de números con la secuencia de -5 a 5\nvector_secuencia <- -5:5\nvector_secuencia\n##  [1] -5 -4 -3 -2 -1  0  1  2  3  4  5\n\n# Definición de un vector de números con la secuencia de -0.5 a 3.7\nvector_secuencia <- -0.5:3.7\nvector_secuencia\n## [1] -0.5  0.5  1.5  2.5  3.5\n\nLa función seq() también crea un vector con base en una secuencia y permite especificar argumentos como un valor de incremento y la longitud de la secuencia.\n\n# Definición de un vector de números en secuencia de 1 a 10\nvector_secuencia <- seq(1, 10)\nvector_secuencia\n##  [1]  1  2  3  4  5  6  7  8  9 10\n\n# Definición de un vector de números en secuencia de 0.5 a 15.3, con incremento de 2\nvector_secuencia <- seq(from=0.5, to=15.3, by=2)\nvector_secuencia\n## [1]  0.5  2.5  4.5  6.5  8.5 10.5 12.5 14.5\n\n# Definición de un vector de números en secuencia de 1.5 a 9.4, con longitud de 4\nvector_secuencia <- seq(from=1.5, to=9.4, length.out=4)\nvector_secuencia\n## [1] 1.500000 4.133333 6.766667 9.400000\n\n\n\n5.8.1.4.2 Indexación\nLos elementos de un vector se acceden a través de sus índices (i.e. posiciones). La primera posición corresponde al índice 1, la segunda al índice 2 y así sucesivamente. Los índices se especifican entre paréntesis cuadrados ([]), ya sea para una posición específica o para un rango de posiciones. También es posible especificar los índices que se desea excluir.\n\n# Vector de nombres de países\npaises <- c(\"Argentina\", \"Francia\", \"China\", \"Australia\", \"México\")\npaises\n## [1] \"Argentina\" \"Francia\"   \"China\"     \"Australia\" \"México\"\n\n# Elemento en el índice 3\npaises[3]\n## [1] \"China\"\n\nEl operador : puede utilizarse para especificar un rango de índices:\n\n# Elementos entre los índices 2 y 4 (2, 3 y 4)\npaises[2:4]\n## [1] \"Francia\"   \"China\"     \"Australia\"\n\nCon la función c(), es posible especificar un conjunto de índices particulares:\n\n# Elementos entre los índices 1, 4 y 5\npaises[c(1, 4, 5)]\n## [1] \"Argentina\" \"Australia\" \"México\"\n\nLos números negativos pueden usarse para excluir índices:\n\n# Exclusión de los índices 3 y 4\npaises[c(-3, -4)]\n## [1] \"Argentina\" \"Francia\"   \"México\"\n\nLos valores lógicos TRUE y FALSE también pueden usarse para incluir y excluir índices de un vector:\n\n# Se incluyen los índices 1, 2 y 4; y se excluyen los índices 3 y 5\npaises[c(TRUE, TRUE, FALSE, TRUE, FALSE)]\n## [1] \"Argentina\" \"Francia\"   \"Australia\"\n\n\n\n5.8.1.4.3 Operaciones\nEn los vectores pueden aplicarse operaciones aritméticas:\n\na <- c(1, 3, 5, 7)\nb <- c(2, 4, 6, 8)\n\n# Suma de vectores\na + b\n## [1]  3  7 11 15\n\n# Multiplicación de vectores\na * b\n## [1]  2 12 30 56\n\nY también pueden realizarse operaciones relacionales:\n\n# Comparación con el operador <\na < b\n## [1] TRUE TRUE TRUE TRUE\n\n\n\n\n5.8.1.5 Matrices\nUna matriz es una estructura bidimensional de filas y columnas.\n\n5.8.1.5.1 Definición\nLas matrices se definen mediante la función matrix().\n\n# Definición de una matriz de 3 x 3 con elementos de la secuencia 1:9 distribuidos en las columnas\nm <- matrix(1:9, nrow=3, ncol=3)\nm\n##      [,1] [,2] [,3]\n## [1,]    1    4    7\n## [2,]    2    5    8\n## [3,]    3    6    9\n\n# Definición de una matriz de 3 x 3 con elementos de la secuencia 1:9 distribuidos en las filas\nm <- matrix(1:9, nrow=3, ncol=3, byrow=TRUE)\nm\n##      [,1] [,2] [,3]\n## [1,]    1    2    3\n## [2,]    4    5    6\n## [3,]    7    8    9\n\n# Definición de una matriz de 3 x 2 con nombres para las filas y las columnas\ndatos <- c(18, 500, 25, 1000, 30, 2000)\nfilas <- c(\"Ana\", \"Mario\", \"Laura\")\ncolumnas <- c(\"Edad\", \"Salario\")\n\nm <- matrix(datos, nrow=3, ncol=2, byrow=TRUE, dimnames=list(filas, columnas))\nm\n##       Edad Salario\n## Ana     18     500\n## Mario   25    1000\n## Laura   30    2000\n\nLa función list() se utiliza, en este caso, para combinar vectores. En general, se usa para combinar datos de cualquier tipo.\n\n\n5.8.1.5.2 Indexación\nLa indexación de matrices es similar a la de vectores, pero deben especificarse índices tanto para filas como para columnas.\n\n# Elemento en la posición [2,2] (segunda fila, segunda columna)\nm[2, 2]\n## [1] 1000\n\n# Elementos de la primera fila\nm[1,]\n##    Edad Salario \n##      18     500\n\n# Elementos de la segunda columna\nm[, 2]\n##   Ana Mario Laura \n##   500  1000  2000\n\n# Elementos de las filas 1 y 2\nm[1:2, ]\n##       Edad Salario\n## Ana     18     500\n## Mario   25    1000\n\n# Elementos de la fila \"Mario\"\nm[\"Mario\", ]\n##    Edad Salario \n##      25    1000\n\n# Elementos de la columna \"Salario\"\nm[, \"Salario\"]\n##   Ana Mario Laura \n##   500  1000  2000\n\n\n\n5.8.1.5.3 Operaciones\nDe manera similar a los vectores, en las matrices pueden realizarse operaciones aritméticas y relacionales.\n\na <- matrix(1:4, nrow=2, ncol=2)\na\n##      [,1] [,2]\n## [1,]    1    3\n## [2,]    2    4\n\nb <- matrix(5:8, nrow=2, ncol=2)\nb\n##      [,1] [,2]\n## [1,]    5    7\n## [2,]    6    8\n\n# Suma de matrices\na + b\n##      [,1] [,2]\n## [1,]    6   10\n## [2,]    8   12\n\n# Multiplicación de matrices\na * b\n##      [,1] [,2]\n## [1,]    5   21\n## [2,]   12   32\n\n# Comparación de matrices con el operador >\na > b\n##       [,1]  [,2]\n## [1,] FALSE FALSE\n## [2,] FALSE FALSE\n\n\n\n\n\n5.8.2 Tipos compuestos\n\n5.8.2.1 Factores\nLos factores se utilizan para representar datos categóricos. Un factor corresponde a un conjunto de categorías correspondientes a un concepto (ej. [“Sí”, “No”], [“Casado”, “Soltero”], [“Alto”, “Medio”, “Bajo”]).\nInternamente, los factores se representan en R como números enteros con etiquetas asociadas. A pesar de que los factores parecen (y pueden funcionar como) hileras de caracteres, en realidad son números y debe tenerse cuidado de no manejarlos como caracteres.\nLos elementos de un factor se denominan niveles (levels) y, por defecto, se almacenan en orden alfabético.\n\n5.8.2.1.1 Definición\nUn factor se crea con la función factor().\n\n# Factor de valores de sexo\nsexo <- factor(c(\"Masculino\", \"Femenino\", \"Femenino\", \"Masculino\"))\n\n\n\n5.8.2.1.2 Operaciones\nR proporciona una gran variedad de funciones para manejar factores. Seguidamente, se ejemplifican algunas de estas.\n\n# Etiquetas de los niveles\nlevels(sexo)\n## [1] \"Femenino\"  \"Masculino\"\n\n# Cantidad de niveles\nnlevels(sexo)\n## [1] 2\n\n# Conteo de elementos de cada uno de los niveles del factor\ntable(sexo)\n## sexo\n##  Femenino Masculino \n##         2         2\n\n\n\n\n5.8.2.2 Data Frames\nUn data frame es una estructura bidimensional similar a lo que comúnmente se conoce como una tabla. Sus filas corresponden a las observaciones de un conjunto de datos y sus columnas a las variables. Internamente, se componen de varios vectores, factores y/o matrices de la misma longitud. La definición de un data frame puede incluir nombres para cada observación y para cada variable. Los data frames implementan un conjunto de funciones similares a las de una hoja electrónica o una tabla de una base de datos relacional. Son fundamentales para el manejo de datos en R.\n\n5.8.2.2.1 Definición\nLa función data.frame() crea un data frame a partir de vectores que serán las columnas del data frame.\n\n# Vector de nombres de países\npaises <-\n  c(\"Panamá\",\n    \"Costa Rica\",\n    \"Nicaragua\",\n    \"El Salvador\",\n    \"Honduras\",\n    \"Guatemala\",\n    \"Belice\")\n\n# Vector de cantidades de habitantes de cada país (en millones)\npoblaciones <- c(4.1, 5.0, 6.2, 6.4, 9.2, 16.9, 0.3)\n\n# Creación de un data frame a partir de los dos vectores\npoblaciones_paises <- \n  data.frame(\n    pais = paises, \n    poblacion = poblaciones\n  )\n\n# Impresión del data frame\npoblaciones_paises\n##          pais poblacion\n## 1      Panamá       4.1\n## 2  Costa Rica       5.0\n## 3   Nicaragua       6.2\n## 4 El Salvador       6.4\n## 5    Honduras       9.2\n## 6   Guatemala      16.9\n## 7      Belice       0.3\n\n\n\n5.8.2.2.2 Indexación\nLos datos de un data frame pueden accederse principalmente de dos formas. La primera es mediante la misma sintaxis [fila, columna] que se utiliza en las matrices.\n\n# Fila 1\npoblaciones_paises[1, ]\n##     pais poblacion\n## 1 Panamá       4.1\n\n# Filas 1, 5 y 7\npoblaciones_paises[c(1, 5, 7), ]\n##       pais poblacion\n## 1   Panamá       4.1\n## 5 Honduras       9.2\n## 7   Belice       0.3\n\n# Columna 2\npoblaciones_paises[, 2]\n## [1]  4.1  5.0  6.2  6.4  9.2 16.9  0.3\n\n# Fila 1, columna 2\npoblaciones_paises[1, 2]\n## [1] 4.1\n\n# Filas 1:4, columna 2\npoblaciones_paises[1:4, 2]\n## [1] 4.1 5.0 6.2 6.4\n\nAdemás, mediante el operador $, es posible acceder a las columnas (i.e. variables) del data frame.\n\n# Columna de nombres de países\npoblaciones_paises$pais\n## [1] \"Panamá\"      \"Costa Rica\"  \"Nicaragua\"   \"El Salvador\" \"Honduras\"   \n## [6] \"Guatemala\"   \"Belice\"\n\n# Modificación de los valores de toda una columna\npoblaciones_paises$poblacion = poblaciones_paises$poblacion*2\npoblaciones_paises\n##          pais poblacion\n## 1      Panamá       8.2\n## 2  Costa Rica      10.0\n## 3   Nicaragua      12.4\n## 4 El Salvador      12.8\n## 5    Honduras      18.4\n## 6   Guatemala      33.8\n## 7      Belice       0.6\n\n\n\n5.8.2.2.3 Operaciones\nR proporciona una gran variedad de funciones para manejar data frames. Las siguientes son algunas de las más utilizadas.\nLa función read.table() lee los datos contenidos en un archivo de texto y los retorna en un data frame. read.csv() es una función derivada, con valores por defecto orientados a los archivos de valores separados por comas (CSV, Comma Separated Values). Como argumento principal, read.csv() recibe la ruta del archivo CSV, el cual puede encontrarse en un disco local, en la Web o en otra ubicación.\n\n# Lectura de archivo CSV ubicado en la Web\ncovid <-\n  read.csv(\n    \"https://raw.githubusercontent.com/pf0953-programacionr/2022-ii/main/datos/cepredenac/covid/covid-20210422.csv\"\n  )\n\n# Despliegue de los datos del data frame\ncovid\n##          pais fallecidos recuperados activos positivos\n## 1      Panamá       6198      351949    3845    361992\n## 2  Costa Rica       3125      199779   32370    235274\n## 3   Guatemala       7345      194075   16725    218145\n## 4    Honduras       4981       77020  121358    203359\n## 5 El Salvador       2089       64208    1864     68161\n## 6      Belice        318       12164     114     12596\n## 7   Nicaragua        181        5212      57      5450\n\nLa función str() despliega la estructura de un data frame u otro objeto R.\n\n# Estructura del data frame\nstr(poblaciones_paises)\n\n'data.frame':   7 obs. of  2 variables:\n $ pais     : chr  \"Panamá\" \"Costa Rica\" \"Nicaragua\" \"El Salvador\" ...\n $ poblacion: num  8.2 10 12.4 12.8 18.4 33.8 0.6\n\n\nLa función summary() proporciona un resumen de los contenidos de un data frame:\n\n# Resumen de los contenidos del data frame\nsummary(poblaciones_paises)\n\n     pais             poblacion    \n Length:7           Min.   : 0.60  \n Class :character   1st Qu.: 9.10  \n Mode  :character   Median :12.40  \n                    Mean   :13.74  \n                    3rd Qu.:15.60  \n                    Max.   :33.80  \n\n\nLa función View() invoca un visor de datos que permite visualizar un objeto R en un formato de tabla en una hoja de cálculo. Ejecute en su computadora la siguiente línea de código para apreciar el funcionamiento de View().\n\n# Vista de los casos de COVID-19\nView(covid, \"Casos de COVID-19 en Centramérica\")\n\n\n5.8.2.2.3.1 Ejercicios\n\nDescargue el archivo de datos de covid de Centroamérica (https://raw.githubusercontent.com/pf0953-programacionr/2022-ii/main/datos/cepredenac/covid/covid-20210422.csv) en su computadora y cárguelo en otro data frame mediante read.csv(), accediendo a la dirección en su disco (ej. C:/Usuarios/…).\n\n\n\n\n\n\n5.8.3 Otros\n\n5.8.3.1 Fechas\nLas fechas se manejan en R mediante un tipo especial que permite realizar operaciones como diferencias, agrupamientos y otras. Internamente, una fecha en R se almacena como un número que representa la cantidad de días transcurridos desde el 1 de enero de 1970 (1970-01-01).\n\n5.8.3.1.1 Operaciones\nLa función Sys.Date() retorna la fecha actual.\n\n# Fecha actual\nfecha_actual <- Sys.Date()\nfecha_actual\n## [1] \"2022-11-14\"\n\n# Tipo de datos\ntypeof(fecha_actual)\n## [1] \"double\"\n\n# Clase\nclass(fecha_actual)\n## [1] \"Date\"\n\nLa función as.Date() convierte datos entre los tipos fecha y carácter, de acuerdo con un formato. El formato que se usa por defecto (y el recomendado) es el que corresponde a la norma ISO 8601 (ej. 2023-12-03), pero pueden emplearse otros también.\n\n# Conversión de fecha en formato año-mes-día\nfecha_caracter_01 <- \"2020-01-01\"\nfecha_01 <- as.Date(fecha_caracter_01, format=\"%Y-%m-%d\")\nfecha_01\n\n[1] \"2020-01-01\"\n\n# Conversión de fecha en formato día/mes/año\nfecha_caracter_02 <- \"31/01/2020\"\nfecha_02 <- as.Date(fecha_caracter_02, format=\"%d/%m/%Y\")\nfecha_02\n\n[1] \"2020-01-31\"\n\n# Diferencia entre fechas\nfecha_02 - fecha_01\n\nTime difference of 30 days\n\n\nHay una lista de formatos de fechas en Date Formats in R - R-bloggers."
  },
  {
    "objectID": "05-r-conceptos_basicos.html#definición-de-funciones",
    "href": "05-r-conceptos_basicos.html#definición-de-funciones",
    "title": "5  R - conceptos básicos",
    "section": "5.9 Definición de funciones",
    "text": "5.9 Definición de funciones\nAdemás de todas las funciones disponibles en la distribución base de R y en sus diferentes paquetes, R permite que los programadores definan sus propias funciones.\nToda función tiene tres partes esenciales:\n\nUn nombre.\nUn conjunto de argumentos.\nUn conjunto de líneas de código, también llamado el cuerpo de la función.\n\nPara programar una función, debe definirse cada una de esas partes por medio de la palabra reservada function function().\nPor ejemplo, la siguiente función calcula la nota final de un curso con base en los argumentos correspondientes a los promedios de exámenes, proyectos y tareas.\n\n# Función que calcula la nota final de un curso\nnota_final <- function(promedio_examenes,\n                       promedio_proyectos,\n                       promedio_tareas) {\n  factor_examenes <- promedio_examenes * 0.5\n  factor_proyectos <- promedio_proyectos * 0.4\n  factor_tareas <- promedio_tareas * 0.1\n  \n  return(factor_examenes + factor_proyectos + factor_tareas)\n}\n\nLa función return() es la que define el valor de retorno de la función. Si no se incluye, la función retorna la última expresión evaluada.\nAhora que está definida, la función nota_final() puede ser “llamada”, con diferentes argumentos:\n\n# Si ni se incluyen los nombres de los argumentos, \n# la función asume que se ingresan en el mismo orden en el que fueron definidos\nnota_final(100, 50, 0)\n## [1] 70\n\n# El uso de los nombres de argumentos \n# permite modificar su orden\nnota_final(promedio_examenes =  100, promedio_tareas =  0, promedio_proyectos = 50)\n## [1] 70\n\nSi se desea darle al usuario la opción de omitir algunos argumentos, se les puede asignar un valor por defecto.\nSeguidamente, la función nota_final() se redefine asignando valores por defecto a algunos de los argumentos:\n\n# Redefinición de la función nota final,\n# con valores por defecto para los argumentos\nnota_final <- function(promedio_examenes,\n                       promedio_proyectos = 0,\n                       promedio_tareas = 0) {\n  factor_examenes <- promedio_examenes * 0.5\n  factor_proyectos <- promedio_proyectos * 0.4\n  factor_tareas <- promedio_tareas * 0.1\n  \n  # Al no llamarse a la función return(), se retorna la última expresión:\n  factor_examenes + factor_proyectos + factor_tareas\n}\n\n# Se utiliza el valor por defecto (0) para el argumento promedio_tareas\nnota_final(promedio_examenes = 100, promedio_proyectos = 50)\n## [1] 70\n\n# Se llama la función usando la posición del primer argumento y el nombre del segundo\nnota_final(100, promedio_proyectos = 50)\n## [1] 70\n\n\n5.9.1 Ejercicios\n\nDefina una función con nombre celsius_a_fahrenheit() que reciba como argumento una cantidad en grados Celsius y retorne el equivalente en grados Fahrenheit.\n\nDefina una función con nombre fahrenheit_a_celsius() que reciba como argumento una cantidad en grados Fahrenheit y retorne el equivalente en grados Celsius.\n\nDefina una función con nombre imc() para calcular el índice de masa corporal (IMC) de una persona con base en su peso (en kilogramos) y su estatura (en metros)."
  },
  {
    "objectID": "05-r-conceptos_basicos.html#condicionales",
    "href": "05-r-conceptos_basicos.html#condicionales",
    "title": "5  R - conceptos básicos",
    "section": "5.10 Condicionales",
    "text": "5.10 Condicionales\nLas sentencias condicionales evalúan una expresión lógica (i.e. condición) y ejecutan, o no, un bloque de intrucciones dependiendo de si la expresión es verdadera (TRUE) o falsa (FALSE). Permiten que los programas “tomen decisiones” y varíen su curso de acción.\nLos condicionales en R se implementa mediante la sentencia if y sus cláusulas else y else if.\n\n5.10.1 La sentencia if\nLa sentencia if evalúa una condición (i.e. una expresión lógica) y ejecuta un bloque de instrucciones, si es verdadera. El bloque se delimita con los caracteres de “llaves”: {}.\n\n# Sintaxis de la sentencia if\nif (condicion) {\n  # bloque de instrucciones a ejecutar si la condicion es verdadera\n}\n\nPor ejemplo:\n\n# Edad de una persona\nedad <- 25\n\n# Se utiliza la sentencia if para determinar \n# si la persona es adulta\nif (edad >= 18) {\n  print(\"Adulto\")\n}\n## [1] \"Adulto\"\n\nYa sea que se ejecute o no el bloque del if, el programa continúa con las instrucciones que siguen al bloque, si las hay.\n\n\n5.10.2 La cláusula else\nUna sentencia if puede ir seguida de una cláusula else, la cual define un bloque que se ejecuta si la condición es falsa. Por ejemplo:\n\nedad <- 15\n\nif (edad >= 18) {\n  print(\"Adulto\")\n} else {\n  print(\"Menor\")\n}\n\n[1] \"Menor\"\n\n\n\n\n5.10.3 La cláusula else if\nUna sentencia if también puede ir seguida de una o varias cláusulas else if, las cuales evalúan condiciones adicionales.\n\nedad <- 70\n\nif (edad < 18) {\n  print(\"Menor\")\n} else if (edad < 65) {\n  print(\"Adulto\")\n} else {\n  print(\"Adulto mayor\")\n}\n\n[1] \"Adulto mayor\"\n\n\nLas cláusulas else if deben escribirse antes de la cláusula else, la cual es siempre la última, si es que está presente. Tanto las cláusulas else if como la cláusula else son opcionales.\n\n\n5.10.4 Ejercicios\n\nDefina una función con nombre interpretacion_imc() que reciba como argumento un número correspondiente al índice de masa corporal (IMC) de una persona. Debe retornar una hilera de caracteres correspondiente a la interpretación del IMC (“Bajo peso”, “Normal”, “Sobrepeso”, “Obesidad”), de acuerdo con la tabla disponible en Índice de masa corporal - Wikipedia."
  },
  {
    "objectID": "05-r-conceptos_basicos.html#ciclos",
    "href": "05-r-conceptos_basicos.html#ciclos",
    "title": "5  R - conceptos básicos",
    "section": "5.11 Ciclos",
    "text": "5.11 Ciclos\nLos ciclos permiten ejecutar tareas de manera repetitiva en un programa. Algunos ciclos se ejecutan una cantidad definida de veces, mientras que otros lo hacen mientras se cumple una condición lógica. Pueden usarse en combinación con sentencias que terminan anticipadamente el ciclo o que omiten algunas de sus iteraciones.\nLos ciclos en R se implementan mediante las sentencias for, while y repeat, en combinación con las sentencias break y next.\nR provee varias funciones que implementan ciclos de manera implícita, tales como apply(), tapply() y lapply(). Adicionalmente, hay muchas operaciones (ej. las aritméticas) que están “vectorizadas”, por lo que no es necesario utilizarlas en ciclos. El uso de código vectorizado es muy recomendado en R, por ser muy eficiente.\n\n5.11.1 La sentencia for\nLa sentencia for repite las instrucciones contenidas en un bloque para cada uno de los elementos de un vector o lista. En cada iteración (i.e. cada “vuelta” del ciclo), el valor del elemento que está siendo procesado se almacena en una variable.\n\n# Sintaxis de la sentencia for\nfor (variable in vector) {\n  # bloque de instrucciones\n}\n\nPor ejemplo, el siguiente bloque de código utiliza un ciclo de tipo for para recorrer un vector de nombres e imprimir un saludo para cada uno.\n\n# Vector con nombres de personas\nvector_nombres <- c(\"Andrés\", \"Beatriz\", \"Carlos\", \"Marta\", \"Pedro\", \"Sara\")\n\n# Recorrido del vector\nfor (nombre in vector_nombres) {\n  cat(\"Hola\", nombre, \"\\n\")\n}\n## Hola Andrés \n## Hola Beatriz \n## Hola Carlos \n## Hola Marta \n## Hola Pedro \n## Hola Sara\n\nEn el siguiente ejemplo, se utiliza otro ciclo for para recorrer un vector de números y sumar sus elementos.\n\n# Vector de números\nvector_numeros <- c(29.6, -36.81, 31.85, 25.71, 90.2, 0.4)\n\n# Variable para la suma de los números\nsuma <- 0\n\n# Recorrido del vector\nfor (x in vector_numeros) {\n  suma <- suma + x\n}\n\n# Impresión de la suma\ncat(\"Suma:\", suma)\n## Suma: 140.95\n\nSeguidamente, se utiliza dos for “anidados” para sumar los elementos de cada una de las columnas de una matriz.\n\n# Matriz de números\nmatriz_numeros <- matrix(1:12, nrow=3, ncol=4)\nmatriz_numeros\n##      [,1] [,2] [,3] [,4]\n## [1,]    1    4    7   10\n## [2,]    2    5    8   11\n## [3,]    3    6    9   12\n\n# Ciclo externo para recorrer las columnas de la matriz\nfor (j in 1:ncol(matriz_numeros)) {\n  suma_columna <- 0\n  # Ciclo interno para recorrer las elementos de cada columna\n  for (i in 1:nrow(matriz_numeros)) {\n    suma_columna <- suma_columna + matriz_numeros[i, j]\n  }\n  print(suma_columna)\n}\n## [1] 6\n## [1] 15\n## [1] 24\n## [1] 33\n\n\n5.11.1.1 Ejercicios\nUtilice un ciclo for para recorrer el vector vector_numeros y calcular el promedio de sus elementos.\nUtilice dos ciclos for anidados para recorrer la matriz vector_numeros y calcular el promedio de cada una de sus columnas.\n\n\n\n5.11.2 La sentencia while\nLa sentencia while evalúa una condición (i.e. una expresión lógica) en cada iteración de un ciclo y ejecuta las intrucciones del bloque mientras la condición sea verdadera. Generalmente, en algún momento la condición se vuelve falsa y así finaliza el ciclo.\n\n# Sintaxis de la sentencia while\nwhile (condicion) {\n  # bloque de instrucciones \n}\n\nEn el siguiente ejemplo, se utiliza un ciclo while para preguntarle al usuario cuál es la respuesta definitiva al sentido de la vida, el universo y todo lo demás y se continúa haciendo la pregunta hasta que responda correctamente:\n\n# Función para leer una respuesta desde la pantalla\nleer_respuesta <- function() {\n  readline(prompt=\"¿Cual es la respuesta definitiva al sentido de la vida, el universo y todo lo demás? \")\n}\n\n# Si la respuesta es incorrecta, se repite la pregunta hasta que el usuario conteste correctamente\nwhile (leer_respuesta() != \"42\") {   \n  print(\"¡Su respuesta es incorrecta!\")\n}\n\n\n5.11.2.1 Ejercicios\nUtilice un ciclo while para implementar el cálculo del promedio de los elementos de un vector. Sugerencia: utilice la función length() para obtener la longitud del vector y así saber cuando terminar de recorrerlo.\n\n\n\n5.11.3 La sentencia repeat\nLa sentencia repeat implementa un ciclo que se repite indefinidamente. Puede interrumpirse con una sentencia break.\n\n# Sintaxis de la sentencia repeat\nrepeat {\n  # bloque de instrucciones \n}\n\nLos ciclos repeat tienen una estructura más sencilla que los while. Algo que los diferencia es que los bloques de los ciclos repeat se ejecutan al menos una vez.\nEn el siguiente ejemplo, se utiliza un ciclo repeat para implementar la pregunta y lectura de la respuesta que anteriormente se implementó con un ciclo while.\n\n# Función para leer una respuesta desde la pantalla\nleer_respuesta <- function() {\n  readline(prompt=\"¿Cual es la respuesta definitiva al sentido de la vida, el universo y todo lo demás? \")\n}\n\n# Ciclo para imprimir la pregunta y leer la respuesta hasta que esta sea correcta\nrepeat {\n  respuesta <- leer_respuesta()\n  if (respuesta != \"42\") {\n    # Respuesta incorrecta\n    print(\"¡Su respuesta es incorrecta!\")\n  } else {\n    # Respuesta correcta. Se interrumpe el ciclo.\n    break\n  }\n}\n\n\n\n5.11.4 Las sentencias break y next\nLa sentencia break interrumpe un ciclo. La ejecución del programa continúa con la instrucción siguiente al bloque del ciclo.\nEn el siguiente ciclo for, se suman uno a uno los números de un vector, pero se usa un break para interrumpir el ciclo cuando el acumulado es mayor que 100.\n\nvector_numeros <- c(17, 23, 37, 41, 52, 64, 75)\n\nacumulado <- 0\n\nfor (x in vector_numeros) {\n  acumulado <- acumulado + x\n  cat(\"Acumulado:\", acumulado, \"\\n\")\n  if (acumulado >= 100) {\n    cat(\"Se superó el límite de 100 en el acumulado\")\n    break\n  }\n}\n## Acumulado: 17 \n## Acumulado: 40 \n## Acumulado: 77 \n## Acumulado: 118 \n## Se superó el límite de 100 en el acumulado\n\nPor su parte, la sentencia next retorna el control al principio del bloque. Las instrucciones que hay después del next no se ejecutan. La siguiente iteración del ciclo (si la hay), se inicia entonces.\nEl siguiente ciclo recorre un vector de números. Se utiliza la sentencia next para “saltar” los números impares y sumar solo los pares.\n\nvector_numeros <- c(17, 23, 37, 41, 52, 64, 75)\n\nsuma_pares <- 0\n\nfor (x in vector_numeros) {\n  if (x %% 2 == 0) {\n    # Número par: se suma\n    suma_pares <- suma_pares + x\n  } else {\n    # Número impar: se \"salta\" al siguiente número\n    next\n  }\n}\n\ncat(\"Suma de los números pares:\", suma_pares)\n## Suma de los números pares: 116\n\n\n\n5.11.5 La familia de funciones apply()\nEsta es una familia de funciones que manipulan subconjuntos de datos obtenidos a partir de matrices, listas y data frames, los cuales son recorridos de una forma repetitiva. Pueden funcionar como una alternativa a los ciclos y aplicar funciones en los subconjuntos de datos como, por ejemplo, funciones estadísticas en las columnas de una matriz o de un data frame. Su uso es muy recomendado por su eficiencia, flexibilidad y simplicidad.\nEntre estas funciones, pueden mencionarse apply(), lapply(), sapply(), vapply(), mapply(), rapply() y tapply().\n\n5.11.5.1 La función apply()\nLa función apply() toma como entrada un arreglo o una matriz y aplica alguna función sobre sus filas o columnas.\nLa sintaxis de la función es:\n\n# Sintaxis de la función apply()\napply(X, MARGIN, FUN, ...)\n\nEn donde:\n- X: es un arreglo o matriz.\n- MARGIN: MARGIN = 1 significa que la función actúa en las filas, MARGIN = 2 significa que la función actúa en las columnas y MARGIN = c(1, 2) significa que la función actúa en las filas y en las columnas.\n- FUN: es la función que se aplicará a cada uno de los elementos de X.\nEn el siguiente ejemplo, se utiliza la función apply() para sumar los elementos de las columnas de una matriz.\n\nm <- matrix(1:12, nrow=3, ncol=4)\nm\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\n# Suma de las columnas\napply(m, 2, sum)\n\n[1]  6 15 24 33\n\n\n\n5.11.5.1.1 Ejercicios\nUtilice la función apply() para obtener el promedio de los elementos de cada columna de la matriz del ejemplo anterior.\n\n\n\n5.11.5.2 La función lapply()\nLa función lapply() toma como entrada un vector o lista y retorna una lista de la misma longitud en la que cada uno de sus elementos es el resultado de aplicar una función al vector o lista de entrada.\nLa sintaxis de la función es:\n\n# Sintaxis de la función lapply()\nlapply(X, FUN, ...)\n\nEn donde:\n- X: es un vector o lista.\n- FUN: es la función que se aplicará a cada elemento de X. Algunas funciones predefinidas que pueden utilizarse incluyen mean(), median(), sum(), min() y max(). También pueden usarse funciones definidas por el usuario.\nEn los siguientes ejemplos, se utiliza lapply() para aplicar diferentes funciones a un vector de nombres de personas.\n\nnombres <- c(\"Andrés\", \"Beatriz\", \"Carlos\", \"Marta\", \"Pedro\", \"Sara\")\n\n# Los nombres de la lista se transforman a minúscula\nnombres_en_minuscula <- lapply(nombres, tolower)\nnombres_en_minuscula\n\n[[1]]\n[1] \"andrés\"\n\n[[2]]\n[1] \"beatriz\"\n\n[[3]]\n[1] \"carlos\"\n\n[[4]]\n[1] \"marta\"\n\n[[5]]\n[1] \"pedro\"\n\n[[6]]\n[1] \"sara\"\n\n# Se genera un saludo para cada nombre\nnombres_con_saludo <- lapply(nombres, function(arg1, arg2) paste(arg1, arg2), arg1=\"Hola\")\nnombres_con_saludo\n\n[[1]]\n[1] \"Hola Andrés\"\n\n[[2]]\n[1] \"Hola Beatriz\"\n\n[[3]]\n[1] \"Hola Carlos\"\n\n[[4]]\n[1] \"Hola Marta\"\n\n[[5]]\n[1] \"Hola Pedro\"\n\n[[6]]\n[1] \"Hola Sara\"\n\n\n\n\n5.11.5.3 La función tapply()\nLa función tapply() aplica una función a cada nivel de un factor.\nLa sintaxis de la función es:\n\n# Sintaxis de la función tapply()\ntapply(X, INDEX, FUN)\n\nEn donde:\n- X: es un objeto, tipicamente un vector.\n- INDEX: es una lista que contiene un factor.\n- FUN: es la función que se aplicará a cada elemento de X.\nEn el siguiente ejemplo, se utiliza tapply() para calcular la mediana del ancho del sépalo para cada especie del conjunto de datos iris.\n\ndata(iris)\ntapply(iris$Sepal.Width, iris$Species, median)\n\n    setosa versicolor  virginica \n       3.4        2.8        3.0 \n\n\n\n5.11.5.3.1 Ejercicios\nUtilice la función tapply() para obtener el promedio de las longitudes de los pétalos para cada especie del conjunto de datos iris.\n\n\n\n\n5.11.6 Vectorización\nEn R, muchas operaciones y funciones pueden ser vectorizadas, lo que significa que pueden aplicarse a los elementos de un vector sin necesidad de iterar uno por uno en estos.\nPor ejemplo, considérese el siguiente fragmento de código no vectorizado, que utiliza un ciclo para convertir los números de un vector a sus valores absolutos:\n\nvector_numeros <- c(23, -17, 34, 0, -12, 55)\n\nfor (i in 1:length(vector_numeros)) {\n  if (vector_numeros[i] < 0) {\n    vector_numeros[i] <- -vector_numeros[i]\n  }\n}\n\nvector_numeros\n## [1] 23 17 34  0 12 55\n\nEl siguiente fragmento de código realiza la misma tarea, pero de forma vectorizada:\n\nvector_numeros <- c(23, -17, 34, 0, -12, 55)\n\n# Se usa una expresión lógica para seleccionar los elementos del vector < 0\nnegativos <- vector_numeros < 0\nnegativos\n## [1] FALSE  TRUE FALSE FALSE  TRUE FALSE\n\n# Se cambian los elementos seleccionados en el paso anterior sin utilizar el for\nvector_numeros[negativos] <- vector_numeros[negativos] * -1\n\nvector_numeros\n## [1] 23 17 34  0 12 55\n\n\n5.11.6.1 Ejercicios\nUtilice código vectorizado para implementar una función que reciba como argumento un vector de números y retorne el mismo vector con los elementos impares (solo los impares) elevados al cuadrado."
  },
  {
    "objectID": "05-r-conceptos_basicos.html#recursos-de-interés",
    "href": "05-r-conceptos_basicos.html#recursos-de-interés",
    "title": "5  R - conceptos básicos",
    "section": "5.12 Recursos de interés",
    "text": "5.12 Recursos de interés\nFind Open Datasets and Machine Learning Projects | Kaggle. (s. f.). Recuperado 24 de abril de 2022, de https://www.kaggle.com/datasets\nIndicators | Data. (s.f.). Recuperado 11 de septiembre de 2022, de https://data.worldbank.org/indicator\nNewest «r» Questions. (s. f.). Stack Overflow. Recuperado 24 de abril de 2022, de https://stackoverflow.com/questions/tagged/r\nPapers with Code—Machine Learning Datasets. (s.f.). Recuperado 11 de septiembre de 2022, de https://paperswithcode.com/datasets\nR Language Definition. (s. f.). Recuperado 24 de abril de 2022, de https://cran.r-project.org/doc/manuals/r-release/R-lang.html\nR Package Documentation. (s.f.). Recuperado 11 de septiembre de 2022, de https://rdrr.io/"
  },
  {
    "objectID": "06-quarto.html",
    "href": "06-quarto.html",
    "title": "6  Quarto - sistema de publicación técnica y científica",
    "section": "",
    "text": "Quarto - Tutorial: Hello, Quarto. (s.f.). Recuperado 22 de agosto de 2022, de https://quarto.org/docs/get-started/hello/rstudio.html\nXie, Y., Allaire, J. J., & Grolemund, G. (2018). R Markdown: The definitive guide. CRC Press. https://bookdown.org/yihui/rmarkdown/\nXie, Y., Dervieux, C., & Riederer, E. (2020). R Markdown Cookbook. CRC Press. https://bookdown.org/yihui/rmarkdown-cookbook/"
  },
  {
    "objectID": "06-quarto.html#resumen",
    "href": "06-quarto.html#resumen",
    "title": "6  Quarto - sistema de publicación técnica y científica",
    "section": "6.2 Resumen",
    "text": "6.2 Resumen\nQuarto es un sistema de publicación de documentos técnicos y científicos, basado en código abierto. Estos documentos combinan código en R, y sus salidas (ej. tablas, gráficos, mapas), con la sintaxis de Markdown."
  },
  {
    "objectID": "06-quarto.html#características-generales",
    "href": "06-quarto.html#características-generales",
    "title": "6  Quarto - sistema de publicación técnica y científica",
    "section": "6.3 Características generales",
    "text": "6.3 Características generales\nQuarto es un sistema de publicación de documentos técnicos y científicos, basado en código abierto. Entre sus principales capacidades están:\n\nCrear contenido dinámico con los lenguajes R, Python, Julia y Observable.\nCrear documentos Markdown de texto plano o cuadernos de notas de Jupyter.\nPublicar artículos académicos, reportes, presentaciones, sitios web, blogs y libros en HTML, PDF, MS Word, ePub y otros formatos.\nCrear contenido científico, incluyendo ecuaciones, citas bibliográficas, referencias cruzadas, figuras y otros elementos.\n\nQuarto es la siguiente generación de R Markdown, un formato que permite insertar código R, y sus salidas, en documentos escritos en Markdown. R Markdown fue introducido por Yihui Xie en 2012, junto con el paquete knitr, cuyo propósito es facilitar la investigación reproducible en R a través de la programación literaria (literate programming), un paradigma de programación propuesto por Donald Knuth en 1984.\nLos programas “literarios” (o “letrados”) están escritos como una exposición lógica en un lenguaje humano similar a la explicación de las fórmulas y ecuaciones empleadas para representar y resolver un problema en un texto de física o de matemáticas. En estos programas, se describe el análisis del problema, su solución y su implementación, intercalando código fuente entre los párrafos (y otros contenidos como imágenes, tablas, gráficos estadísticos y mapas), de forma similar a como en los textos de matemáticas se intercalan las fórmulas y las ecuaciones. La programación literaria puede mejorar enormemente un programa, ya que permite documentar ampliamente en qué consiste el problema a resolver, cómo se resuelve, cómo y por qué se adoptó cierto diseño, cómo se optimizó y cómo se implementó en un lenguaje de programación."
  },
  {
    "objectID": "06-quarto.html#anatomía-de-un-documento-quarto",
    "href": "06-quarto.html#anatomía-de-un-documento-quarto",
    "title": "6  Quarto - sistema de publicación técnica y científica",
    "section": "6.4 Anatomía de un documento Quarto",
    "text": "6.4 Anatomía de un documento Quarto\nUn documento Quarto tiene tres tipos de contenido:\n\nMetadatos en YAML.\nNarrativa en Markdown.\nBloques de código en R (u otro lenguaje de programación).\n\n\n6.4.1 Metadatos en YAML\nTodo documento Quarto inicia con un encabezado en la sintaxis YAML (YAML Ain’t Markup Language), el cual contiene metadatos del documento como el título, el autor, la fecha de creación, el formato de salida y la estructura de la tabla de contenidos, entre muchos otros.\nUn encabezado YAML comienza y termina con tres guiones (---) y contiene un conjunto de campos y valores de la forma:\n---\ncampo01: valor01\ncampo02: valor02\ncampo0n: valor0n\n---\nPor ejemplo, un encabezado YAML típico puede ser el siguiente:\n---\ntitle: Mi primer documento Quarto\nformat: html\neditor: visual\n---\nLos campos del encabezado pueden anidarse con sangrías de dos espacios como, por ejemplo:\n---\nformat:\n  html:\n    toc: true\n    toc_float: true\n---\nLos elementos de metadatos que pueden especificarse en el encabezado, pueden variar de acuerdo al formato de salida, como puede verse en los siguientes enlaces:\n\nElementos de metadatos para HTML\nElementos de metadatos para PDF\nElementos metadatos para MS Word\n\nExisten elementos de metadatos para muchos otros formatos de salida (OpenOffice, ePub, presentaciones, wikis, etc.), como puede apreciarse en la Referencia de Quarto.\n\n\n6.4.2 Narrativa en Markdown\nLa narrativa proporciona estructura y contenido al documento en la forma de encabezados, párrafos, enlaces y otros elementos de la sintaxis de Markdown.\n\n\n6.4.3 Fragmentos de código en R (u otro lenguaje de programación)\nLos bloques (chunks) de código en R se identifican con {r} y diferentes opciones identificadas con #|. Los bloques de otros lenguajes de programación se identifican con {python} y {julia}, por ejemplo.\nEl siguiente es un ejemplo de bloque de código en R y su salida:\n```{r}\n#| label: graficacion-cars\n#| include: true\n#| echo: false\n\nplot(\n  x = cars$speed,\n  y = cars$dist,\n  main = \"Velocidad vs distancia de frenado\",\n  xlab = \"Velocidad (MPH)\",\n  ylab = \"Distancia (pies)\"\n)\n```\n\n\n\n\n\nLa opción label se utiliza para etiquetar el bloque y la de include para especificar si se desea que el bloque y sus resultados se incluyan en el documento de salida."
  },
  {
    "objectID": "06-quarto.html#cómo-funciona-quarto",
    "href": "06-quarto.html#cómo-funciona-quarto",
    "title": "6  Quarto - sistema de publicación técnica y científica",
    "section": "6.5 ¿Cómo funciona Quarto?",
    "text": "6.5 ¿Cómo funciona Quarto?\nQuarto se apoya en knitr y en Pandoc. knitr ejecuta el código en R (u otro lenguaje) y convierte los documentos a Markdown. Por su parte, Pandoc exporta los documentos Markdown al formato de salida deseado (ej. HTML, PDF, MS Word, MS PowerPoint). Este proceso se ilustra en la Figure 6.1.\n\n\n\n\n\nFigure 6.1: Conversión de un documento Quarto (.qmd) a su formato de salida. Imagen de quarto.org."
  },
  {
    "objectID": "06-quarto.html#ejemplo-de-documento-quarto",
    "href": "06-quarto.html#ejemplo-de-documento-quarto",
    "title": "6  Quarto - sistema de publicación técnica y científica",
    "section": "6.6 Ejemplo de documento Quarto",
    "text": "6.6 Ejemplo de documento Quarto\nVisualización de datos con funciones del paquete base de R.\n\nSitio en GitHub Pages: https://pf0953-programacionr.github.io/2022-ii-graficacion-base/\nCódigo fuente: https://github.com/pf0953-programacionr/2022-ii-graficacion-base"
  },
  {
    "objectID": "07-tidyverse.html",
    "href": "07-tidyverse.html",
    "title": "7  Tidyverse - paquetes para ciencia de datos",
    "section": "",
    "text": "Wickham, H., & Grolemund, G. (2017). R for Data Science: Import, Tidy, Transform, Visualize, and Model Data (1st ed.). O’Reilly Media. https://r4ds.had.co.nz/\nWickham, H., & Grolemund, G. (s. f.). R para Ciencia de Datos (1era ed.). Recuperado 14 de mayo de 2022, de https://es.r4ds.hadley.nz/\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (s. f.). R for Data Science (2nd ed.). Recuperado 16 de octubre de 2022, de https://r4ds.hadley.nz/"
  },
  {
    "objectID": "07-tidyverse.html#resumen",
    "href": "07-tidyverse.html#resumen",
    "title": "7  Tidyverse - paquetes para ciencia de datos",
    "section": "7.2 Resumen",
    "text": "7.2 Resumen\nEn este capítulo se estudia Tidyverse, una colección de paquetes para ciencia de datos. También se introducen los concepto de datos tidy y de pipes."
  },
  {
    "objectID": "07-tidyverse.html#características-generales",
    "href": "07-tidyverse.html#características-generales",
    "title": "7  Tidyverse - paquetes para ciencia de datos",
    "section": "7.3 Características generales",
    "text": "7.3 Características generales\nTidyverse es una colección de paquetes de R enfocados en ciencia de datos. La ciencia de datos es una discipina que permite convertir datos no procesados en entendimiento, comprensión y conocimiento (Wickham and Grolemund 2017).\nLa Figure 7.1 ilustra el modelo de un proyecto típico de ciencia de datos, el cual incluye los procesos de importar, organizar, transformar, visualizar, modelar y comunicar.\n\n\n\n\n\nFigure 7.1: Modelo de ciencia de datos. Imagen de Hadley Wickham.\n\n\n\n\nImportar los datos, típicamente implica leerlos de un archivo, una base de datos o una interfaz de programación de aplicaciones (API) y cargarlos en un data frame. Organizar (to tidy) los datos significa colocarlos en estructuras rectangulares, similares a tablas, de manera que cada fila sea una observación y cada columna una variable.\nUna vez que los datos han sido importados y organizados, suele ser necesario realizar en estos algún tipo de transformación. Transformar los datos puede implicar la generación de algún subconjunto de filas y columnas, la creación de nuevas variables o el cálculo de estadísticas (ej. conteos, promedios). Cuando los datos han sido organizados con las variables necesarias, pueden aplicarse dos fuentes de generación de conocimiento: la visualización y el modelado. Al visualizar los datos (en tablas, gráficos, mapas, etc.), pueden encontrarse patrones inesperados o pueden surgir nuevas preguntas. Por su parte, los modelos son herramientas matemáticas o computacionales que facilitan la descripción o predicción de un problema.\nEl último paso es la comunicación, una actividad crítica de cualquier proyecto de análisis de datos o de ciencia en general.\nTodos estos procesos se articulan mediante programación de computadoras.\nLos paquetes de Tidyverse “comparten filosofía de diseño, gramática y estructuras de datos” (“Tidyverse” n.d.) para apoyar estos procesos del modelo de ciencia de datos. El concepto de Tidyverse fue introducido por Hadley Wickham, quien también ha programado varios de sus paquetes."
  },
  {
    "objectID": "07-tidyverse.html#paquetes",
    "href": "07-tidyverse.html#paquetes",
    "title": "7  Tidyverse - paquetes para ciencia de datos",
    "section": "7.4 Paquetes",
    "text": "7.4 Paquetes\nEl núcleo de Tidyverse está compuesto por ocho paquetes base, los cuales proveen las funcionalidades utilizadas más frecuentemente en análisis de datos:\n\nggplot2: sistema para la creación declarativa de gráficos, basado en el libro The Grammar of Graphics, de Wilkinson et al..\ndplyr: gramática para la manipulación de datos que proporciona un conjunto consistente de “verbos” que resulven los retos más comunes de manipulación de datos.\ntidyr: conjunto de funciones para organizar (to tidy) datos, colocando las observaciones, variables y valores en filas, columnas y celdas de estructuras rectangulares.\nreadr: conjunto de funciones para cargar datos de estructuras rectangulares (ej. archivos CSV) en memoria.\npurr: conjunto de herramientas de programación funcional para trabajar con funciones y vectores.\ntibble: un tibble es una redefinición del concepto de data frame, para hacerlos más eficientes y fáciles de usar.\nstringr: colección de funciones para facilitar el trabajo con hileras de caracteres.\nforcats: colección de funciones para facilitar el trabajo con factores.\n\nHay otros paquetes para tareas más especifícas relacionadas con importación, limpieza y modelado de datos, entre otras. Los paquetes de Tidyverse son de los más descargados, entre la totalidad de paquetes del lenguaje de programación R."
  },
  {
    "objectID": "07-tidyverse.html#instalación-y-carga",
    "href": "07-tidyverse.html#instalación-y-carga",
    "title": "7  Tidyverse - paquetes para ciencia de datos",
    "section": "7.5 Instalación y carga",
    "text": "7.5 Instalación y carga\nLos paquetes de Tidyverse pueden instalarse de manera conjunta o individualmente con la función install.packages():\n\n# Instalación conjunta\ninstall.packages(\"tidyverse\")\n\n# Instalación de paquetes individuales\ninstall.packages(\"ggplot2\")\ninstall.packages(\"dplyr\")\n\nUna vez instalados, los paquetes también pueden cargarse conjunta o separadamente con la función library():\n\n# Carga conjunta\nlibrary(tidyverse)\n\n# Carga de paquetes individuales\nlibrary(ggplot2)\nlibrary(dplyr)\n\nTambién es posible utilizar la notación paquete::funcion() para llamar una función sin necesidad de cargar todo el paquete (siempre y cuando el paquete haya sido instalado):\n\n# Llamado a la función glimpse() del paquete dplyr\ndplyr::glimpse(iris)\n\nRows: 150\nColumns: 5\n$ Sepal.Length <dbl> 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9, 5.4, 4.…\n$ Sepal.Width  <dbl> 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1, 3.7, 3.…\n$ Petal.Length <dbl> 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1.5, 1.…\n$ Petal.Width  <dbl> 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1, 0.2, 0.…\n$ Species      <fct> setosa, setosa, setosa, setosa, setosa, setosa, setosa, s…"
  },
  {
    "objectID": "07-tidyverse.html#el-conjunto-de-datos-palmerpenguins",
    "href": "07-tidyverse.html#el-conjunto-de-datos-palmerpenguins",
    "title": "7  Tidyverse - paquetes para ciencia de datos",
    "section": "7.6 El conjunto de datos palmerpenguins",
    "text": "7.6 El conjunto de datos palmerpenguins\npalmerpenguins es un paquete de datos de R ampliamente utilizado para ejemplificar funciones de exploración y visualización, como las de Tidyverse. Es muy popular en ciencia de datos en general y también está disponible para otros lenguajes de programación (ej. Python, Julia). Se utiliza como una alternativa a otros conjuntos de datos como, por ejemplo, iris.\nLos datos de palmerpenguins fueron recolectados entre 2007 y 2009 por la Dr. Kristen Gorman y el Programa de Investigación Ecológica de Largo Plazo (LTER) de la Estación Palmer. Consisten de 344 observaciones de pingüinos de tres especies, las cuales habitan en tres islas del archipiélago Palmer, en la Antártida. Para cada individuo se registraron variables como especie, sexo, masa (peso), longitud de la aleta (flipper), longitud del pico (bill) y profundidad del pico, entre otras.\nEn R, el paquete puede instalarse con la función install.packages():\n\n# Instalación de palmerpenguins\ninstall.packages(\"palmerpenguins\")\n\nUna vez instalado, el paquete puede cargarse con la función library():\n\n# Carga de palmerpenguins\nlibrary(palmerpenguins)\n\nEl paquete contiene dos conjuntos de datos:\n\npenguins_raw: datos sin procesar.\npenguins: subconjunto curado de los datos sin procesar.\n\npalmerpinguins se utilizará en este capítulo, y en los siguientes, para ejemplificar varias de las funcionalidades de Tidyverse.\n\n7.6.1 Ejemplos de visualizaciones\nSe muestran varios tipos de gráficos estadísticos generados con la función ‘ggplot()’.\n\n7.6.1.1 Gráficos de dispersión\nEste tipo de gráficos muestra relaciones entre variables.\n\n# Gráfico de dispersión de longitud del pico vs masa (peso)\npenguins |>\n  ggplot(aes(x = bill_length_mm, y = body_mass_g)) +\n  geom_point(size = 2) +\n  geom_smooth(method = \"lm\", se = FALSE) +\n  ggtitle(\"Longitud del pico vs. masa\") +\n  xlab(\"Longitud del pico (mm)\") +\n  ylab(\"Masa (g)\") +\n  labs(color = \"Especie\", shape = \"Especie\")\n\n\n\n\n\n# Gráfico de dispersión de longitud del pico vs masa (peso) por especie\npenguins |>\n  ggplot(aes(x = bill_length_mm, y = body_mass_g)) +\n  geom_point(aes(color = species,\n                 shape = species),\n             size = 2) +\n  geom_smooth(method = \"lm\", se = FALSE, aes(color = species)) +\n  scale_color_manual(values = c(\"darkorange\", \"darkorchid\", \"cyan4\")) +\n  ggtitle(\"Longitud del pico vs. masa por especie\") +\n  xlab(\"Longitud del pico (mm)\") +\n  ylab(\"Masa (g)\") +\n  labs(color = \"Especie\", shape = \"Especie\")\n\n\n\n\n\n\n7.6.1.2 Histogramas\nEste tipo de gráficos muestra distribuciones de variables.\n\n# Distribución de la variable de masa (peso)\npenguins |>\n  ggplot(aes(x = body_mass_g)) +\n  geom_histogram() +\n  ggtitle(\"Distribución de la variable masa (peso)\") +\n  xlab(\"Masa (g)\") +\n  ylab(\"n\")\n\n\n\n\n\n# Distribución de la variable de masa (peso) por especie\npenguins |>\n  ggplot(aes(x = body_mass_g)) +\n  geom_histogram(aes(fill = species), alpha = 0.5, position = \"identity\") +\n  scale_fill_manual(values = c(\"darkorange\", \"darkorchid\", \"cyan4\")) +\n  ggtitle(\"Distribución de la variable masa (peso) por especie\") +\n  xlab(\"Masa (g)\") +\n  ylab(\"n\") +\n  labs(fill = \"Especie\")\n\n\n\n\n\n\n7.6.1.3 Diagramas de caja\nEste tipo de gráficos muestra datos a través de sus cuartiles.\n\n# Diagrama de caja de la variable masa (peso)\npenguins |>\n  ggplot(aes(y = body_mass_g)) +\n  geom_boxplot() +\n  ylab(\"Masa (g)\")\n\n\n\n\n\n# Diagrama de caja de la variable masa (peso) por especie\npenguins |>\n  ggplot(aes(x = species, y = body_mass_g)) +\n  geom_boxplot(aes(color = species), width = 0.3, show.legend = FALSE) +\n  scale_color_manual(values = c(\"darkorange\", \"purple\", \"cyan4\")) +\n  xlab(\"Especie\") +\n  ylab(\"Masa (g)\")"
  },
  {
    "objectID": "07-tidyverse.html#datos-tidy",
    "href": "07-tidyverse.html#datos-tidy",
    "title": "7  Tidyverse - paquetes para ciencia de datos",
    "section": "7.7 Datos tidy",
    "text": "7.7 Datos tidy\nLos paquetes de Tidyverse trabajan con datos tidy (i.e. ordenados, organizados), un concepto también introducido por Hadley Wickham y que está relacionado con la organización de los datos en estructuras rectangulares de filas y columnas, similares a las tablas o matrices.\nSegún Wickham, los datos tidy deben cumplir con tres características:\n\nCada variable debe tener su propia columna.\nCada observación debe tener su propia fila.\nCada valor debe tener su propia celda.\n\nEstas características se ilustran en la Figure 7.2.\n\n\n\n\n\nFigure 7.2: Datos tidy. Imagen de Hadley Wickham.\n\n\n\n\nEl empleo de este modelo de datos es común en todos los paquetes de Tidyverse, lo que posibilita aprender y usar sus funciones con mayor facilidad. Además, permite invertir menos esfuerzo en lidiar con diferentes modelos de datos y así dedicar más tiempo y esfuerzo en los problemas de análisis a resolver."
  },
  {
    "objectID": "07-tidyverse.html#pipes",
    "href": "07-tidyverse.html#pipes",
    "title": "7  Tidyverse - paquetes para ciencia de datos",
    "section": "7.8 Pipes",
    "text": "7.8 Pipes\nLas funciones de Tidyverse pueden encadenarse a través del operador pipe (tubo), ya sea el del paquete magrittr (%>%) o el del paquete base de R (|>). Los procesos se enlazan con pipes para formar pipelines (tuberías). En este contexto, un pipeline consiste de una cadena de procesos conectados de forma tal que la salida de cada proceso de la cadena es la entrada del próximo. Esto permite la comunicación y sincronización entre los procesos y evita la anidación (nesting) de llamados a funciones.\nEl siguiente ejemplo implementa un pipeline de dos funciones de Tidyverse:\n\n# Cadena de \"pipes\" entre funciones de Tidyverse\npenguins |>\n  dplyr::filter(species == \"Gentoo\") %>% # subconjunto de observaciones\n  select(species, bill_length_mm, flipper_length_mm) # subconjunto de columnas\n\n# A tibble: 124 × 3\n   species bill_length_mm flipper_length_mm\n   <fct>            <dbl>             <int>\n 1 Gentoo            46.1               211\n 2 Gentoo            50                 230\n 3 Gentoo            48.7               210\n 4 Gentoo            50                 218\n 5 Gentoo            47.6               215\n 6 Gentoo            46.5               210\n 7 Gentoo            45.4               211\n 8 Gentoo            46.7               219\n 9 Gentoo            43.3               209\n10 Gentoo            46.8               215\n# … with 114 more rows\n\n\nUna alternativa a los pipes es la anidación de llamados a funciones:\n\n# Llamados anidados a funciones\nselect(filter(penguins, species == \"Gentoo\"),\n       species,\n       bill_length_mm,\n       flipper_length_mm)\n\n# A tibble: 124 × 3\n   species bill_length_mm flipper_length_mm\n   <fct>            <dbl>             <int>\n 1 Gentoo            46.1               211\n 2 Gentoo            50                 230\n 3 Gentoo            48.7               210\n 4 Gentoo            50                 218\n 5 Gentoo            47.6               215\n 6 Gentoo            46.5               210\n 7 Gentoo            45.4               211\n 8 Gentoo            46.7               219\n 9 Gentoo            43.3               209\n10 Gentoo            46.8               215\n# … with 114 more rows\n\n\nEl uso de pipes permite un funcionamiento homogéneo de las funciones de Tidyverse:\n\nEl primer argumento es un data frame. Puede omitirse si la función recibe el data frame a través del operador pipe.\nLos argumentos siguientes describen que hacer con el data frame, utilizando los nombres de las columnas (sin comillas).\n\nEl resultado es un nuevo data frame."
  },
  {
    "objectID": "07-tidyverse.html#recursos-de-interés",
    "href": "07-tidyverse.html#recursos-de-interés",
    "title": "7  Tidyverse - paquetes para ciencia de datos",
    "section": "7.9 Recursos de interés",
    "text": "7.9 Recursos de interés\nCanelón, S. (s.f.). Slides | Silvia Canelón—An Antarctic Tour of the Tidyverse. Recuperado 16 de octubre de 2022, de https://slides.silviacanelon.com/tour-of-the-tidyverse-v2/#/title-slide\nWickham, H. (2014). Tidy Data. Journal of Statistical Software, 59(1), 1-23. https://doi.org/10.18637/jss.v059.i10\n\n\n\n\n“Tidyverse.” n.d. Accessed May 14, 2022. https://www.tidyverse.org/.\n\n\nWickham, Hadley, and Garrett Grolemund. 2017. R for Data Science: Import, Tidy, Transform, Visualize, and Model Data. 1 edition. Sebastopol, CA: O’Reilly Media. https://r4ds.had.co.nz/."
  },
  {
    "objectID": "08-dplyr.html",
    "href": "08-dplyr.html",
    "title": "8  dplyr - gramática para manipulación de datos",
    "section": "",
    "text": "Wickham, H., & Grolemund, G. (2017). R for Data Science: Import, Tidy, Transform, Visualize, and Model Data (1st ed.). O’Reilly Media. https://r4ds.had.co.nz/"
  },
  {
    "objectID": "08-dplyr.html#resumen",
    "href": "08-dplyr.html#resumen",
    "title": "8  dplyr - gramática para manipulación de datos",
    "section": "8.2 Resumen",
    "text": "8.2 Resumen\nEn este capítulo se estudia el paquete dplyr de Tidyverse."
  },
  {
    "objectID": "08-dplyr.html#características-generales",
    "href": "08-dplyr.html#características-generales",
    "title": "8  dplyr - gramática para manipulación de datos",
    "section": "8.3 Características generales",
    "text": "8.3 Características generales\nEl paquete dplyr de Tidyverse es descrito como una “gramática para la manipulación de datos, la cual proporciona un conjunto consistente de verbos que ayuda a solucionar los retos de manipulación de datos más comunes”. Los principales “verbos” (i.e. funciones) de esta gramática son:\n\nselect(): selecciona columnas con base en sus nombres.\nfilter(): selecciona filas con base en sus valores.\narrange(): cambia el orden de las filas.\nmutate(): crea nuevas columnas, las cuales se expresan como funciones de columnas existentes.\nsummarise(): agrupa y resume valores.\n\nTodas estas operaciones pueden combinarse con la función group_by(), la cual ejecuta cualquiera de las operaciones anteriores “en grupo”. Además, dplyr proporciona funciones adicionales para tareas más específicas.\nTodas las funciones de dplyr trabajan de manera similar:\n\nEl primer argumento es un data frame. Puede omitirse si la función recibe el data frame a través del operador pipe.\nLos argumentos siguientes describen que hacer con el data frame, utilizando los nombres de las columnas (sin comillas).\n\nEl resultado es un nuevo data frame.\n\nLas funciones de dplyr pueden encadenarse a través del operador pipe (tubo), ya sea el del paquete magrittr (%>%) o el del paquete base de R (|>). Los procesos se enlazan con pipes para formar pipelines (tuberías)."
  },
  {
    "objectID": "08-dplyr.html#instalación-y-carga",
    "href": "08-dplyr.html#instalación-y-carga",
    "title": "8  dplyr - gramática para manipulación de datos",
    "section": "8.4 Instalación y carga",
    "text": "8.4 Instalación y carga\nEl paquete dplyr pueden instalarse junto con todos los demás paquete de Tidyverse o de manera individual:\n\n# Instalación conjunta de Tidyverse\ninstall.packages(\"tidyverse\")\n\n# Instalación individual\ninstall.packages(\"dplyr\")\n\nUna vez instalado, dplyr puede cargarse con la función library():\n\n# Carga conjunta de Tidyverse\nlibrary(tidyverse)\n\n# Carga individual\nlibrary(dplyr)"
  },
  {
    "objectID": "08-dplyr.html#conjuntos-de-datos-de-ejemplo",
    "href": "08-dplyr.html#conjuntos-de-datos-de-ejemplo",
    "title": "8  dplyr - gramática para manipulación de datos",
    "section": "8.5 Conjuntos de datos de ejemplo",
    "text": "8.5 Conjuntos de datos de ejemplo\nPara los ejemplos de este capítulo, se utiliza el paquete de datos palmerpenguins.\n\n# Carga del paquete de datos palmerpenguins\nlibrary(palmerpenguins)\n\nEstructura del conjunto de datos penguins:\n\n# Estructura del paquete de datos palmerpenguins\nglimpse(penguins)\n\nRows: 344\nColumns: 8\n$ species           <fct> Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            <fct> Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm <int> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       <int> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               <fct> male, female, female, NA, female, male, female, male…\n$ year              <int> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\nVista del conjunto de datos penguins:\n\n# Vista del paquete de datos palmerpenguins\nView(penguins)"
  },
  {
    "objectID": "08-dplyr.html#funciones",
    "href": "08-dplyr.html#funciones",
    "title": "8  dplyr - gramática para manipulación de datos",
    "section": "8.6 Funciones",
    "text": "8.6 Funciones\n\n8.6.1 select()\nLa función select() selecciona (y opcionalmente renombra) columnas de un data frame con base en sus nombres.\n\n# Selección de las columnas de especie, longitud del pico y sexo\npenguins |>\n  select(species, bill_length_mm, sex)\n\n# A tibble: 344 × 3\n   species bill_length_mm sex   \n   <fct>            <dbl> <fct> \n 1 Adelie            39.1 male  \n 2 Adelie            39.5 female\n 3 Adelie            40.3 female\n 4 Adelie            NA   <NA>  \n 5 Adelie            36.7 female\n 6 Adelie            39.3 male  \n 7 Adelie            38.9 female\n 8 Adelie            39.2 male  \n 9 Adelie            34.1 <NA>  \n10 Adelie            42   <NA>  \n# … with 334 more rows\n\n\nCambio de nombres de columnas:\n\n# Selección y cambio de nombre de las columnas de especie, longitud del pico y sexo\npenguins |>\n  select(especie = species,\n         longitud_pico_mm = bill_length_mm,\n         sexo = sex)\n\n# A tibble: 344 × 3\n   especie longitud_pico_mm sexo  \n   <fct>              <dbl> <fct> \n 1 Adelie              39.1 male  \n 2 Adelie              39.5 female\n 3 Adelie              40.3 female\n 4 Adelie              NA   <NA>  \n 5 Adelie              36.7 female\n 6 Adelie              39.3 male  \n 7 Adelie              38.9 female\n 8 Adelie              39.2 male  \n 9 Adelie              34.1 <NA>  \n10 Adelie              42   <NA>  \n# … with 334 more rows\n\n\nEl operador : permite seleccionar un rango de columnas continuas:\n\n# Selección de las columnas en el rango de species a flipper_length_mm\npenguins |>\n  select(species:flipper_length_mm)\n\n# A tibble: 344 × 5\n   species island    bill_length_mm bill_depth_mm flipper_length_mm\n   <fct>   <fct>              <dbl>         <dbl>             <int>\n 1 Adelie  Torgersen           39.1          18.7               181\n 2 Adelie  Torgersen           39.5          17.4               186\n 3 Adelie  Torgersen           40.3          18                 195\n 4 Adelie  Torgersen           NA            NA                  NA\n 5 Adelie  Torgersen           36.7          19.3               193\n 6 Adelie  Torgersen           39.3          20.6               190\n 7 Adelie  Torgersen           38.9          17.8               181\n 8 Adelie  Torgersen           39.2          19.6               195\n 9 Adelie  Torgersen           34.1          18.1               193\n10 Adelie  Torgersen           42            20.2               190\n# … with 334 more rows\n\n\nSelección de todas las columnas que cumplen una condición:\n\n# Selección de las columnas numéricas\npenguins |>\n  select(where(is.numeric))\n\n# A tibble: 344 × 5\n   bill_length_mm bill_depth_mm flipper_length_mm body_mass_g  year\n            <dbl>         <dbl>             <int>       <int> <int>\n 1           39.1          18.7               181        3750  2007\n 2           39.5          17.4               186        3800  2007\n 3           40.3          18                 195        3250  2007\n 4           NA            NA                  NA          NA  2007\n 5           36.7          19.3               193        3450  2007\n 6           39.3          20.6               190        3650  2007\n 7           38.9          17.8               181        3625  2007\n 8           39.2          19.6               195        4675  2007\n 9           34.1          18.1               193        3475  2007\n10           42            20.2               190        4250  2007\n# … with 334 more rows\n\n\n\n\n8.6.2 filter()\nLa función filter() retorna un subconjunto de un data frame con todas las filas que satisfacen una condición (i.e. expresión lógica).\nEjemplos de uso de expresiones y operadores lógicos:\n\n# Filas de la especie 'Adelie' con longitud del pico mayor o igual a 45 mm\npenguins |>\n  filter(species == 'Adelie' & bill_length_mm >= 45)\n\n# A tibble: 3 × 8\n  species island    bill_length_mm bill_depth_mm flipper_l…¹ body_…² sex    year\n  <fct>   <fct>              <dbl>         <dbl>       <int>   <int> <fct> <int>\n1 Adelie  Torgersen           46            21.5         194    4200 male   2007\n2 Adelie  Torgersen           45.8          18.9         197    4150 male   2008\n3 Adelie  Biscoe              45.6          20.3         191    4600 male   2009\n# … with abbreviated variable names ¹​flipper_length_mm, ²​body_mass_g\n\n\n\n# Filas de la especie 'Adelie' o 'Gentoo'\npenguins |>\n  filter(species == 'Adelie' | species == 'Gentoo')\n\n# A tibble: 276 × 8\n   species island    bill_length_mm bill_depth_mm flipper_…¹ body_…² sex    year\n   <fct>   <fct>              <dbl>         <dbl>      <int>   <int> <fct> <int>\n 1 Adelie  Torgersen           39.1          18.7        181    3750 male   2007\n 2 Adelie  Torgersen           39.5          17.4        186    3800 fema…  2007\n 3 Adelie  Torgersen           40.3          18          195    3250 fema…  2007\n 4 Adelie  Torgersen           NA            NA           NA      NA <NA>   2007\n 5 Adelie  Torgersen           36.7          19.3        193    3450 fema…  2007\n 6 Adelie  Torgersen           39.3          20.6        190    3650 male   2007\n 7 Adelie  Torgersen           38.9          17.8        181    3625 fema…  2007\n 8 Adelie  Torgersen           39.2          19.6        195    4675 male   2007\n 9 Adelie  Torgersen           34.1          18.1        193    3475 <NA>   2007\n10 Adelie  Torgersen           42            20.2        190    4250 <NA>   2007\n# … with 266 more rows, and abbreviated variable names ¹​flipper_length_mm,\n#   ²​body_mass_g\n\n\n\n# Filas de especies diferentes a 'Chinstrap'\npenguins |>\n  filter(!(species == 'Chinstrap'))\n\n# A tibble: 276 × 8\n   species island    bill_length_mm bill_depth_mm flipper_…¹ body_…² sex    year\n   <fct>   <fct>              <dbl>         <dbl>      <int>   <int> <fct> <int>\n 1 Adelie  Torgersen           39.1          18.7        181    3750 male   2007\n 2 Adelie  Torgersen           39.5          17.4        186    3800 fema…  2007\n 3 Adelie  Torgersen           40.3          18          195    3250 fema…  2007\n 4 Adelie  Torgersen           NA            NA           NA      NA <NA>   2007\n 5 Adelie  Torgersen           36.7          19.3        193    3450 fema…  2007\n 6 Adelie  Torgersen           39.3          20.6        190    3650 male   2007\n 7 Adelie  Torgersen           38.9          17.8        181    3625 fema…  2007\n 8 Adelie  Torgersen           39.2          19.6        195    4675 male   2007\n 9 Adelie  Torgersen           34.1          18.1        193    3475 <NA>   2007\n10 Adelie  Torgersen           42            20.2        190    4250 <NA>   2007\n# … with 266 more rows, and abbreviated variable names ¹​flipper_length_mm,\n#   ²​body_mass_g\n\n\n\n# Filas con longitud del pico mayor o igual al promedio\n#   El argumento lógico na.rm de mean() indica si los valores NA (\"not available\") \n#   deben ser removidos antes del cálculo\npenguins |>\n  filter(bill_length_mm >= mean(bill_length_mm, na.rm = TRUE))\n\n# A tibble: 175 × 8\n   species island    bill_length_mm bill_depth_mm flipper_…¹ body_…² sex    year\n   <fct>   <fct>              <dbl>         <dbl>      <int>   <int> <fct> <int>\n 1 Adelie  Torgersen           46            21.5        194    4200 male   2007\n 2 Adelie  Dream               44.1          19.7        196    4400 male   2007\n 3 Adelie  Torgersen           45.8          18.9        197    4150 male   2008\n 4 Adelie  Biscoe              45.6          20.3        191    4600 male   2009\n 5 Adelie  Torgersen           44.1          18          210    4000 male   2009\n 6 Gentoo  Biscoe              46.1          13.2        211    4500 fema…  2007\n 7 Gentoo  Biscoe              50            16.3        230    5700 male   2007\n 8 Gentoo  Biscoe              48.7          14.1        210    4450 fema…  2007\n 9 Gentoo  Biscoe              50            15.2        218    5700 male   2007\n10 Gentoo  Biscoe              47.6          14.5        215    5400 male   2007\n# … with 165 more rows, and abbreviated variable names ¹​flipper_length_mm,\n#   ²​body_mass_g\n\n\nCondiciones relacionadas con valores NA:\n\n# Filas con valor NA en la columna sex\npenguins |>\n  select(species, island, sex) %>%\n  filter(is.na(sex))\n\n# A tibble: 11 × 3\n   species island    sex  \n   <fct>   <fct>     <fct>\n 1 Adelie  Torgersen <NA> \n 2 Adelie  Torgersen <NA> \n 3 Adelie  Torgersen <NA> \n 4 Adelie  Torgersen <NA> \n 5 Adelie  Torgersen <NA> \n 6 Adelie  Dream     <NA> \n 7 Gentoo  Biscoe    <NA> \n 8 Gentoo  Biscoe    <NA> \n 9 Gentoo  Biscoe    <NA> \n10 Gentoo  Biscoe    <NA> \n11 Gentoo  Biscoe    <NA> \n\n\nLa función drop_na() remueve las filas con valores NA en una o varias columnas.\n\n# Filas con valor diferente a NA en la columna sex\npenguins |>\n  select(species,\n         bill_length_mm,\n         bill_depth_mm,\n         flipper_length_mm,\n         body_mass_g,\n         sex) %>%\n  drop_na(sex)\n\n# A tibble: 333 × 6\n   species bill_length_mm bill_depth_mm flipper_length_mm body_mass_g sex   \n   <fct>            <dbl>         <dbl>             <int>       <int> <fct> \n 1 Adelie            39.1          18.7               181        3750 male  \n 2 Adelie            39.5          17.4               186        3800 female\n 3 Adelie            40.3          18                 195        3250 female\n 4 Adelie            36.7          19.3               193        3450 female\n 5 Adelie            39.3          20.6               190        3650 male  \n 6 Adelie            38.9          17.8               181        3625 female\n 7 Adelie            39.2          19.6               195        4675 male  \n 8 Adelie            41.1          17.6               182        3200 female\n 9 Adelie            38.6          21.2               191        3800 male  \n10 Adelie            34.6          21.1               198        4400 male  \n# … with 323 more rows\n\n\n\n# Filas con valor diferente a NA en cualquier columna\npenguins |>\n  select(species,\n         bill_length_mm,\n         bill_depth_mm,\n         flipper_length_mm,\n         body_mass_g,\n         sex) %>%\n  drop_na()\n\n# A tibble: 333 × 6\n   species bill_length_mm bill_depth_mm flipper_length_mm body_mass_g sex   \n   <fct>            <dbl>         <dbl>             <int>       <int> <fct> \n 1 Adelie            39.1          18.7               181        3750 male  \n 2 Adelie            39.5          17.4               186        3800 female\n 3 Adelie            40.3          18                 195        3250 female\n 4 Adelie            36.7          19.3               193        3450 female\n 5 Adelie            39.3          20.6               190        3650 male  \n 6 Adelie            38.9          17.8               181        3625 female\n 7 Adelie            39.2          19.6               195        4675 male  \n 8 Adelie            41.1          17.6               182        3200 female\n 9 Adelie            38.6          21.2               191        3800 male  \n10 Adelie            34.6          21.1               198        4400 male  \n# … with 323 more rows\n\n\n\n\n8.6.3 arrange()\nLa función arrange() cambia el orden de las filas de un data frame de acuerdo con los valores de las columnas seleccionadas.\n\n# Ordenamiento ascendente por las columnas 'bill_lenght_mm' y 'bill_depth_mm'\npenguins |>\n  arrange(bill_length_mm, bill_depth_mm)\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_…¹ body_…² sex    year\n   <fct>   <fct>              <dbl>         <dbl>      <int>   <int> <fct> <int>\n 1 Adelie  Dream               32.1          15.5        188    3050 fema…  2009\n 2 Adelie  Dream               33.1          16.1        178    2900 fema…  2008\n 3 Adelie  Torgersen           33.5          19          190    3600 fema…  2008\n 4 Adelie  Dream               34            17.1        185    3400 fema…  2008\n 5 Adelie  Torgersen           34.1          18.1        193    3475 <NA>   2007\n 6 Adelie  Torgersen           34.4          18.4        184    3325 fema…  2007\n 7 Adelie  Biscoe              34.5          18.1        187    2900 fema…  2008\n 8 Adelie  Torgersen           34.6          17.2        189    3200 fema…  2008\n 9 Adelie  Torgersen           34.6          21.1        198    4400 male   2007\n10 Adelie  Biscoe              35            17.9        190    3450 fema…  2008\n# … with 334 more rows, and abbreviated variable names ¹​flipper_length_mm,\n#   ²​body_mass_g\n\n\nPor defecto, las columnas se ordenan de manera acendente. Si se desea un orden descendente, puede utilizarse la función desc().\n\n# Ordenamiento descendente por las columnas 'bill_lenght_mm' y 'bill_depth_mm'\npenguins |>\n  arrange(desc(bill_length_mm), desc(bill_depth_mm))\n\n# A tibble: 344 × 8\n   species   island bill_length_mm bill_depth_mm flipper_l…¹ body_…² sex    year\n   <fct>     <fct>           <dbl>         <dbl>       <int>   <int> <fct> <int>\n 1 Gentoo    Biscoe           59.6          17           230    6050 male   2007\n 2 Chinstrap Dream            58            17.8         181    3700 fema…  2007\n 3 Gentoo    Biscoe           55.9          17           228    5600 male   2009\n 4 Chinstrap Dream            55.8          19.8         207    4000 male   2009\n 5 Gentoo    Biscoe           55.1          16           230    5850 male   2009\n 6 Gentoo    Biscoe           54.3          15.7         231    5650 male   2008\n 7 Chinstrap Dream            54.2          20.8         201    4300 male   2008\n 8 Chinstrap Dream            53.5          19.9         205    4500 male   2008\n 9 Gentoo    Biscoe           53.4          15.8         219    5500 male   2009\n10 Chinstrap Dream            52.8          20           205    4550 male   2008\n# … with 334 more rows, and abbreviated variable names ¹​flipper_length_mm,\n#   ²​body_mass_g\n\n\nNótese que los valores NA se ubican al final de cualquier ordenamiento.\nLa función across() aplica una función en múltiples columnas.\n\n# Ordenamiento ascendente por las columnas que empiezan con 'bill'\npenguins |>\n  arrange(across(starts_with('bill')))\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_…¹ body_…² sex    year\n   <fct>   <fct>              <dbl>         <dbl>      <int>   <int> <fct> <int>\n 1 Adelie  Dream               32.1          15.5        188    3050 fema…  2009\n 2 Adelie  Dream               33.1          16.1        178    2900 fema…  2008\n 3 Adelie  Torgersen           33.5          19          190    3600 fema…  2008\n 4 Adelie  Dream               34            17.1        185    3400 fema…  2008\n 5 Adelie  Torgersen           34.1          18.1        193    3475 <NA>   2007\n 6 Adelie  Torgersen           34.4          18.4        184    3325 fema…  2007\n 7 Adelie  Biscoe              34.5          18.1        187    2900 fema…  2008\n 8 Adelie  Torgersen           34.6          17.2        189    3200 fema…  2008\n 9 Adelie  Torgersen           34.6          21.1        198    4400 male   2007\n10 Adelie  Biscoe              35            17.9        190    3450 fema…  2008\n# … with 334 more rows, and abbreviated variable names ¹​flipper_length_mm,\n#   ²​body_mass_g\n\n\n\n# Ordenamiento ascendente por las columnas que contienen la hilera 'lenght'\npenguins |>\n  arrange(across(contains('length')))\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_…¹ body_…² sex    year\n   <fct>   <fct>              <dbl>         <dbl>      <int>   <int> <fct> <int>\n 1 Adelie  Dream               32.1          15.5        188    3050 fema…  2009\n 2 Adelie  Dream               33.1          16.1        178    2900 fema…  2008\n 3 Adelie  Torgersen           33.5          19          190    3600 fema…  2008\n 4 Adelie  Dream               34            17.1        185    3400 fema…  2008\n 5 Adelie  Torgersen           34.1          18.1        193    3475 <NA>   2007\n 6 Adelie  Torgersen           34.4          18.4        184    3325 fema…  2007\n 7 Adelie  Biscoe              34.5          18.1        187    2900 fema…  2008\n 8 Adelie  Torgersen           34.6          17.2        189    3200 fema…  2008\n 9 Adelie  Torgersen           34.6          21.1        198    4400 male   2007\n10 Adelie  Biscoe              35            17.9        190    3450 fema…  2008\n# … with 334 more rows, and abbreviated variable names ¹​flipper_length_mm,\n#   ²​body_mass_g\n\n\n\n\n8.6.4 mutate()\nLa función mutate() crea o modifica columnas en un data frame.\n\n# Creación de la columna 'body_mass_kg' con el valor de 'body_mass_g' expresado en kg\npenguins |>\n  select(species, body_mass_g) |>\n  mutate(body_mass_kg = body_mass_g/1000)\n\n# A tibble: 344 × 3\n   species body_mass_g body_mass_kg\n   <fct>         <int>        <dbl>\n 1 Adelie         3750         3.75\n 2 Adelie         3800         3.8 \n 3 Adelie         3250         3.25\n 4 Adelie           NA        NA   \n 5 Adelie         3450         3.45\n 6 Adelie         3650         3.65\n 7 Adelie         3625         3.62\n 8 Adelie         4675         4.68\n 9 Adelie         3475         3.48\n10 Adelie         4250         4.25\n# … with 334 more rows\n\n\n\n# Creación de la columnas 'body_mass_g_mean' (promedio de masa) \n# y 'body_mass_g_normalized' (proporción con respecto al promedio)\npenguins |>\n  select(species, body_mass_g) |>\n  mutate(body_mass_g_mean = mean(body_mass_g, na.rm = TRUE)) |>\n  mutate(body_mass_g_normalized = body_mass_g / body_mass_g_mean)\n\n# A tibble: 344 × 4\n   species body_mass_g body_mass_g_mean body_mass_g_normalized\n   <fct>         <int>            <dbl>                  <dbl>\n 1 Adelie         3750            4202.                  0.892\n 2 Adelie         3800            4202.                  0.904\n 3 Adelie         3250            4202.                  0.773\n 4 Adelie           NA            4202.                 NA    \n 5 Adelie         3450            4202.                  0.821\n 6 Adelie         3650            4202.                  0.869\n 7 Adelie         3625            4202.                  0.863\n 8 Adelie         4675            4202.                  1.11 \n 9 Adelie         3475            4202.                  0.827\n10 Adelie         4250            4202.                  1.01 \n# … with 334 more rows\n\n\nLa función group_by() agrupa una o más columnas.\n\n# Creación de la columnas 'body_mass_g_mean_species' (promedio de masa de la especie) \n# y 'body_mass_g_species_normalized' (proporción con respecto al promedio de masa de la especie)\npenguins |>\n  select(species, body_mass_g) |>\n  group_by(species) |>\n  mutate(body_mass_g_mean_species = mean(body_mass_g, na.rm = TRUE)) |>\n  mutate(body_mass_g_species_normalized = body_mass_g / body_mass_g_mean_species)\n\n# A tibble: 344 × 4\n# Groups:   species [3]\n   species body_mass_g body_mass_g_mean_species body_mass_g_species_normalized\n   <fct>         <int>                    <dbl>                          <dbl>\n 1 Adelie         3750                    3701.                          1.01 \n 2 Adelie         3800                    3701.                          1.03 \n 3 Adelie         3250                    3701.                          0.878\n 4 Adelie           NA                    3701.                         NA    \n 5 Adelie         3450                    3701.                          0.932\n 6 Adelie         3650                    3701.                          0.986\n 7 Adelie         3625                    3701.                          0.980\n 8 Adelie         4675                    3701.                          1.26 \n 9 Adelie         3475                    3701.                          0.939\n10 Adelie         4250                    3701.                          1.15 \n# … with 334 more rows\n\n\n\n\n8.6.5 summarise()\nLa función summarise() crea un nuevo data frame con una (o más filas), correspondientes a combinaciones de las columnas usadas en una agrupación. Esta función frecuentemente se usa en combinación con group_by(). Si no hay agrupación, se retorna una sola fila que sumariza todas las observaciones de la entrada.\nSumarización sin agrupamiento:\n\n# Creación de un data frame con las columnas sumarizadas 'body_mass_g_mean' (promedio de masa) \n# y 'n' (cantidad de individuos)\npenguins |>\n  summarise(body_mass_g_mean = mean(body_mass_g, na.rm = TRUE),\n            n = n())\n\n# A tibble: 1 × 2\n  body_mass_g_mean     n\n             <dbl> <int>\n1            4202.   344\n\n\nLa función n() cuenta la cantidad de filas en un grupo.\nSumarización con agrupamiento:\n\n# Creación de un data frame con las columnas sumarizadas de mínimo, máximo y promedio de masa,\n# y cantidad de individuos para cada especie\npenguins |>\n  group_by(species) |>\n  summarise(\n    body_mass_g_min = min(body_mass_g, na.rm = TRUE),\n    body_mass_g_max = max(body_mass_g, na.rm = TRUE),\n    body_mass_g_mean = mean(body_mass_g, na.rm = TRUE),\n    n = n()\n  )\n\n# A tibble: 3 × 5\n  species   body_mass_g_min body_mass_g_max body_mass_g_mean     n\n  <fct>               <int>           <int>            <dbl> <int>\n1 Adelie               2850            4775            3701.   152\n2 Chinstrap            2700            4800            3733.    68\n3 Gentoo               3950            6300            5076.   124\n\n\n\n\n8.6.6 Otras\n\n8.6.6.1 count()\nUna forma alternativa (a summarise()) de realizar un conteo es con la función count():\n\n# Creación de un data frame con el conteo de individuos por especie\npenguins |>\n  count(species)\n\n# A tibble: 3 × 2\n  species       n\n  <fct>     <int>\n1 Adelie      152\n2 Chinstrap    68\n3 Gentoo      124"
  },
  {
    "objectID": "08-dplyr.html#ejercicios",
    "href": "08-dplyr.html#ejercicios",
    "title": "8  dplyr - gramática para manipulación de datos",
    "section": "8.7 Ejercicios",
    "text": "8.7 Ejercicios\nUtilice las funciones de dplyr para responder a las siguientes preguntas sobre el conjunto de datos penguins:\n\n¿Cuántos individuos de cada sexo hay en cada especie?\n¿Cuál es el mínimo, máximo y promedio de masa corporal (peso) por especie y sexo?\n¿Cuántos individuos se observaron durante cada año?\n¿Cuántos individuos de cada especie se observaron durante cada año?\n¿Cuántos individuos de cada especie y cada sexo se observaron durante cada año?\n¿Cuál es el promedio de masa corporal (peso) por año?\n¿Cuál es el promedio de masa corporal (peso) por año para cada especie?"
  },
  {
    "objectID": "08-dplyr.html#recursos-de-interés",
    "href": "08-dplyr.html#recursos-de-interés",
    "title": "8  dplyr - gramática para manipulación de datos",
    "section": "8.8 Recursos de interés",
    "text": "8.8 Recursos de interés\nRStudio. (2017). Data transformation with dplyr::Cheat Sheet. https://github.com/rstudio/cheatsheets/blob/45c1e642468695830fd8b724587ccfe8901e2185/data-transformation.pdf"
  },
  {
    "objectID": "09-ggplot2-plotly.html",
    "href": "09-ggplot2-plotly.html",
    "title": "9  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "",
    "text": "Chang, W. (2018). R graphics cookbook: Practical recipes for visualizing data. O’Reilly. https://r-graphics.org/\nWickham, H., & Grolemund, G. (2017). R for Data Science: Import, Tidy, Transform, Visualize, and Model Data (capítulo 3). O’Reilly Media. https://r4ds.had.co.nz/\nWickham, H., Navarro, D., & Pedersen, T. L. (s.f.). ggplot2: Elegant graphics for data analysis. https://ggplot2-book.org/"
  },
  {
    "objectID": "09-ggplot2-plotly.html#resumen",
    "href": "09-ggplot2-plotly.html#resumen",
    "title": "9  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "9.2 Resumen",
    "text": "9.2 Resumen\nR proporciona una gran cantidad de funciones para la elaboración de gráficos estadísticos. En este capítulo, se describen algunos de los paquetes que contienen estas funciones y se ejemplifican varios tipos de gráficos. Específicamente, se estudia el paquete ggplot2, para la creación declarativa de gráficos y el paquete plotly, para graficación interactiva.\nAdicionalmente, se introducen el paquete DT, para la creación de tablas interactivas, y el paquete readr, para lectura de datos tabulares. También algunos paquetes con conjuntos de datos de ejemplo y para estilos de ggplot2."
  },
  {
    "objectID": "09-ggplot2-plotly.html#instalación-y-carga",
    "href": "09-ggplot2-plotly.html#instalación-y-carga",
    "title": "9  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "9.3 Instalación y carga",
    "text": "9.3 Instalación y carga\nLos paquetes pueden instalarse con la función install.packages().\n\n# Instalación de todos los paquetes de Tidyverse (opcional).\n# Si se hace, no es necesario instalar ggplot2 y readr por separado.\ninstall.packages(\"tidyverse\")\n\n# Instalación de ggplot2\ninstall.packages(\"ggplot2\")\n\n# Instalación de readr\ninstall.packages(\"readr\")\n\n# Instalación de plotly\ninstall.packages(\"plotly\")\n\n# Instalación de DT\ninstall.packages(\"DT\")\n\nUna vez instalados, todos los paquetes pueden cargarse con la función library():\n\n# Carga de todos los paquetes de Tidyverse (opcional).\n# Si se hace, no es necesario cargar ggplot2 y readr por separado.\nlibrary(tidyverse)\n\n# Carga de ggplot2\nlibrary(ggplot2)\n\n# Carga de readr\nlibrary(readr)\n\n# Carga de plotly\nlibrary(plotly)\n\n# Carga de DT\nlibrary(DT)\n\n# Carga de dplyr\nlibrary(dplyr)"
  },
  {
    "objectID": "09-ggplot2-plotly.html#conjuntos-de-datos-de-ejemplo",
    "href": "09-ggplot2-plotly.html#conjuntos-de-datos-de-ejemplo",
    "title": "9  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "9.4 Conjuntos de datos de ejemplo",
    "text": "9.4 Conjuntos de datos de ejemplo\n\n9.4.1 mpg\nmpg es uno de los conjuntos de datos de ejemplo que se incluyen junto con el paquete ggplot2. Contiene observaciones para 38 modelos de automóviles, recopiladas por la Agencia de Protección Ambiental de los Estados Unidos, y un conjunto de variables relacionadas con el consumo de combustible.\nEn el siguiente bloque de código, se utiliza el paquete DT, para desplegar las observaciones de mpg en una tabla.\n\n# Tabla de datos de mpg\nmpg |>\n  datatable(options = list(\n    pageLength = 5,\n    language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n  ))\n\n\n\n\n\n\n\n\n9.4.2 diamonds\ndiamonds es otro de los conjuntos de datos de ejemplo de ggplot2. Contiene observaciones de más de 50000 diamantes, incluyendo su precio, color, claridad y otros atributos.\nEn el siguiente bloque de código, se utiliza el paquete DT, para desplegar las observaciones de diamonds en una tabla.\n\n# Tabla de datos de diamonds\ndiamonds |>\n  datatable(options = list(\n    pageLength = 5,\n    language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n  ))\n\n\n\n\n\n\n\n\n9.4.3 gapminder\nEs un extracto de los datos disponibles en Gapminder.org, una organización son fines de lucro que promueve el desarrollo global y el cumplimiento de los Objetivos de Desarrollo del Milenio de las Naciones Unidas, a través de la estadística y la información general sobre desarrollo social, económico y ambiental a nivel local, nacional y global.\nSe distribuye en el paquete gapminder, el cual contiene el data frame gapminder, que incluye datos de esperanza de vida, producto interno bruto y población de 142 países, para cada cinco años, entre 1952 y 2007.\n\n# Instalación de gapminder\ninstall.packages(\"gapminder\")\n\n\n# Carga de gapminder\nlibrary(gapminder)\n\nLa siguiente tabla muestra los datos de gapminder para el año 2007.\n\n# Tabla de datos de gapminder\ngapminder |>\n  filter(year == 2007) |> # filtro para el año 2007\n  datatable(options = list(\n    pageLength = 5,\n    language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n  ))\n\n\n\n\n\n\n\n\n9.4.4 Casos de COVID-19 en Costa Rica\nEstos datos son publicados por el Ministerio de Salud de Costa Rica en https://geovision.uned.ac.cr/oges/. Se distribuyen en archivos CSV, incluyendo un archivo de datos generales para todo el país y varios archivos con datos por cantón. La fecha de la última actualización es 2022-05-30.\nAlternativamente, puede descargar los archivos necesarios de los siguientes enlaces:\n\n05_30_22_CSV_GENERAL.csv\n05_30_22_CSV_POSITIVOS.csv\n\nEl siguiente bloque de código, carga y transforma los datos generales de COVID-19 con funciones de readr y dplyr. La función read_delim() de readr, lee datos de formatos tabulares (ej. CSV, TSV) y, entre otras ventajas, permite cargar solo las columnas especificadas en el argumento col_select.\n\n# Carga del archivo CSV de entrada en un dataframe\n# con la función read_delim() de readr\ncovid_general <-\n  read_delim(\n    file = \"datos/ministerio-salud/covid/05_30_22_CSV_GENERAL.csv\",\n    col_select = c(\n      \"FECHA\",\n      \"positivos\",\n      \"activos\",\n      \"RECUPERADOS\",\n      \"fallecidos\",\n      \"nue_posi\",\n      \"nue_falleci\",\n      \"salon\",\n      \"UCI\"\n    ) # lista de columnas que se leen del archivo\n  )\n\n# Cambio de nombre de columnas\ncovid_general <-\n  covid_general |>\n  rename(\n    fecha = FECHA,\n    recuperados = RECUPERADOS,\n    nuevos_positivos = nue_posi,\n    nuevos_fallecidos = nue_falleci,\n    uci = UCI\n  )\n\n# Cambio de tipo de datos de la columna fecha, de str a date\ncovid_general <-\n  covid_general |>\n  mutate(fecha = as.Date(fecha, format = \"%d/%m/%Y\"))\n\nLa siguiente tabla muestra los datos generales de COVID-19.\n\n# Tabla de datos de COVID generales\ncovid_general |>\n  datatable(options = list(\n    pageLength = 5,\n    language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n  ))\n\n\n\n\n\n\nSeguidamente, se cargan y transforman los datos cantonales de casos positivos.\n\n# Carga del archivo CSV de entrada en un dataframe\n# con la función read_delim() de readr\ncovid_cantonal_positivos <-\n  read_delim(\n    file = \"datos/ministerio-salud/covid/05_30_22_CSV_POSITIVOS.csv\",\n    locale = locale(encoding = \"WINDOWS-1252\"), # para procesar las tildes\n    col_select = c(\"provincia\", \"canton\", \"30/05/2022\")\n  )\n\n# Cambio de nombre de columnas\ncovid_cantonal_positivos <-\n  covid_cantonal_positivos |>\n  rename(\n    positivos = '30/05/2022'\n  )\n\n# Borrado de filas con valor NA u \"Otros\"\n# en la columna canton\ncovid_cantonal_positivos <-\n  covid_cantonal_positivos |>\n   filter(!is.na(canton) & canton != \"Otros\")\n\nLa siguiente tabla muestra los datos cantonales de casos positivos de COVID-19.\n\n# Tabla de datos de COVID cantonales positivos\ncovid_cantonal_positivos |>\n  datatable(options = list(\n    pageLength = 5,\n    language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n  ))"
  },
  {
    "objectID": "09-ggplot2-plotly.html#características-generales",
    "href": "09-ggplot2-plotly.html#características-generales",
    "title": "9  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "9.5 Características generales",
    "text": "9.5 Características generales\n\n9.5.1 ggplot2\nggplot2 es un sistema para la creación declarativa de gráficos, creado por Hadley Wickham en 2005. Está basado en el libro The Grammar of Graphics, de Leland Wilkinson, un esquema general para visualización de datos que descompone un gráfico en sus principales componentes semáticos, tales como capas y geometrías.\n\n9.5.1.1 Principales componentes de un gráfico\nDe acuerdo con The Grammar of Graphics, los tres principales componentes de un gráfico son:\n\nDatos (observaciones y variables).\nConjunto de mapeos de las variables del conjunto de datos a propiedades visuales (aesthetics) del gráfico, tales como posición en el eje x, posición en el eje y, color, tamaño y forma, entre otras.\nAl menos una capa, la cual describe como graficar cada observación. Por lo general, las capas se crean con funciones de geometrías (ej. puntos, líneas, barras).\n\n\n\n9.5.1.2 Opciones básicas\nggplot2 implementa un gráfico estadístico por medio de la función ggplot(), cuya sintaxis básica puede resumirse de la siguiente forma:\nggplot(data = <DATOS>) + \n    <FUNCION_GEOMETRIA>(mapping = aes(<MAPEOS>))\nEl llamado a ggplot() crea un sistema de coordenadas (i.e. un “canvas”), al cual se le agregan capas. Su primer argumento es <DATOS>, el cual es usualmente un dataframe o un tibble.\nLa función aes() realiza los mapeos (<MAPEOS>) de las variables del conjunto de datos a las propiedades visuales del gráfico. Las capas se crean con funciones de geometrías (<FUNCION_GEOMETRIA>) como geom_point(), geom_bar() o geom_histogram(), entre muchas otras. Note el uso del operador + para agregar las capas al gráfico.\nComo ejemplo, se crea un gráfico de dispersión que muestra la variable engine displacement o cilindrada (displ) en el eje X, y la variable highway miles per gallon o millas por galón en autopista (hwy) en el eje Y.\n\n# Gráfico de dispersión de cilindrada vs millas por galón en autopista\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy))\n\n\n\n\nEl bloque de código anterior puede reescribirse mediante un pipe, para pasar el conjunto de datos a ggplot(). También puede llamarse a aes() como un argumento de ggplot() y no de la función de geometría. Esto último acostumbra hacerse cuando los mapeos de las variables a las propiedades estéticas son los mismos en todas las capas del gráfico.\n\n# Gráfico de dispersión de cilindrada vs millas por galón en autopista\nmpg |>\n  ggplot(aes(x = displ, y = hwy)) +\n  geom_point()\n\n\n\n\nEl gráfico muestra una relación negativa entre el tamaño del motor (displ) y la eficiencia en el uso del combustible (hwy). En otras palabras, los vehículos con motores grandes usan más combustible.\n\n\n9.5.1.3 Variables adicionales\nSe pueden incluir variables adicionales en el gráfico mediante su mapeo a otras propiedades visuales. En el siguiente bloque de código, la variable tipo de automóvil (class), se mapea a la propiedad color.\n\n# Gráfico de dispersión de cilindrada vs millas por galón en autopista\n# coloreado por tipo de automóvil\nmpg |>\n  ggplot(aes(x = displ, y = hwy, color = class)) +\n  geom_point()\n\n\n\n\nLa misma variable puede mapearse a la propiedad visual shape (forma). La categoría de los SUV no se incluye en el gráfico debido a que ggplot solo muestra, por defecto, seis formas diferentes cuando se asignan de manera automática (el problema puede solucionarse si se asignan explicitamente).\n\n# Gráfico de dispersión de cilindrada vs millas por galón en autopista\n# con formas de puntos correspondientes al tipo de automóvil\nmpg |>\n  ggplot(aes(x = displ, y = hwy, shape = class)) +\n  geom_point()\n\n\n\n\n\n\n9.5.1.4 Capas adicionales\nUn mismo gráfico puede contener múltiples capas, cada una con su propia función de geometría. El siguiente bloque de código agrega una capa con la función geom_smooth(), la cual muestra una curva de tendencia.\n\n# Gráfico de dispersión de cilindrada vs millas por galón en autopista\n# + curva de tendencia\nmpg |>\n  ggplot(aes(x = displ, y = hwy)) +\n  geom_point() +\n  geom_smooth()\n\n\n\n\nEn el siguiente ejemplo, se mapea la variable tipo de tracción (drv) a la propiedad visual del color, tanto para la capa de puntos como para la de la curva de tendencia.\n\n# Gráfico de dispersión de cilindrada vs millas por galón en autopista\n# coloreado por tipo de tracción\n# + curva de tendencia\nmpg |>\n  ggplot(aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  geom_smooth()\n\n\n\n\nEl siguiente gráfico muestra varias capas, correspondientes a geometrías de puntos y curvas de tendencia. aes() se llama en las funciones de geometrías debido a que cada una realiza mapeos diferentes.\n\n# Gráfico de dispersión de cilindrada vs millas por galón en autopista\n# + gráfico de dispersión de cilindrada vs millas por galón en ciudad\n# + curvas de tendencias\nmpg |>\n  ggplot(aes(x = displ)) +\n  geom_point(aes(y = hwy), color = \"green\") +\n  geom_smooth(aes(y = hwy), color = \"green\") +\n  geom_point(aes(y = cty), color = \"red\") +\n  geom_smooth(aes(y = cty), color = \"red\")  \n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n9.5.1.5 Facets\nComo se mostró anteriormente, una forma de mostrar variables adicionales en un gráfico es mediante propiedades visuales (color, forma, tamaño, etc.). Otra forma es mediante el uso de facets, los cuales dividen un gráfico en subgráficos, de acuerdo con los valores de una variable. Este método es particularmente apropiado cuando la variable adicional es categórica o discreta.\nLa función facet_wrap() divide un gráfico de acuerdo con una sola variable. El primer argumento es una fórmula, la cual se crea con el caracter ~ seguido por el nombre de una variable.\nEn el siguiente bloque de código, se generan facets para el gráfico de dispersión de cilindrada vs millas por galón en autopista, de acuerdo con el tipo de automóvil. Es decir, un facet (subgráfico) por cada tipo de automóvil.\n\n# Gráfico de dispersión de cilindrada vs millas por galón en autopista\n# + facets por tipo de automóvil\nmpg |>\n  ggplot(aes(x = displ, y = hwy)) +\n  geom_point() +\n  facet_wrap(~ class, nrow = 2)\n\n\n\n\nLa función facet_grid() genera los subgráficos con la combinación de dos variables. El primer argumento es también una fórmula, la cual contiene dos variables separadas por ~.\nEn el siguiente bloque de código, se generan facets para el gráfico de dispersión de cilindrada vs millas por galón en autopista, de acuerdo con el tipo de automóvil y el tipo de tracción.\n\n# Gráfico de dispersión de cilindrada vs millas por galón en autopista\n# + facets por tipo de automóvil y tipo de tracción\nmpg |>\n  ggplot(aes(x = displ, y = hwy)) +\n  geom_point() +\n  facet_grid(class ~ drv)\n\n\n\n\n\n\n9.5.1.6 Títulos, etiquetas y estilos\nggplot2 incluye las funciones ggtitle(), xlab(), ylab() y labs(), las cuales permiten agregar títulos, subtítulos, etiquetas en los ejes y de otros tipos a un gráfico.\nAlgunas de las opciones que ofrecen estas funciones se ilustran en el siguiente gráfico.\n\n# Gráfico de dispersión de cilindrada vs millas por galón en autopista\n# coloreado por tipo de tracción con título, subtítulo y etiquetas\nmpg |>\n  ggplot(aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  geom_smooth() +\n  ggtitle(\"Cilindrada vs rendimiento en autopista\") +\n  xlab(\"Cilindrada (l)\") +\n  ylab(\"Rendimiento en autopista (mpg)\") +\n  labs(subtitle = \"Datos de 38 modelos de automóviles de años entre 1999 y 2008\", \n       caption = \"Fuente: United States Environmental Protection Agency (EPA)\",\n       color = \"Tipo de tracción\")\n\n\n\n\nEl títulos y las etiquetas de los ejes se pueden agregar también mediante argumentos de labs().\n\n9.5.1.6.1 Temas\nggplot2 incluye un conjunto de temas (estilos) que pueden mejorar el aspecto visual de los gráficos.\n\n# Gráfico de dispersión de cilindrada vs millas por galón en autopista\n# coloreado por tipo de tracción con título, subtítulo, etiquetas y tema\nmpg |>\n  ggplot(aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  geom_smooth() +\n  ggtitle(\"Cilindrada vs rendimiento en autopista\") +\n  xlab(\"Cilindrada (l)\") +\n  ylab(\"Rendimiento en autopista (mpg)\") +\n  labs(subtitle = \"Datos de 38 modelos de automóviles de años entre 1999 y 2008\", \n       caption = \"Fuente: United States Environmental Protection Agency (EPA)\",\n       color = \"Tipo de tracción\") +\n  theme_bw() # tema de ggplot2\n\n\n\n\nExisten paquetes que ofrecen temas adicionales como, por ejemplo, ggthemes.\n\n# Instalación de ggthemes\ninstall.packages(\"ggthemes\")\n\n\n# Carga de ggthemes\nlibrary(ggthemes)\n\n\n# Gráfico de dispersión de cilindrada vs millas por galón en autopista\n# coloreado por tipo de tracción con título, subtítulo, etiquetas y tema de ggthemes\nmpg |>\n  ggplot(aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  geom_smooth() +\n  ggtitle(\"Cilindrada vs rendimiento en autopista\") +\n  xlab(\"Cilindrada (l)\") +\n  ylab(\"Rendimiento en autopista (mpg)\") +\n  labs(subtitle = \"Datos de 38 modelos de automóviles de años entre 1999 y 2008\", \n       caption = \"Fuente: United States Environmental Protection Agency (EPA)\",\n       color = \"Tipo de tracción\") +\n  theme_economist() # tema de ggthemes\n\n\n\n\nOtro paquete de temas y recursos relacionados (escalas de colores, fuentes, etc.) es hrbrthemes.\n\n# Instalación de hbrthemes\ninstall.packages(\"hrbrthemes\")\n\n\n# Carga de hbrthemes\nlibrary(hrbrthemes)\n\n\n# Gráfico de dispersión de cilindrada vs millas por galón en autopista\n# coloreado por tipo de tracción con título, subtítulo, etiquetas y tema de hbrthemes\nmpg |>\n  ggplot(aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  geom_smooth() +\n  ggtitle(\"Cilindrada vs rendimiento en autopista\") +\n  xlab(\"Cilindrada (l)\") +\n  ylab(\"Rendimiento en autopista (mpg)\") +\n  labs(subtitle = \"Datos de 38 modelos de automóviles de años entre 1999 y 2008\", \n       caption = \"Fuente: United States Environmental Protection Agency (EPA)\",\n       color = \"Tipo de tracción\") +\n  theme_ipsum() # tema de hrbrthemes\n\n\n\n\n\n\n9.5.1.6.2 Colores\nggplot2 incluye múltiples funciones para escalas de colores, entre las que pueden mencionarse:\n\nscale_color_brewer(): para escalas de colores secuenciales, divergentes y cualitativas de ColorBrewer.\nscale_color_viridis_d(): para escalas viridis, diseñadas para mejorar la legibilidad de gráficos para lectores con formas comunes de daltonismo y discapacidades relacionadas con la percepción de colores.\nscale_color_manual(): para especificar directamente los colores a utilizar.\n\nEl siguiente bloque de código genera un gráfico de dispersión para los datos de diamonds. Muestra el peso en quilates (carat) de los diamantes en el eje X y su precio (price) en el eje Y. La variable correspondiente a su claridad (clarity) se muestra mediante el color de los puntos, de acuerdo con una escala de ColorBrewer.\n\n# Gráfico de dispersión de peso vs precio de diamantes\n# coloreado por claridad\ndiamonds |>\n  ggplot(aes(x = carat, y = price, color = clarity)) +\n  geom_point() +\n  ggtitle(\"Peso vs precio de diamantes\") +\n  xlab(\"Peso (quilates)\") +\n  ylab(\"Precio ($ EE.UU.)\") +\n  labs(color = \"Claridad\\n(I1=peor IF=mejor)\") +\n  scale_colour_brewer(palette = \"YlOrBr\", direction = -1) +\n  theme_ipsum() # tema de hrbrthemes\n\n\n\n\nPara más información sobre etiquetas, estilos, colores y otros temas relacionados en ggplot2, se recomienda leer ggplot2: Elegant Graphics for Data Analysis - Themes.\n\n\n\n9.5.1.7 Opciones avanzadas\nEn las secciones y ejemplos anteriores, se han estudiado las opciones básicas para crear un gráfico en ggplot2: datos, mapeos de variables a propiedades visuales y capas. También se mostró la forma de implementar facets, como un mecanismo para visualizar variables adicionales y algunos recursos para mejorar la apariencia de los gráficos.\nggplot2 incluye otras opciones para la creación de gráficos, como transformaciones estadísticas, transformaciones de sistemas de coordenadas y posicionamiento de las geometrías, las cuales pueden esquematizarse de la siguiente forma:\nggplot(data = <DATOS>) + \n  <FUNCION_GEOMETRIA>(\n    mapping = aes(<MAPEOS>),\n    stat = <ESTADISTICA>,\n    position = <POSICION>\n  ) +\n  <FUNCION_COORDENADAS> +\n  <FUNCION_FACET>\nEn las secciones siguientes, se explicarán y ejemplificarán alguna de estas opciones.\n\n\n\n9.5.2 plotly\nplotly R es una biblioteca para gráficos interactivos que forma parte del grupo de bibliotecas de graficación de Plotly, el cual también incluye bibliotecas para otros lenguajes como Python, Julia, F# y MATLAB. Plotly fue originalmente escrita en JavaScript, por lo que es particularmente adecuada para gráficos interactivos en la Web.\nplotly implementa la función ggplotly(), la cual convierte graficos de ggplot2 a plotly, haciéndolos interactivos.\nEl siguiente bloque de código muestra un gráfico generado con ggplot2 y convertido a plotly con la función ggplotly().\n\n# Gráfico ggplot2\ngrafico_ggplot2 <-\n  mpg |>\n  ggplot(aes(x = displ, y = hwy, color = drv)) +\n  geom_point(aes(\n    text = paste0( # se especifican los datos que se muestran al pasar el ratón\n      \"Cilindrada: \",\n      displ,\n      \"\\n\",\n      \"Rendimiento en autopista: \",\n      hwy,\n      \"\\n\",\n      \"Tipo de tracción: \",\n      drv\n    )\n  )) +\n  geom_smooth() +\n  ggtitle(\"Cilindrada vs rendimiento en autopista\") +\n  xlab(\"Cilindrada (l)\") +\n  ylab(\"Rendimiento en autopista (mpg)\") +\n  labs(subtitle = \"Datos de 38 modelos de automóviles de años entre 1999 y 2008\",\n       caption = \"Fuente: United States Environmental Protection Agency (EPA)\",\n       color = \"Tipo de tracción\") +\n  theme_ipsum()\n\n# Gráfico plotly\nggplotly(grafico_ggplot2, tooltip = \"text\") |> \n  config(locale = 'es') # para mostrar los controles en español"
  },
  {
    "objectID": "09-ggplot2-plotly.html#tipos-de-gráficos",
    "href": "09-ggplot2-plotly.html#tipos-de-gráficos",
    "title": "9  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "9.6 Tipos de gráficos",
    "text": "9.6 Tipos de gráficos\nEn esta sección, se ejemplifican varios tipos de gráficos, los cuales se construyen con ggplot2 y luego se convierten a plotly.\n\n9.6.1 Histogramas\nUn histograma es una representación gráfica de la distribución de una variable numérica en forma de barras (llamadas en inglés bins). La longitud de cada barra representa la frecuencia de un rango de valores de la variable. La graficación de la distribución de las variables es, frecuentemente, una de las primeras tareas que se realiza cuando se explora un conjunto de datos.\nEn ggplot2, los histogramas se implementan con la función geom_histogram().\nEl siguiente bloque de código muestra, mediante un histograma, la distribución del producto interno bruto (PIB) per cápita para el año 2007, entre los países incluídos en gapminder.\n\n# Histograma ggplot2 de distribución del PIB per cápita en 2007\nhistograma_ggplot2 <-\ngapminder |>\n  filter(year == 2007) |>\n  ggplot(aes(x = gdpPercap)) +\n  geom_histogram(bins = 10) + # cantidad de bins\n  ggtitle(\"Distribución del PIB per cápita en 2007\") +\n  xlab(\"PIB per cápita ($ EE.UU.)\") +\n  ylab(\"Frecuencia\") +\n  labs(subtitle = \"Datos de 14o países\", caption = \"Fuente: Gapminder.org\") +\n  theme_economist()\n\n# Histograma plotly\nggplotly(histograma_ggplot2) |> \n  config(locale = 'es')\n\nWarning: The following aesthetics were dropped during statistical transformation:\nx_plotlyDomain\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\n\n\n\n\n\n\nLa función geom_density() permite crear una estimación de densidad del kernel (Kernel Density Estimation o KDE), una curva que muestra la densidad de los datos.\n\n# Histograma ggplot2 de distribución del PIB per cápita en 2007\nhistograma_ggplot2 <-\n  gapminder |>\n  filter(year == 2007) |>\n  ggplot(aes(x = gdpPercap)) +\n  geom_histogram(aes(y = ..density..), # argumento necesario para crear la curva KDE\n                 bins = 10) + # cantidad de bins\n  geom_density() +\n  ggtitle(\"Distribución del PIB per cápita en 2007\") +\n  xlab(\"PIB per cápita ($ EE.UU.)\") +\n  ylab(\"Frecuencia\") +\n  labs(subtitle = \"Datos de 140 países\", caption = \"Fuente: Gapminder.org\") +\n  theme_economist()\n\n# Histograma plotly\nggplotly(histograma_ggplot2) |>\n  config(locale = 'es')\n\nWarning: The dot-dot notation (`..density..`) was deprecated in ggplot2 3.4.0.\nℹ Please use `after_stat(density)` instead.\nℹ The deprecated feature was likely used in the ggplot2 package.\n  Please report the issue at <\u001b]8;;https://github.com/tidyverse/ggplot2/issues\u0007https://github.com/tidyverse/ggplot2/issues\u001b]8;;\u0007>.\n\n\nWarning: The following aesthetics were dropped during statistical transformation:\nx_plotlyDomain\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\nThe following aesthetics were dropped during statistical transformation:\nx_plotlyDomain\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\n\n\n\n\n\n\nEn el siguiente bloque, se incluye en el gráfico anterior la variable continent a través de la propiedad visual relleno (fill).\n\n# Histograma ggplot2 de distribución del PIB per cápita en 2007 por continente\nhistograma_ggplot2 <-\n  gapminder |>\n  filter(year == 2007) |>\n  ggplot(aes(x = gdpPercap, fill = continent)) +\n  geom_histogram(bins = 10) + # cantidad de bins\n  ggtitle(\"Distribución del PIB per cápita en 2007 por continente\") +\n  xlab(\"PIB per cápita ($ EE.UU.)\") +\n  ylab(\"Frecuencia\") +\n  labs(subtitle = \"Datos de 140 países\",\n       caption = \"Fuente: Gapminder.org\",\n       fill = \"Continente\") +\n  theme_economist()\n\n# Histograma plotly\nggplotly(histograma_ggplot2) |>\n  config(locale = 'es')\n\nWarning: The following aesthetics were dropped during statistical transformation:\nx_plotlyDomain\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\n\n\n\n\n\n\nEl gráfico anterior muestra como el PIB per cápita varía considerablemente entre continentes. La misma información puede mostrarse mediante facets.\n\n# Histogramas ggplot2 de distribución del PIB per cápita en 2007 por continente\nhistograma_ggplot2 <-\n  gapminder |>\n  filter(year == 2007) |>\n  ggplot(aes(x = gdpPercap)) +\n  geom_histogram(bins = 10) + # cantidad de bins\n  ggtitle(\"Distribución del PIB per cápita en 2007 por continente\") +\n  xlab(\"PIB per cápita ($ EE.UU.)\") +\n  ylab(\"Frecuencia\") +\n  labs(subtitle = \"Datos de 140 países\",\n       caption = \"Fuente: Gapminder.org\",\n       fill = \"Continente\") +\n  facet_wrap(~ continent, nrow = 2) +\n  theme_economist()\n\n# Histograma plotly\nggplotly(histograma_ggplot2) |>\n  config(locale = 'es')\n\nWarning: The following aesthetics were dropped during statistical transformation:\nx_plotlyDomain\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\nThe following aesthetics were dropped during statistical transformation:\nx_plotlyDomain\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\nThe following aesthetics were dropped during statistical transformation:\nx_plotlyDomain\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\nThe following aesthetics were dropped during statistical transformation:\nx_plotlyDomain\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\nThe following aesthetics were dropped during statistical transformation:\nx_plotlyDomain\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\n\n\n\n\n\n\n\n\n9.6.2 Gráficos de caja\nUn gráfico de caja (boxplot) muestra información de una variable numérica a través de su mediana, sus cuartiles (Q1, Q2 y Q3) y sus valores atípicos.\nLa figura Figure 9.1 muestra los componentes de un gráfico de caja.\n\n\n\n\n\nFigure 9.1: Componentes de un diagrama de caja. Imagen de Onkel Dagobert.\n\n\n\n\nEn ggplot2, los gráficos de caja se implementan con la función geom_boxplot().\nEl siguiente bloque de código muestra, mediante un gráfico de caja, la distribución del PIB per cápita para el año 2007, entre los países incluídos en gapminder.\n\n# Gráfico de caja ggplot2 de distribución del PIB per cápita en 2007\ngrafico_caja_ggplot2 <-\ngapminder |>\n  filter(year == 2007) |>\n  ggplot(aes(y = gdpPercap)) +\n  geom_boxplot() +\n  ggtitle(\"Distribución del PIB per cápita en 2007\") +\n  ylab(\"PIB per cápita ($ EE.UU.)\") +\n  labs(subtitle = \"Datos de 140 países\", caption = \"Fuente: Gapminder.org\") +\n  theme_economist()\n\n# Gráfico de caja plotly\nggplotly(grafico_caja_ggplot2) |> \n  config(locale = 'es')\n\nWarning: The following aesthetics were dropped during statistical transformation:\ny_plotlyDomain\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\n\n\n\n\n\n\nEn el siguiente bloque, se utiliza la posición en el eje X para mostrar la variable continent y apreciar la distribución del PIB per cápita en cada continente.\n\n# Gráfico de caja ggplot2 de distribución del PIB per cápita en 2007 por continente\ngrafico_caja_ggplot2 <-\ngapminder |>\n  filter(year == 2007) |>\n  ggplot(aes(x = continent, y = gdpPercap)) +\n  geom_boxplot() +\n  ggtitle(\"Distribución del PIB per cápita en 2007 por continente\") +\n  ylab(\"PIB per cápita ($ EE.UU.)\") +\n  labs(subtitle = \"Datos de 140 países\", caption = \"Fuente: Gapminder.org\") +\n  theme_economist()\n\n# Gráfico de caja plotly\nggplotly(grafico_caja_ggplot2) |> \n  config(locale = 'es')\n\nWarning: The following aesthetics were dropped during statistical transformation:\ny_plotlyDomain\nℹ This can happen when ggplot fails to infer the correct grouping structure in\n  the data.\nℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n  variable into a factor?\n\n\n\n\n\n\n\n\n9.6.3 Gráficos de barras\nUn gráfico de barras se compone de barras rectangulares con longitud proporcional a estadísticas (ej. frecuencias, promedios, mínimos, máximos) asociadas a una variable categórica o discreta. Las barras pueden ser horizontales o verticales y se recomienda que estén ordenadas según su longitud, a menos que exista un orden inherente a la variable (ej. el orden de los días de la semana). Es uno de los tipos de gráficos estadísticos más antiguos y comunes y tiene la ventaja de ser muy fácil de comprender.\nEn ggplot2, los histogramas se implementan con las funciones geom_bar(), que se utiliza en gráficos que requieren transformaciones estadísticas, y geom_col(), para gráficos que no requieren estas transformaciones.\n\n9.6.3.1 Barras con transformaciones estadísticas\nLos gráficos de barras y otros tipos de gráficos (ej. histogramas, gráficos de caja, líneas de ajuste) pueden requerir de alguna transformación estadística antes de presentar la información. Esta transformación estadística puede ser un conteo, el cálculo de un promedio, un mínimo o un máximo, entre otras opciones.\nPor ejemplo, el siguiente gráfico muestra la cantidad de países por continente presentes en el conjunto de datos gapminder para el año 2007. Nótese que este conteo no está presente en ninguna de las variables del conjunto de datos.\n\n# Gráfico de barras con conteo de países por continente para el año 2007\ngrafico_barras_ggplot2 <-\ngapminder |>\n  filter(year == 2007) |>\n  ggplot(aes(x = continent)) +\n  geom_bar() +\n  ggtitle(\"Cantidad de países por continente\") +\n  xlab(\"Continente\") +\n  ylab(\"Cantidad\") +\n  labs(caption = \"Fuente: Gapminder.org\") +\n  theme_economist()\n\n# Gráfico de barras plotly\nggplotly(grafico_barras_ggplot2) |> \n  config(locale = 'es')\n\n\n\n\n\nPara ordenar las barras de acuerdo con el conteo, puede utilizarse la función fct_infreq() del paquete forcats de Tidyerse, para manejo de factores. Tenga en cuenta que la columna continent está definida como un factor.\n\n# Gráfico de barras con conteo de países por continente para el año 2007\ngrafico_barras_ggplot2 <-\ngapminder |>\n  filter(year == 2007) |>\n  ggplot(aes(x = fct_infreq(continent))) +\n  geom_bar() +\n  ggtitle(\"Cantidad de países por continente\") +\n  xlab(\"Continente\") +\n  ylab(\"Cantidad\") +\n  labs(caption = \"Fuente: Gapminder.org\") +\n  theme_economist()\n\n# Gráfico de barras plotly\nggplotly(grafico_barras_ggplot2) |> \n  config(locale = 'es')\n\n\n\n\n\nSi se prefiere el orden inverso, puede utilizarse la función fct_rev() (ej. fct_rev(fct_infreq(continent))).\nEn un ejemplo similar, se cuenta la cantidad de diamantes por tipo de corte (cut), para el conjunto de datos diamonds.\n\n# Gráfico de barras con conteo de diamantes por corte\ngrafico_barras_ggplot2 <-\ndiamonds |>\n  ggplot(aes(x = fct_rev(cut))) +\n  geom_bar() +\n  ggtitle(\"Cantidad de diamantes por corte\") +\n  xlab(\"Corte\") +\n  ylab(\"Cantidad\") +\n  theme_economist()\n\n# Gráfico de barras plotly\nggplotly(grafico_barras_ggplot2) |> \n  config(locale = 'es')\n\n\n\n\n\nEl cálculo de la cantidad de países por continente o el de la cantidad de diamantes por corte, son ejemplos de transformaciones estadísticas. La Figure 9.2 muestra como se realiza este proceso para el gráfico anterior.\n\n\n\n\n\nFigure 9.2: Transformación estadística para un gráfico de barras de ggplot2. Imagen de Hadley Wickham.\n\n\n\n\nLas barras pueden mostrar otras transformaciones estadísticas a través del uso de los argumentos stat y fun.y de geom_bar(). Por ejemplo, stat = \"summary\" y fun.y = \"mean\"generan un gráfico que muestra el promedio de esperanza de vida (lifeExp) para cada continente para el año 2007.\n\n# Gráfico de barras con promedio de esperanza de vida\n# para cada continente para el año 2007\ngrafico_barras_ggplot2 <-\n  gapminder |>\n  filter(year == 2007) |>\n  ggplot(aes(x = fct_infreq(continent), y = lifeExp)) +\n  geom_bar(stat = \"summary\", fun.y = \"mean\") +\n  ggtitle(\"Promedio de esperanza de vida por continente en 2007\") +\n  xlab(\"Continente\") +\n  ylab(\"Promedio\") +\n  labs(caption = \"Fuente: Gapminder.org\") +\n  theme_economist()\n\n# Gráfico de barras plotly\nggplotly(grafico_barras_ggplot2) |>\n  config(locale = 'es')\n\n\n\n\n\nNota:  la función fct_infreq() no está ordenando en este caso las columnas (se desconoce la razón). El ordenamiento aún puede conseguirse si se realiza primero el cálculo del promedio y luego se grafica la columna correspondiete, como en el siguiente bloque de código.\n\n# Cálculo del promedio de esperanza de vida por continente\ngapminder_mean_lifeExp_continent <-\n  gapminder |>\n  filter(year == 2007) |>\n  group_by(continent) |>\n  summarize(lifeExp_mean = mean(lifeExp))\n\n# Despliegue por orden descendente del promedio de esperanza de vida\ngapminder_mean_lifeExp_continent |>\n  arrange(desc(lifeExp_mean))\n\n# A tibble: 5 × 2\n  continent lifeExp_mean\n  <fct>            <dbl>\n1 Oceania           80.7\n2 Europe            77.6\n3 Americas          73.6\n4 Asia              70.7\n5 Africa            54.8\n\n\nLuego se dibuja luego el gráfico con geom_col() y se ordenan las barras con reorder().\n\n# Gráfico de barras con promedio de esperanza de vida\n# para cada continente para el año 2007\ngrafico_barras_ggplot2 <-\n  gapminder_mean_lifeExp_continent |>\n  ggplot(aes(x = reorder(continent,-lifeExp_mean), y = lifeExp_mean)) +\n  geom_col(aes(\n    text = paste0(\n      \"Continente: \",\n      continent,\n      \"\\n\",\n      \"Promedio de esperanza de vida: \",\n      lifeExp_mean\n    )\n  )) +\n  ggtitle(\"Promedio de esperanza de vida por continente en 2007\") +\n  xlab(\"Continente\") +\n  ylab(\"Promedio\") +\n  labs(caption = \"Fuente: Gapminder.org\") +\n  theme_economist()\n\n# Gráfico de barras plotly\nggplotly(grafico_barras_ggplot2, tooltip = \"text\") |>\n  config(locale = 'es')\n\n\n\n\n\nEl uso de geom_col() se ampliará en la sección siguiente.\n\n\n9.6.3.2 Barras sin transformaciones estadísticas\nEn algunos conjuntos de datos, el valor que se quiere representar en la longitud de las barras ya está presente como una variable en el conjunto de datos, por lo que no es necesario que ggplot2 realice una transformación estadística. En estos casos, se utiliza la función geom_col().\nNota:  para dibujar barras sin transformaciones estadísticas, tambien es posible utilizar la función geom_bar(). En este caso, al argumento stat se le asigna el valor \"identity\" y al argumento y de aes() la variable que contiene el valor que quiere mostrarse en las barras.\nEl siguiente gráfico de barras muestra la población de los países de los países de América en 2007. Nótese que este valor se puede tomar directamente de la variable pop, después de realizar los filtros correspondientes.\n\n# Gráfico de barras con población de países \n# de América para el año 2007\ngrafico_barras_ggplot2 <-\ngapminder |>\n  filter(year == 2007 & continent == \"Americas\") |>\n  ggplot(aes(x = reorder(country, pop), y = pop/1000000)) +\n  geom_col(aes(text = paste0(\n      \"País: \",\n      country,\n      \"\\n\",\n      \"Población (millones de habitantes): \",\n      pop/1000000\n    ))) +\n  coord_flip() + # para mostrar barras horizontales\n  ggtitle(\"Población de países de América en 2007\") +\n  xlab(\"País\") +\n  ylab(\"Población (millones de habitantes)\") +\n  labs(caption = \"Fuente: Gapminder.org\") +\n  theme_economist()\n\n# Gráfico de barras plotly\nggplotly(grafico_barras_ggplot2, tooltip = \"text\") |> \n  config(locale = 'es')\n\n\n\n\n\n\n\n9.6.3.3 Barras apiladas\nAl usar el argumento fill de aes(), las barras de un gráfico pueden dividirse de acuerdo con una variable adicional, produciendo el efecto de barras apiladas (i.e. unas sobre otras).\nEn el siguiente bloque de código, se genera un gráfico de barras apiladas que, para el conjunto de datos diamonds, muestra las cantidades de diamantes por corte (cut) subdivididas por claridad (clarity).\n\n# Gráfico de barras apiladas por tipo de corte y claridad \ngrafico_barras_ggplot2 <-\ndiamonds |>\n  ggplot(aes(x = cut, fill = clarity)) +\n  geom_bar() +\n  ggtitle(\"Cantidad de diamantes por corte y claridad\") +\n  xlab(\"Corte\") +\n  ylab(\"Cantidad\") +\n  labs(fill = \"Claridad\") +\n  theme_minimal()\n\n# Gráfico de barras plotly\nggplotly(grafico_barras_ggplot2) |> \n  config(locale = 'es')\n\n\n\n\n\nEl argumento position = \"fill\" de geom_bar() también genera barras apiladas, pero le asigna a todas las barras la misma longitud, facilitando así la comparación de proporciones.\n\n# Gráfico de barras apiladas por tipo de corte y claridad \ngrafico_barras_ggplot2 <-\ndiamonds |>\n  ggplot(aes(x = cut, fill = clarity)) +\n  geom_bar(position = \"fill\") +\n  ggtitle(\"Proporción de tipos de claridad en cortes de diamantes\") +\n  xlab(\"Corte\") +\n  ylab(\"Proporción\") +\n  labs(fill = \"Claridad\") +\n  theme_minimal()\n\n# Gráfico de barras plotly\nggplotly(grafico_barras_ggplot2) |> \n  config(locale = 'es')\n\n\n\n\n\n\n\n9.6.3.4 Barras agrupadas\nEl argumento position = \"dodge\" de geom_bar() genera barras agrupadas (i.e. unas al lado de otras), facilitando así la comparación de valores individuales.\n\n# Gráfico de barras agrupadas por tipo de corte y claridad \ngrafico_barras_ggplot2 <-\ndiamonds |>\n  ggplot(aes(x = cut, fill = clarity)) +\n  geom_bar(position = \"dodge\") +\n  ggtitle(\"Cantidad de diamantes por corte y claridad\") +\n  xlab(\"Corte\") +\n  ylab(\"Cantidad\") +\n  labs(fill = \"Claridad\") +\n  theme_minimal()\n\n# Gráfico de barras plotly\nggplotly(grafico_barras_ggplot2) |> \n  config(locale = 'es')\n\n\n\n\n\n\n\n\n9.6.4 Gráficos de dispersión\nUn gráfico de dispersión (scatterplot) despliega los valores de dos variables numéricas, como puntos en un sistema de coordenadas. El valor de una variable se despliega en el eje X y el de la otra variable en el eje Y. Variables adicionales pueden ser mostradas mediante atributos de los puntos, tales como su tamaño, color o forma.\nEn ggplot2, los gráficos de dispersión se implementan con la función de geometría geom_point().\nEl siguiente bloque de código muestra la relación entre el PIB per cápita y la esperanza de vida de los países en el conjunto de datos gapminder, para el año 2007.\n\n# Gráfico de dispersión PIB per cápita vs esperanza de vida en 2007\n# + línea de tendencia\ngrafico_dispersion_ggplot2 <-\n  gapminder |>\n  filter(year == 2007) |>\n  ggplot(aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(aes(\n    text = paste0(\n      \"País: \",\n      country,\n      \"\\n\",\n      \"PIB per cápita: \",\n      gdpPercap,\n      \"\\n\",\n      \"Esperanza de vida: \",\n      lifeExp\n    )\n  )) +\n  geom_smooth(method = \"lm\") +\n  ggtitle(\"PIB per cápita vs esperanza de vida en 2007\") +\n  xlab(\"PIB per cápita ($ EE.UU.)\") +\n  ylab(\"Esperanza de vida (años)\") +\n  labs(caption = \"Fuente: Gapminder.org\") +\n  theme_economist()  \n\n# Gráfico de dispersión plotly\nggplotly(grafico_dispersion_ggplot2, tooltip = \"text\") |>\n  config(locale = 'es')\n\n\n\n\n\nComo se explicó anteriormente, se pueden agregar al gráfico variables adicionales mediante su mapeo a propiedades visuales. En el siguiente ejemplo, se agrega la variable de continente al gráfico anterior, mediante su mapeo a la propiedad correspondiente al color.\n\n# Gráfico de dispersión PIB per cápita vs esperanza de vida por continente en 2007\ngrafico_dispersion_ggplot2 <-\n  gapminder |>\n  filter(year == 2007) |>\n  ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point(aes(\n    text = paste0(\n      \"País: \",\n      country,\n      \"\\n\",\n      \"Continente: \",\n      continent,\n      \"\\n\",\n      \"PIB per cápita: \",\n      gdpPercap,\n      \"\\n\",\n      \"Esperanza de vida: \",\n      lifeExp\n    )\n  )) +\n  ggtitle(\"PIB per cápita vs esperanza de vida por continente en 2007\") +\n  xlab(\"PIB per cápita ($ EE.UU.)\") +\n  ylab(\"Esperanza de vida (años)\") +\n  labs(caption = \"Fuente: Gapminder.org\", color = \"Continente\") +\n  theme_economist()  \n\n# Gráfico de dispersión plotly\nggplotly(grafico_dispersion_ggplot2, tooltip = \"text\") |>\n  config(locale = 'es')\n\n\n\n\n\n\n\n9.6.5 Gráficos de líneas\nUn gráfico de líneas muestra información en la forma de puntos de datos, llamados marcadores (markers), conectados por segmentos de líneas rectas. Es similar a un gráfico de dispersión pero, además del uso de segmentos de línea, tiene la particularidad de que los datos están ordenados, usualmente con respecto al eje X. Los gráficos de línea son usados frecuentemente para mostrar tendencias a través del tiempo.\nEn ggplot2, los gráficos de líneas se implementan con la función de geometría geom_line().\nEl siguiente gráfico de línea muestran la evolución en el tiempo de los casos positivos, fallecidos, recuperados y activos de COVID-19 en Costa Rica.\n\n# Gráfico de líneas con la evolución de los casos de COVID\ngrafico_lineas_ggplot2 <-\n  covid_general |>\n  ggplot(aes(x = fecha, y = value, color = variable)) +\n  geom_line(aes(y = positivos, color = \"Positivos\")) +\n  geom_line(aes(y = recuperados, color = \"Recuperados\")) +\n  geom_line(aes(y = activos, color = \"Activos\")) +\n  geom_line(aes(y = fallecidos, color = \"Fallecidos\")) +\n  scale_color_manual( # colores\n    \"\",\n    values = c(\n      \"Positivos\" = \"blue\",\n      \"Recuperados\" = \"green\",\n      \"Activos\" = \"red\",\n      \"Fallecidos\" = \"black\"\n    )\n  ) +\n  ggtitle(\"Casos acumulados de COVID en Costa Rica al 2022-05-30\") +\n  xlab(\"Fecha\") +\n  ylab(\"Casos\") +\n  theme_economist()  \n\n# Gráfico de dispersión plotly\nggplotly(grafico_lineas_ggplot2) |>\n  config(locale = 'es')\n\n\n\n\n\n\n\n9.6.6 Otros tipos de gráficos\nggplot2 provee más de 40 tipos de geometrías para gráficos (puntos, líneas, barras, histogramas, cajas, etc.) y los paquetes de extensión proporcionan aún más (ej. https://exts.ggplot2.tidyverse.org/gallery/).\nPara una explicación resumida de ggplot2, se recomienda leer Data visualization with ggplot2::Cheat Sheet."
  },
  {
    "objectID": "09-ggplot2-plotly.html#recursos-de-interés",
    "href": "09-ggplot2-plotly.html#recursos-de-interés",
    "title": "9  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "9.7 Recursos de interés",
    "text": "9.7 Recursos de interés\nDT: An R interface to the DataTables library. (s. f.). Recuperado 21 de mayo de 2022, de https://rstudio.github.io/DT/\nHealy, Y. H. and C. (s. f.). From data to Viz | Find the graphic you need. Recuperado 20 de marzo de 2022, de https://www.data-to-viz.com/\nRStudio. (2017). Data visualization with ggplot2::Cheat Sheet. https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-visualization.pdf\nWickham, H. (2010). A Layered Grammar of Graphics. Journal of Computational and Graphical Statistics, 19(1), 3-28. https://doi.org/10.1198/jcgs.2009.07098"
  },
  {
    "objectID": "10-introduccion-manejo-datos-geoespaciales.html",
    "href": "10-introduccion-manejo-datos-geoespaciales.html",
    "title": "10  Introducción al manejo de datos geoespaciales en R",
    "section": "",
    "text": "Lovelace, R., Nowosad, J., & Münchow, J. (2019). Geocomputation with R (capítulos 1 y 2). CRC Press. https://geocompr.robinlovelace.net/"
  },
  {
    "objectID": "10-introduccion-manejo-datos-geoespaciales.html#resumen",
    "href": "10-introduccion-manejo-datos-geoespaciales.html#resumen",
    "title": "10  Introducción al manejo de datos geoespaciales en R",
    "section": "10.2 Resumen",
    "text": "10.2 Resumen\nEl lenguaje de programación R cuenta con varios paquetes para manejo de datos geoespaciales, entre los que están el paquete sf para datos vectoriales, el paquete terra para datos raster y el paquete leaflet para mapas en la Web."
  },
  {
    "objectID": "10-introduccion-manejo-datos-geoespaciales.html#introducción",
    "href": "10-introduccion-manejo-datos-geoespaciales.html#introducción",
    "title": "10  Introducción al manejo de datos geoespaciales en R",
    "section": "10.3 Introducción",
    "text": "10.3 Introducción\nLa comunidad de programadores de R ha desarrollado un conjunto de paquetes para el manejo de datos geoespaciales, tanto en formatos vectoriales como raster. Algunos de los principales de estos paquetes son:\n\nEl paquete sf. Ofrece un conjunto de funciones para el manejo de datos vectoriales, de acuerdo con el estándar Simple Features.\nEl paquete terra. Implementa un conjunto de funciones para el manejo de datos raster. Es una reimplementación del paquete raster.\nEl paquete leaflet. Es una implementación en R de la biblioteca Leaflet para el lenguaje JavaScript para la programación de mapas interactivos en páginas web.\n\nAlgunos paquetes de graficación estadística, como ggplot2 y plotly, también cuentan con capacidades para visualización de datos geoespaciales.\nEn CRAN Task View: Analysis of Spatial Data, puede encontrarse un resumen detallado de los paquetes de R con funciones geoespaciales."
  },
  {
    "objectID": "10-introduccion-manejo-datos-geoespaciales.html#datos-vectoriales",
    "href": "10-introduccion-manejo-datos-geoespaciales.html#datos-vectoriales",
    "title": "10  Introducción al manejo de datos geoespaciales en R",
    "section": "10.4 Datos vectoriales",
    "text": "10.4 Datos vectoriales\n\n10.4.1 El modelo vectorial\nEl modelo vectorial de datos está basado en puntos localizados en un sistema de referencia de coordenadas (CRS). Los puntos individuales pueden representar objetos independientes (ej. postes eléctricos, cabinas telefónicas) o pueden también agruparse para formar geometrías más complejas como líneas (ej. ríos, caminos) o polígonos (ej. fincas, países, provincias). Por lo general, los puntos tienen solo dos dimensiones (x, y), a las que se les puede agregar una tercera dimensión z, usualmente correspondiente a la altitud sobre el nivel del mar.\n\n\n10.4.2 El estándar Simple Features\nSimple Features (o Simple Feature Access) es un estándar abierto de la Organización Internacional de Estandarización (ISO) y del Open Geospatial Consortium (OGC) que especifica un modelo común de almacenamiento y acceso para geometrías de dos dimensiones (líneas, polígonos, multilíneas, multipolígonos, etc.). El estándar es implementado por muchas bibliotecas y bases de datos geoespaciales como sf, Fiona, GDAL, PostgreSQL/PostGIS, SQLite/SpatiaLite, Oracle Spatial y Microsoft SQL Server, entre muchas otras.\nLa especificación define 17 tipos de geometrías, de las cuales siete son las más comúnmente utilizadas. Estas últimas se muestran en la Figure 10.1.\n\n\n\n\n\nFigure 10.1: Tipos de geometrías de Simple Features más usadas. Imagen de Robin Lovelace et al..\n\n\n\n\n\n\n10.4.3 El paquete sf\nEl paquete sf (de Simple Features) de R implementa los modelos de datos de las geometrías de tipo vectorial: puntos, líneas, polígonos, sus versiones múltiples y las colecciones de geometrías. Está basado en bibliotecas de sofware ampliamente utilizadas en aplicaciones geoespaciales:\n\nGeospatial Data Abstraction Library (GDAL): es una biblioteca para leer y escribir datos geoespaciales en varios formatos raster y vectoriales. Implementa un único modelo abstracto de datos raster y un único modelo abstracto de datos vectoriales, lo que permite programar aplicaciones geoespaciales sin tener que ocuparse de las particularidades de cada formato que se utilice (GeoTIFF, NetCDF, ESRI Shapefile, GeoJSON, etc.). A pesar de que GDAL está programada en C/C++, cuenta con una interfaz de programación de aplicaciones (API) para varios lenguajes de programación, incluyendo C, C++, Python y Java. Además, ofrece un conjunto de utilitarios de línea de comandos cuyas distribuciones binarias están disponibles para varios sistemas operativos, incluyendo Windows, macOS y Linux.\nGeometry Engine, Open Source (GEOS): es una implementación en C++ de la biblioteca JTS Topology Suite (desarrollada en Java) y que implementa un conjunto de operaciones y predicados geoespaciales (ej. unión, intersección, distancia, área).\nPROJ: es una biblioteca que transforma coordenadas entre diferentes CRS, incluyendo tanto proyecciones cartográficas como transformaciones geodésicas.\n\nsf provee acceso, desde un mismo paquete de R, a la funcionalidad de estas tres bibliotecas, proporcionando así una interfaz unificada para leer y escribir datos geoespaciales mediante GDAL, realizar operaciones con geometrías mediante GEOS y efectuar transformaciones entre sistemas de coordenadas mediante PROJ.\nEn sf, los conjuntos de datos geoespaciales se almacenan en objetos de una clase también llamada sf, los cuales son data frames que contiene una columna especial para las geometrías. Esta columna se denomina generalmente geom o geometry (aunque pueden tener cualquier otro nombre). El manejo de datos geoespaciales como data frames permite manipularlos con las funciones ya desarrolladas para este tipo de datos y con la misma forma de referenciar las filas (observaciones) y las columnas (variables).\n\n10.4.3.1 Instalación y carga\n\n# Instalación de sf\ninstall.packages(\"sf\")\n\n\n# Carga de sf\nlibrary(sf)\n\n\n\n10.4.3.2 Métodos\nLa lista de métodos (i.e. funciones) de la clase sf puede obtenerse a través de la función methods():\n\n# Métodos de la clase sf\nmethods(class = \"sf\")\n\n [1] [                     [[<-                  $<-                  \n [4] aggregate             as.data.frame         cbind                \n [7] coerce                dbDataType            dbWriteTable         \n[10] filter                identify              initialize           \n[13] merge                 plot                  print                \n[16] rbind                 show                  slotsFromS3          \n[19] st_agr                st_agr<-              st_area              \n[22] st_as_s2              st_as_sf              st_as_sfc            \n[25] st_bbox               st_boundary           st_buffer            \n[28] st_cast               st_centroid           st_collection_extract\n[31] st_convex_hull        st_coordinates        st_crop              \n[34] st_crs                st_crs<-              st_difference        \n[37] st_filter             st_geometry           st_geometry<-        \n[40] st_inscribed_circle   st_interpolate_aw     st_intersection      \n[43] st_intersects         st_is_valid           st_is                \n[46] st_join               st_line_merge         st_m_range           \n[49] st_make_valid         st_nearest_points     st_node              \n[52] st_normalize          st_point_on_surface   st_polygonize        \n[55] st_precision          st_reverse            st_sample            \n[58] st_segmentize         st_set_precision      st_shift_longitude   \n[61] st_simplify           st_snap               st_sym_difference    \n[64] st_transform          st_triangulate        st_union             \n[67] st_voronoi            st_wrap_dateline      st_write             \n[70] st_z_range            st_zm                 transform            \nsee '?methods' for accessing help and source code\n\n\nSeguidamente, se describen y ejemplifican algunos de los métodos básicos de la clase sf.\n\n10.4.3.2.1 st_read() - lectura de datos\nEl método st_read() lee datos vectoriales de una fuente en formato geoespacial (ej. shapefiles, archivos GeoJSON, bases de datos geoespaciales) y los recupera en un objeto sf.\nEn el siguiente bloque de código en R, se utiliza el método st_read() para leer un archivo GeoJSON con los polígonos de las provincias de Costa Rica. Este archivo proviene de un geoservicio de tipo Web Feature Service (WFS) publicado por el Instituto Geográfico Nacional (IGN).\n\n# Lectura de una capa vectorial (GeoJSON) de provincias de Costa Rica\nprovincias <-\n  st_read(\n    \"datos/ign/delimitacion-territorial-administrativa/provincias.geojson\",\n    quiet = TRUE # para evitar el despliegue de mensajes\n  )\n\nst_read() también puede crear objetos sf a partir de archivos de texto. Esta variante se utiliza principalmente cuando el archivo contiene coordenadas correspondientes a geometrías de puntos.\nEn el siguiente bloque de código, se utiliza st_read() para leer un archivo CSV con registros de presencia de felinos de Costa Rica, el cual contiene dos columnas llamadas decimalLongitude y decimalLatitude correspondientes a la longitud decimal y latitud decimal en las que fue observado cada felino. Este archivo proviene de una consulta al portal de datos de la Infraestructura Mundial de Información en Biodiversidad (GBIF).\n\n# Lectura de un archivo CSV con registros de presencia de felinos en Costa Rica\nfelinos <-\n  st_read(\n    \"datos/gbif/felinos.csv\",\n    options = c(\n      \"X_POSSIBLE_NAMES=decimalLongitude\", # columna de longitud decimal\n      \"Y_POSSIBLE_NAMES=decimalLatitude\"   # columna de latitud decimal\n    ),\n    quiet = TRUE\n  )\n\nTanto provincias como felinos son objetos de la clase sf (y además de data.frame).\n\n# Clase del objeto provincias\nclass(provincias)\n\n[1] \"sf\"         \"data.frame\"\n\n# Clase del objeto felinos\nclass(felinos)\n\n[1] \"sf\"         \"data.frame\"\n\n\nAl escribirse el nombre de un objeto sf en la consola de R, se despliega información general sobre este.\n\n# Información general sobre el objeto provincias\nprovincias\n\nSimple feature collection with 7 features and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 156152 ymin: 608833.8 xmax: 658879.5 ymax: 1241118\nProjected CRS: CR05 / CRTM05\n  cod_catalo cod_provin  provincia\n1     160103          6 Puntarenas\n2     160103          1   San José\n3     160103          7      Limón\n4     160103          3    Cartago\n5     160103          2   Alajuela\n6     160103          5 Guanacaste\n7     160103          4    Heredia\n                                                                                                                                                                                                                 ori_toponi\n1 En documento de 1720, se menciona la llegada del pirata Chipperton a la zona, en el cual aparece la descripcíon referente a una embarcación pequeña en la Punta de Arena, adoptando con el tiempo el nombre de Puntarenas\n2                                                                                                                                              Se remonta a la creación de la ermita dedicada al Patriarca San José en 1737\n3                                                                                         El origen del nombre de la provincia se remonta a 1852, cuando por primera vez se cita en un documento oficial el puerto de Limón\n4                                         Don Juan Vázques de Coronado escogió el sitio en el valle del Guarco para trasladar a la ciudad de Garcimuños, en 1563, bautizando al nuevo asentamiento con el nombre de Cartago\n5                                                                                                                  Se remonta al paraje llamado La Lajuela que por primera vez se cita en los Protocolos de Cartago de 1657\n6        En alegoria a un frondoso árbol de Guanacaste ubicado en la intersección de los caminos que se dirigían a Nicoya, Bagaces y Rivas, en lo que hoy día es el parque de Liberia. Esta referencia data del siglo XVIII\n7                                        En correspondiencia al Presidente  de la Real Audiencia de Guatemala, Capitán General don Alonso Fernández de Heredia, de la Inmaculada Concepción de Cubujuquí a Villa de Heredia\n      area  version                       geometry\n1 11298.51 20201222 MULTIPOLYGON (((159917.7 60...\n2  4969.73 20201222 MULTIPOLYGON (((505765.3 11...\n3  9176.96 20201222 MULTIPOLYGON (((532516.6 12...\n4  3093.23 20201222 MULTIPOLYGON (((556146.1 10...\n5  9772.27 20201222 MULTIPOLYGON (((427195 1224...\n6 10196.32 20201222 MULTIPOLYGON (((380807.3 11...\n7  2663.46 20201222 MULTIPOLYGON (((497345.1 11...\n\n\n\n\n10.4.3.2.2 st_crs() y st_transform() - manejo de sistemas de coordenadas\nEl método st_crs() retorna el CRS de un objeto sf.\n\n# Despliegue del CRS del objeto provincias\nst_crs(provincias)\n\nCoordinate Reference System:\n  User input: CR05 / CRTM05 \n  wkt:\nPROJCRS[\"CR05 / CRTM05\",\n    BASEGEOGCRS[\"CR05\",\n        DATUM[\"Costa Rica 2005\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",5365]],\n    CONVERSION[\"Costa Rica TM 2005\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",-84,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",0.9999,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",500000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping (large and medium scale).\"],\n        AREA[\"Costa Rica - onshore and offshore east of 86°30'W.\"],\n        BBOX[2.21,-86.5,11.77,-81.43]],\n    ID[\"EPSG\",5367]]\n\n# Despliegue CRS del objeto felinos\nst_crs(felinos)\n\nCoordinate Reference System: NA\n\n\nst_crs() también puede asignar un CRS a un objeto sf que no lo tiene.\n\n# Asignación de un CRS al objeto felinos\nst_crs(felinos) <- 4326\n\nEl método st_transform() transforma un objeto sf a un nuevo CRS.\n\n# Transformación del CRS del objeto provincias a WGS84 (EPSG = 4326)\nprovincias <-\n  provincias |>\n  st_transform(4326)\n\n\n\n10.4.3.2.3 plot() - mapeo\nEl método plot() grafica objetos sf en un mapa.\n\n# Mapeo de las geometrías del objeto provincias\nplot(provincias$geometry)\n\n\n\n# Mapeo con argumentos adicionales de plot()\nplot(\n  provincias$geometry,\n  extent = st_bbox(c(xmin = -86.0, xmax = -82.3, ymin = 8.0, ymax = 11.3)),\n  main = \"Provincias de Costa Rica\",\n  axes = TRUE,\n  graticule = TRUE\n)\n\n\n\n\nLos argumentos reset y add de plot() permiten generar un mapa con varias capas.\n\n# Primera capa del mapa\nplot(\n  provincias$geometry,\n  extent = st_bbox(c(xmin = -86.0, xmax = -82.3, ymin = 8.0, ymax = 11.3)),\n  main = \"Registros de presencia de felinos en Costa Rica\",\n  axes = TRUE,\n  graticule = TRUE,\n  reset = FALSE\n)\n\n# Segunda capa\nplot(felinos$geometry,\n     add = TRUE,     \n     pch = 16,\n     col = \"blue\")\n\n\n\n\nPara conocer los valores del argumento pch, puede consultar R plot pch symbols.\n\n\n10.4.3.2.4 st_write() - escritura de datos\nEl método st_write() guarda en el disco un objeto sf en los diferentes formatos vectoriales de GDAL.\n\n# Especificación del directorio de trabajo (debe utilizarse una ruta existente)\nsetwd(\"/home/mfvargas\")\n\n# Escritura del objeto provincias en formato GPKG\nprovincias |>\n  st_write(\"provincias.gpkg\")\n\n# Escritura del objeto felinos en formato KML\nfelinos |>\n  st_write(\"felinos.kml\")\n\n\n\n10.4.3.2.5 Otros\n\n# Cantidad de filas de un objeto sf\nnrow(provincias)\n\n[1] 7\n\n# Cantidad de columnas de un objeto sf\nncol(provincias)\n\n[1] 7\n\n# Resumen de la columna de geometría\nsummary(provincias$geometry)\n\n MULTIPOLYGON     epsg:4326 +proj=long... \n            7             0             0 \n\n\n\n\n\n\n10.4.4 Mapeo de objetos sf con otros paquetes\n\n10.4.4.1 leaflet\nEl paquete leaflet genera mapas interactivos en lenguaje de marcado de hipertexto (HTML), el lenguaje de marcado utilizado para desarrollar páginas web.\n\n10.4.4.1.1 Instalación y carga\n\n# Instalación de leaflet\ninstall.packages(\"leaflet\")\n\n# Instalación de leaflet.extras (funciones adicionales de leaflet)\ninstall.packages(\"leaflet.extras\")\n\n# Instalación de leaflem (funciones adicionales de leaflet)\ninstall.packages(\"leafem\")\n\n\n# Carga de leaflet\nlibrary(leaflet)\n\n# Carga de leaflet.extras\nlibrary(leaflet.extras)\n\n# Carga de leafem\nlibrary(leafem)\n\nEl siguiente bloque de código muestra las capas de provincias (polígonos) y de registros de presencia de felinos (puntos) sobre una capa base de OpenStreetMap (OSM).\n\n# Mapa leaflet básico de provincias y registros de presencia de felinos\nleaflet() |>\n  setView(# centro y nivel inicial de acercamiento\n    lng = -84.19452,\n    lat = 9.572735,\n    zoom = 7) |>\n  addTiles(group = \"OpenStreetMap\") |> # capa base de OSM |>\n  addPolygons(\n    # capa de provincias (polígonos)\n    data = provincias,\n    color = \"black\",\n    fillColor = \"transparent\",\n    stroke = TRUE,\n    weight = 1.0\n  ) |>\n  addCircleMarkers(\n    # capa de registros de presencia (puntos)\n    data = felinos,\n    stroke = F,\n    radius = 4,\n    fillColor = 'blue',\n    fillOpacity = 1,\n    group = \"Felinos\",\n    popup = paste(\n      paste0(\"<strong>Especie: </strong>\", felinos$species),\n      paste0(\"<strong>Localidad: </strong>\", felinos$locality),\n      paste0(\"<strong>Fecha: </strong>\", felinos$eventDate),\n      paste0(\"<strong>Fuente: </strong>\", felinos$institutionCode),\n      paste0(\"<a href='\", felinos$occurrenceID, \"'>Más información</a>\"),\n      sep = '<br/>'\n    )\n  ) |>\n  addLayersControl(\n    baseGroups = c(\"OpenStreetMap\"),\n    overlayGroups = c(\"Felinos\")) |> # control de capas\n  addResetMapButton() |> # botón de reinicio\n  addSearchOSM() |> # búsqueda en OSM\n  addMouseCoordinates() |> # coordenadas del puntero del ratón\n  addScaleBar(position = \"bottomleft\", options = scaleBarOptions(imperial = FALSE)) |> # barra de escala\n  addMiniMap(position = \"bottomleft\") # mapa de ubicación\n\n\n\n\n\n\n\n\n\n10.4.5 Ejercicios\n\nAgregue capas base adicionales al mapa anterior, con la función leaflet::addProviderTiles() (vea Leaflet for R - Using Basemaps).\nAgrupe los puntos correspondientes a los registros de presencia mediante la función markerClusterOptions() (vea Leaflet for R - Markers).\nGenere una capa de calor (heat map) con la función leaflet.extras::addHeatmap()."
  },
  {
    "objectID": "10-introduccion-manejo-datos-geoespaciales.html#datos-raster",
    "href": "10-introduccion-manejo-datos-geoespaciales.html#datos-raster",
    "title": "10  Introducción al manejo de datos geoespaciales en R",
    "section": "10.5 Datos raster",
    "text": "10.5 Datos raster\n\n10.5.1 El modelo raster\nEl modelo de datos raster usualmente consiste de un encabezado y de una matriz con celdas (también llamadas pixeles) de un mismo tamaño. El encabezado define el CRS, la extensión y el punto de origen de una capa raster. Por lo general, el origen se ubica en la esquina inferior izquierda o en la esquina superior izquierda de la matriz. La extensión se define mediante el número de filas, el número de columnas y el tamaño (resolución) de la celda.\nCada celda tiene una identificación (ID) y almacena un único valor, el cual puede ser numérico o categórico, como se muestra en la Figure 10.2.\n\n\n\n\n\nFigure 10.2: El modelo raster: (A) ID de las celdas, (B) valores de las celdas, (C) mapa raster de colores. Imagen de Robin Lovelace et al.\n\n\n\n\nA diferencia del modelo vectorial, el modelo raster no necesita almacenar todas las coordenadas de cada geometría (i.e. las esquinas de las celdas), debido a que la ubicación de cada celda puede calcularse a partir de la información contenida en el encabezado. Esta simplicidad, en conjunto con el álgebra de mapas, permiten que el procesamiento de datos raster sea mucho más eficiente que el procesamiento de datos vectoriales. Por otra parte, el modelo vectorial es mucho más flexible en cuanto a las posibilidades de representación de geometrías y almacenamiento de valores, por medio de múltiples elementos de datos.\nLos mapas raster generalmente almacenan fenómenos continuos como elevación, precipitación, temperatura, densidad de población y datos espectrales. También es posible representar mediante raster datos discretos, tales como tipos de suelo o clases de cobertura de la tierra, como se muestra en la Figure 10.3.\n\n\n\n\n\nFigure 10.3: Ejemplos de mapas raster continuos y categóricos. Imagen de Robin Lovelace et al.\n\n\n\n\n\n\n10.5.2 El paquete terra\nEl paquete terra implementa un conjunto de funciones para la lectura, escritura, manipulación, análisis y modelado de datos raster y vectoriales. Implementa la clase SpatRaster para manejar los objetos raster.\n\n10.5.2.1 Instalación y carga\n\n# Instalación de terra\ninstall.packages(\"terra\")\n\n\n# Carga de terra\nlibrary(terra)\n\n\n\n10.5.2.2 Métodos\nLa función help() presenta la documentación del paquete terra, incluyendo sus métodos.\n\n# Ayuda sobre el paquete terra\nhelp(\"terra-package\")\n\nSeguidamente, se describen y ejemplifican algunos de los métodos básicos para manejo de datos raster del paquete terra.\n\n10.5.2.2.1 rast() - lectura de datos\nEl método rast() lee datos raster.\nEn el siguiente bloque de código en R, se utiliza el método rast()` para leer un archivo GeoTIFF correspondiente a la altitud de Costa Rica. Este archivo proviene de WorldClim, un conjunto de capas climáticas disponibles en varias resoluciones espaciales.\n\n# Lectura de una capa raster de altitud\naltitud <-\n  rast(\n    \"datos/worldclim/altitud.tif\"\n  )\n\naltitud es un objeto de la clase SpatRaster.\n\n# Clase del objeto altitud\nclass(altitud)\n\n[1] \"SpatRaster\"\nattr(,\"package\")\n[1] \"terra\"\n\n\nAl escribirse el nombre de un objeto SpatRaster en la consola de R, se despliega información general sobre este.\n\n# Información general sobre el objeto altitud\naltitud\n\nclass       : SpatRaster \ndimensions  : 687, 546, 1  (nrow, ncol, nlyr)\nresolution  : 0.008333333, 0.008333333  (x, y)\nextent      : -87.10189, -82.55189, 5.494651, 11.21965  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource      : altitud.tif \nname        : altitud \n\n\n\n\n10.5.2.2.2 crs() y project() - manejo de sistemas de coordenadas\nEl método crs() retorna el CRS de un objeto SpatRaster.\n\n# CRS del objeto altitud\ncrs(altitud)\n\n[1] \"GEOGCRS[\\\"WGS 84\\\",\\n    DATUM[\\\"World Geodetic System 1984\\\",\\n        ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n            LENGTHUNIT[\\\"metre\\\",1]]],\\n    PRIMEM[\\\"Greenwich\\\",0,\\n        ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    CS[ellipsoidal,2],\\n        AXIS[\\\"geodetic latitude (Lat)\\\",north,\\n            ORDER[1],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        AXIS[\\\"geodetic longitude (Lon)\\\",east,\\n            ORDER[2],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    ID[\\\"EPSG\\\",4326]]\"\n\n\ncrs() también puede asignar un CRS a un objeto SpatRaster.\n\n# Asignación de un CRS a una copia del objeto altitud\naltitud_crtm05 <- altitud\ncrs(altitud_crtm05) <- \"EPSG:5367\"\n\n# Consulta\ncrs(altitud_crtm05)\n\n[1] \"PROJCRS[\\\"CR05 / CRTM05\\\",\\n    BASEGEOGCRS[\\\"CR05\\\",\\n        DATUM[\\\"Costa Rica 2005\\\",\\n            ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n                LENGTHUNIT[\\\"metre\\\",1]]],\\n        PRIMEM[\\\"Greenwich\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        ID[\\\"EPSG\\\",5365]],\\n    CONVERSION[\\\"Costa Rica TM 2005\\\",\\n        METHOD[\\\"Transverse Mercator\\\",\\n            ID[\\\"EPSG\\\",9807]],\\n        PARAMETER[\\\"Latitude of natural origin\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8801]],\\n        PARAMETER[\\\"Longitude of natural origin\\\",-84,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8802]],\\n        PARAMETER[\\\"Scale factor at natural origin\\\",0.9999,\\n            SCALEUNIT[\\\"unity\\\",1],\\n            ID[\\\"EPSG\\\",8805]],\\n        PARAMETER[\\\"False easting\\\",500000,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8806]],\\n        PARAMETER[\\\"False northing\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8807]]],\\n    CS[Cartesian,2],\\n        AXIS[\\\"northing (N)\\\",north,\\n            ORDER[1],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        AXIS[\\\"easting (E)\\\",east,\\n            ORDER[2],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n    USAGE[\\n        SCOPE[\\\"Cadastre, engineering survey, topographic mapping (large and medium scale).\\\"],\\n        AREA[\\\"Costa Rica - onshore and offshore east of 86°30'W.\\\"],\\n        BBOX[2.21,-86.5,11.77,-81.43]],\\n    ID[\\\"EPSG\\\",5367]]\"\n\n\nEl método project() reproyecta un objeto SpatRaster a un nuevo CRS.\n\n# Transformación del CRS del objeto altitud\naltitud_utm17N <-\n  altitud |>\n  project(\"EPSG:8910\")\n\n# Consulta\ncrs(altitud_utm17N)\n\n[1] \"PROJCRS[\\\"CR-SIRGAS / UTM zone 17N\\\",\\n    BASEGEOGCRS[\\\"CR-SIRGAS\\\",\\n        DATUM[\\\"CR-SIRGAS\\\",\\n            ELLIPSOID[\\\"GRS 1980\\\",6378137,298.257222101,\\n                LENGTHUNIT[\\\"metre\\\",1]]],\\n        PRIMEM[\\\"Greenwich\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        ID[\\\"EPSG\\\",8907]],\\n    CONVERSION[\\\"UTM zone 17N\\\",\\n        METHOD[\\\"Transverse Mercator\\\",\\n            ID[\\\"EPSG\\\",9807]],\\n        PARAMETER[\\\"Latitude of natural origin\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8801]],\\n        PARAMETER[\\\"Longitude of natural origin\\\",-81,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8802]],\\n        PARAMETER[\\\"Scale factor at natural origin\\\",0.9996,\\n            SCALEUNIT[\\\"unity\\\",1],\\n            ID[\\\"EPSG\\\",8805]],\\n        PARAMETER[\\\"False easting\\\",500000,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8806]],\\n        PARAMETER[\\\"False northing\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8807]]],\\n    CS[Cartesian,2],\\n        AXIS[\\\"(E)\\\",east,\\n            ORDER[1],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        AXIS[\\\"(N)\\\",north,\\n            ORDER[2],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n    USAGE[\\n        SCOPE[\\\"Oil and gas exploration and production.\\\"],\\n        AREA[\\\"Costa Rica - offshore - Caribbean sea.\\\"],\\n        BBOX[9.6,-83.6,11.77,-81.43]],\\n    ID[\\\"EPSG\\\",8910]]\"\n\n\n\n\n10.5.2.2.3 plot() - mapeo\nEl método plot() muestra objetos SpatRaster en un mapa.\n\n# Mapa de la capa de altitud\nplot(altitud)\n\n\n\n\nLos argumentos reset y add de plot() permiten generar un mapa con varias capas.\n\n# Primera capa del mapa (raster)\nplot(\n  altitud,\n  main = \"Registros de presencia de felinos en Costa Rica\",\n  axes = TRUE,\n  reset = FALSE\n)\n\n# Segunda capa (vectorial)\nplot(felinos$geometry,\n     add = TRUE,     \n     pch = 16,\n     col = \"blue\")\n\n\n\n\n\n\n10.5.2.2.4 writeRaster() - escritura de datos\nLa función writeRaster() guarda en el disco un objeto SpatRaster en los diferentes formatos raster de GDAL.\n\n# Especificación del directorio de trabajo (debe utilizarse una ruta existente)\nsetwd(\"/home/mfvargas\")\n\n# Escritura del objeto altitud\naltitud |>\n  writeRaster(\"altitud.asc\")\n\n\n\n10.5.2.2.5 Otros\n\n# Cantidad de filas de un objeto SpatRaster\nnrow(altitud)\n\n[1] 687\n\n# Cantidad de columnas de un objeto SpatRaster\nncol(altitud)\n\n[1] 546\n\n# Resolución de un objeto SpatRaster\nres(altitud)\n\n[1] 0.008333333 0.008333333\n\n\n\n\n\n10.5.2.3 leaflet\nA la fecha de escritura de este documento (2022-11-05), el paquete leaflet no cuenta con soporte para combinar en un mapa objetos sf con objetos SpatRaster, pero sí puede hacerlo con objetos de tipo RasterLayer del paquete raster (antecesor de terra). Por este motivo, se utiliza aquí el método raster() de raster para realizar la conversión de SpatRaster a RasterLayer y así mapear el objeto altitud con el método addRasterImage() de leaflet. Para más información sobre el tema de conversiones entre las diferentes clases espaciales de R, puede consultarse Conversions between different spatial classes in R.\nEntonces, primero se instala y carga el paquete raster. También debe cargarse e instalarse el paquete rgdal, como complemento de raster.\n\n# Instalación de raster y rgdal\ninstall.packages(\"raster\")\ninstall.packages(\"rgdal\")\n\n\n# Carga de raster y rgdal\nlibrary(raster)\nlibrary(rgdal)\n\nSe muestran en un mapa leaflet las capas de altitud (raster), provincias (polígonos) y registros de presencia de felinos (puntos) sobre una capa base de OpenStreetMap (OSM).\n\n# Paleta de colores de altitud de Costa Rica\ncolores_altitud <-\n  colorNumeric(terrain.colors(25),\n               values(altitud),\n               na.color = \"transparent\")\n\n# Mapa leaflet básico con capas de altitud, provincias y registros de presencia de felinos\nleaflet() %>%\n  setView(# centro y nivel inicial de acercamiento\n    lng = -84.19452,\n    lat = 9.572735,\n    zoom = 7) |>  \n  addTiles(group = \"OpenStreetMap\") |> # capa base de OSM\n  addRasterImage( # capa raster\n    raster(altitud), # conversión de SpatRaster a RasterLayer \n    colors = colores_altitud, # paleta de colores\n    opacity = 0.6,\n    group = \"Altitud\",\n  ) |>\n  addLegend(\n    title = \"Altitud\",\n    values = values(altitud),\n    pal = colores_altitud,\n    position = \"bottomleft\",\n    group = \"Altitud\"\n  ) |>\n  addPolygons(\n    data = provincias,\n    color = \"black\",\n    fillColor = \"transparent\",\n    stroke = TRUE,\n    weight = 1.0,\n    group = \"Provincias\"\n  ) |>\n  addCircleMarkers(\n    data = felinos,\n    stroke = F,\n    radius = 4,\n    fillColor = 'blue',\n    fillOpacity = 1,\n    group = \"Felinos\",\n    popup = paste(\n      paste0(\"<strong>Especie: </strong>\", felinos$species),\n      paste0(\"<strong>Localidad: </strong>\", felinos$locality),\n      paste0(\"<strong>Fecha: </strong>\", felinos$eventDate),\n      paste0(\"<strong>Fuente: </strong>\", felinos$institutionCode),\n      paste0(\"<a href='\", felinos$occurrenceID, \"'>Más información</a>\"),\n      sep = '<br/>'\n    )    \n  ) |>\n  addLayersControl(\n    # control de capas\n    baseGroups = c(\"OpenStreetMap\"),\n    overlayGroups = c(\"Altitud\", \"Provincias\", \"Felinos\")\n  )"
  },
  {
    "objectID": "10-introduccion-manejo-datos-geoespaciales.html#ejercicios-1",
    "href": "10-introduccion-manejo-datos-geoespaciales.html#ejercicios-1",
    "title": "10  Introducción al manejo de datos geoespaciales en R",
    "section": "10.6 Ejercicios",
    "text": "10.6 Ejercicios\nEn un documento Quarto incluya:\n\nUna tabla DT con las columnas del conjunto de datos de felinos de Costa Rica correspondientes a especie (species), fecha (eventDate), provincia (stateProvince), localidad (locality), longitud (decimalLongitude) y latitud (decimalLatitude).\n\nLas columnas deben, si es necesario, convertirse al tipo de datos adecuado (ej. Date).\nLos encabezados de las columnas en la tabla deben desplegarse en español, pero no deben alterarse los nombres de las columnas. Sugerencia: utilice el argumento colnames de la función datatable().\nLos controles de la tabla deben estar en español.\n\nUn gráfico de barras, generado con gglot2 y traducido a plotly con ggplotly(), que muestre la cantidad de registros para cada especie de felinos.\n\nLas barras deben estar ordenadas de mayor a menor.\nTodos los controles y etiquetas del gráfico deben estar en español.\n\nUn mapa leaflet con las siguientes capas:\n\nCapa base de OpenStreetMap (OSM).\nProvincias de Costa Rica (polígonos).\nRegistros de presencia de felinos (puntos).\n\n\nPublique el documento como un sitio web en GitHub Pages."
  },
  {
    "objectID": "10-introduccion-manejo-datos-geoespaciales.html#recursos-de-interés",
    "href": "10-introduccion-manejo-datos-geoespaciales.html#recursos-de-interés",
    "title": "10  Introducción al manejo de datos geoespaciales en R",
    "section": "10.7 Recursos de interés",
    "text": "10.7 Recursos de interés\nBivand, R. (2022). CRAN Task View: Analysis of Spatial Data. https://CRAN.R-project.org/view=Spatial\nR-Ladies Madrid. (2021). R-Ladies Madrid (español)—Analiza datos espaciales—Stephanie Orellana. https://www.youtube.com/watch?v=59tO2ARvVVU"
  },
  {
    "objectID": "examen_corto-01.html",
    "href": "examen_corto-01.html",
    "title": "Examen corto 01",
    "section": "",
    "text": "Lunes 5 de setiembre de 2022"
  },
  {
    "objectID": "examen_corto-01.html#temas-a-evaluar",
    "href": "examen_corto-01.html#temas-a-evaluar",
    "title": "Examen corto 01",
    "section": "Temas a evaluar",
    "text": "Temas a evaluar\n\nIntroducción a la ciencia de datos geoespaciales\nMarkdown - lenguaje de marcado\nGit - sistema de control de versiones"
  },
  {
    "objectID": "tarea-01.html",
    "href": "tarea-01.html",
    "title": "Tarea 01",
    "section": "",
    "text": "Lunes 12 de setiembre de 2022, 02:59 p.m."
  },
  {
    "objectID": "tarea-01.html#entregables",
    "href": "tarea-01.html#entregables",
    "title": "Tarea 01",
    "section": "Entregables",
    "text": "Entregables\n\nDirección de un repositorio en GitHub llamado notas-investigacion-reproducible (ej. https://github.com/mfvargas/notas-investigacion-reproducible) que contenga un documento escrito en Markdown llamado README.md, con el contenido especificado en la sección Desarrollo.\nDirección de un sitio web publicado en GitHub Pages generado a partir del repositorio especificado en el punto anterior (ej. https://mfvargas.github.io/notas-investigacion-reproducible/).\n\nLa entrega debe realizarse a través de la plataforma Mediación Virtual."
  },
  {
    "objectID": "tarea-01.html#objetivos",
    "href": "tarea-01.html#objetivos",
    "title": "Tarea 01",
    "section": "Objetivos",
    "text": "Objetivos\nCada estudiante debe mostrar que es capaz de:\n\nEscribir documentos en el lenguaje de marcado Markdown.\nManejar repositorios en GitHub.\nPublicar repositorios en GitHub como sitios web en GitHub Pages."
  },
  {
    "objectID": "tarea-01.html#consideraciones-adicionales",
    "href": "tarea-01.html#consideraciones-adicionales",
    "title": "Tarea 01",
    "section": "Consideraciones adicionales",
    "text": "Consideraciones adicionales\nEsta tarea es estrictamente individual."
  },
  {
    "objectID": "tarea-01.html#desarrollo",
    "href": "tarea-01.html#desarrollo",
    "title": "Tarea 01",
    "section": "Desarrollo",
    "text": "Desarrollo\nEl sitio web debe tener los contenidos y formatos que se muestran en las siguientes imágenes. Deben reproducirse los encabezados, negritas, itálicas, citas textuales, imágenes e hipervínculos a otros documentos.\n\n\n\n\n\n\n\n\n\n\nLos textos están disponibles en este enlace."
  },
  {
    "objectID": "tarea-01.html#calificación",
    "href": "tarea-01.html#calificación",
    "title": "Tarea 01",
    "section": "Calificación",
    "text": "Calificación\nEntre paréntesis, se muestra el porcentaje correspondiente a cada aspecto que se calificará:\nRevisión de las direcciones entregadas:\n- (5%) Dirección del repositorio en GitHub.\n- (5%) Dirección del sitio web publicado en GitHub Pages.\nRevisión de los elementos del documento escrito en Markdown:\n- (10%) Encabezados.\n- (20%) Negritas e itálicas.\n- (20%) Citas textuales.\n- (20%) Imagen de la figura 1 (el archivo está en ZiemannEtAlFig1.png.\n- (20%) Hipervínculos (además de los dos de la bibliografía, incluya uno al sitio web de la FDA en https://www.fda.gov/, en donde se mencionan las siglas)."
  },
  {
    "objectID": "examen_corto-02.html",
    "href": "examen_corto-02.html",
    "title": "Examen corto 02",
    "section": "",
    "text": "Lunes 10 de octubre de 2022"
  },
  {
    "objectID": "examen_corto-02.html#temas-a-evaluar",
    "href": "examen_corto-02.html#temas-a-evaluar",
    "title": "Examen corto 02",
    "section": "Temas a evaluar",
    "text": "Temas a evaluar\n\nR - conceptos básicos"
  },
  {
    "objectID": "examen_corto-03.html",
    "href": "examen_corto-03.html",
    "title": "Examen corto 03",
    "section": "",
    "text": "Lunes 24 de octubre de 2022"
  },
  {
    "objectID": "examen_corto-03.html#temas-a-evaluar",
    "href": "examen_corto-03.html#temas-a-evaluar",
    "title": "Examen corto 03",
    "section": "Temas a evaluar",
    "text": "Temas a evaluar\n\nQuarto\nVisualización de datos con funciones de graficación del paquete base de R"
  },
  {
    "objectID": "tarea-02.html",
    "href": "tarea-02.html",
    "title": "Tarea 02",
    "section": "",
    "text": "Lunes 7 de noviembre de 2022, 02:59 p.m.\nLa entrega debe realizarse a través de la plataforma Mediación Virtual."
  },
  {
    "objectID": "tarea-02.html#objetivos",
    "href": "tarea-02.html#objetivos",
    "title": "Tarea 02",
    "section": "Objetivos",
    "text": "Objetivos\nCada estudiante debe mostrar que es capaz de:\n\nDesarrollar programas en el lenguaje R y documentos en el sistema de publicación científica y técnica Quarto.\nImplementar tablas y gráficos con las bibliotecas DT, ggplot2 y plotly.\nPublicar resultados en la Web, junto con el código y los datos que los generan."
  },
  {
    "objectID": "tarea-02.html#entregables",
    "href": "tarea-02.html#entregables",
    "title": "Tarea 02",
    "section": "Entregables",
    "text": "Entregables\nDirección de un repositorio en GitHub que contenga código, datos y documentación. También debe publicar el repositorio como un sitio GitHub Pages.\nEspecíficamente, el repositorio debe contener:\n\nUn documento Quarto con el código en R necesario para generar las salidas especificadas en la sección Desarrollo.\nUn directorio con archivos de datos.\nUn archivo README.md con:\n\nUna breve descripción (no mayor a 200 palabras) del contenido del repositorio. Si lo desea, puede incluir su interpretación de los resultados.\nUna mención y un enlace a la fuente de los datos.\nUn enlace a un sitio en GitHub Pages con el documento Quarto publicado como una página HTML.\n\n\nLa entrega debe realizarse a través de la plataforma Mediación Virtual."
  },
  {
    "objectID": "tarea-02.html#consideraciones-adicionales",
    "href": "tarea-02.html#consideraciones-adicionales",
    "title": "Tarea 02",
    "section": "Consideraciones adicionales",
    "text": "Consideraciones adicionales\nEsta tarea puede realizarse en parejas o de manera individual. Si es en pareja, solo un integrante debe realizar la entrega e indicar el nombre del otro integrante en Mediación Virtual."
  },
  {
    "objectID": "tarea-02.html#desarrollo",
    "href": "tarea-02.html#desarrollo",
    "title": "Tarea 02",
    "section": "Desarrollo",
    "text": "Desarrollo\nDebe desarrollar un documento en Quarto, con bloques de código en R, que utilice los datos de COVID en Costa Rica al 30 de mayo de 2022, disponibles en https://oges.ministeriodesalud.go.cr/. Los archivos necesarios son:\n\nCantidades diarias de casos a nivel nacional: 05_30_22_CSV_GENERAL.csv\nCantidades de casos por cantón: 05_30_22_CSV_POSITIVOS.csv\n\nAlternativamente, puede descargar los archivos de los siguientes enlaces:\n\n05_30_22_CSV_GENERAL.csv\n05_30_22_CSV_POSITIVOS.csv\n\nDebe cargar los datos en los archivos CSV a data frames de R y prepararlos mediante:\n\nConversiones de tipos (ej. fechas).\nManejo de codificaciones de caracteres (locales).\nEliminación de columnas no necesarias.\nEliminación de filas no necesarias.\nCambio de nombres de columnas.\n\nLuego, debe implementar las siguientes salidas:\n\nUna tabla que muestre datos diarios de COVID (del archivo 05_30_22_CSV_GENERAL.csv). Incluya las columnas: fecha, casos positivos acumulados de hombres (hom_posi), casos positivos acumulados de mujeres (muj_posi), casos positivos acumulados de menores (menor_posi), casos positivos acumulados de adultos (adul_posi), casos positivos acumulados de adultos mayores (am_posi) y casos positivos nuevos (nue_posi).\nUn gráfico de barras que muestre la cantidad de casos positivos nuevos por día. Es decir, debe contener una barra por cada día, desde el 2020-06-03 hasta el 2022-05-30.\nUn gráfico de líneas que muestre la evolución a través del tiempo de los casos positivos acumulados de hombres y de los casos positivos acumulados de mujeres.\nUn gráfico de líneas que muestre la evolución a través del tiempo de los casos positivos acumulados de menores, los casos positivos acumulados de adultos y de los casos positivos acumulados de adultos mayores.\nUna tabla que muestre la cantidad casos positivos en cantones. Incluya las columnas provincia (provincia), cantón (canton) y casos al 2022-05-30 (30/05/2022). No incluya la fila de “Otros” o la que contiene valores nulos.\nUn histograma que muestre la distribución de los casos positivos en cantones.\n\nLas tablas deben generarse con DT. Los gráficos deben generarse con ggplot2 y convertirse a plotly con la función ggplotly(), para que sean interactivos en la página web que se entregue.\nConsidere este proyecto como un breve artículo de análisis de datos y siga los siguientes lineamientos:\n\nEl código en R y sus salidas deben ser legibles y bien presentados.\nProcure incluir solamente el código necesario para generar los resultados.\nAgregue texto en Markdown para darle estructura al documento e incluir las explicaciones que considere necesarias.\nPara cada gráfico, incluya un título y etiquetas para los ejes x e y."
  },
  {
    "objectID": "tarea-02.html#calificación",
    "href": "tarea-02.html#calificación",
    "title": "Tarea 02",
    "section": "Calificación",
    "text": "Calificación\nEntre paréntesis, se muestra el porcentaje correspondiente a cada aspecto que se calificará:\n\nEstructura y legibilidad del documento Quarto (5%).\nInclusión de los archivos de datos en el repositorio (5%).\nInclusión del archivo README.md, con el contenido descrito en la sección Entregables (5%).\nPreparación de los archivos de datos (5%).\nTabla con datos de casos por día (10%).\nTabla con datos de casos por cantón (10%).\nGráfico de barras (15%).\nGráfico de líneas de casos por sexo (15%).\nGráfico de líneas de casos por edad (15%).\nHistograma (15%)."
  },
  {
    "objectID": "examen_corto-04.html",
    "href": "examen_corto-04.html",
    "title": "Examen corto 04",
    "section": "",
    "text": "Lunes 14 de noviembre de 2022"
  },
  {
    "objectID": "examen_corto-04.html#temas-a-evaluar",
    "href": "examen_corto-04.html#temas-a-evaluar",
    "title": "Examen corto 04",
    "section": "Temas a evaluar",
    "text": "Temas a evaluar\n\nTidyverse - paquetes para ciencia de datos\ndplyr - gramática para manipulación de datos\nggplot2 y plotly - creación declarativa de gráficos interactivos"
  },
  {
    "objectID": "tarea-03.html",
    "href": "tarea-03.html",
    "title": "Tarea 03",
    "section": "",
    "text": "Lunes 21 de noviembre de 2022, 02:59 p.m.\nLa entrega debe realizarse a través de la plataforma Mediación Virtual."
  },
  {
    "objectID": "tarea-03.html#objetivos",
    "href": "tarea-03.html#objetivos",
    "title": "Tarea 03",
    "section": "Objetivos",
    "text": "Objetivos\nCada estudiante debe mostrar que es capaz de:\n\nDesarrollar programas en el lenguaje R y documentos en el sistema de publicación científica y técnica Quarto.\nImplementar tablas, gráficos y mapas con las bibliotecas DT, ggplot2, plotly y sf.\nPublicar resultados en la Web, junto con el código y los datos que los generan."
  },
  {
    "objectID": "tarea-03.html#entregables",
    "href": "tarea-03.html#entregables",
    "title": "Tarea 03",
    "section": "Entregables",
    "text": "Entregables\nDirección de un repositorio en GitHub que contenga código, datos y documentación. También debe publicar el repositorio como un sitio GitHub Pages.\nEspecíficamente, el repositorio debe contener:\n\nUn documento Quarto con el código en R necesario para generar las salidas especificadas en la sección Desarrollo.\nUn directorio con archivos de datos.\nUn archivo README.md con:\n\nUna breve descripción (no mayor a 200 palabras) del contenido del repositorio. Si lo desea, puede incluir su interpretación de los resultados.\nUna mención y un enlace a las fuentes de los datos (ej. DOI de las consultas al portal de GBIF, fuentes de datos geoespaciales).\nUn enlace a un sitio en GitHub Pages con el documento Quarto publicado como una página HTML.\n\n\nLa entrega debe realizarse a través de la plataforma Mediación Virtual."
  },
  {
    "objectID": "tarea-03.html#consideraciones-adicionales",
    "href": "tarea-03.html#consideraciones-adicionales",
    "title": "Tarea 03",
    "section": "Consideraciones adicionales",
    "text": "Consideraciones adicionales\nEsta tarea puede realizarse en parejas o de manera individual. Si es en pareja, solo un integrante debe realizar la entrega e indicar el nombre del otro integrante en Mediación Virtual."
  },
  {
    "objectID": "tarea-03.html#desarrollo",
    "href": "tarea-03.html#desarrollo",
    "title": "Tarea 03",
    "section": "Desarrollo",
    "text": "Desarrollo\nDebe desarrollar un documento en Quarto, con bloques de código en R, que utilicen los siguientes conjuntos de datos:\n\nRegistros de presencia de felinos de Costa Rica, agrupados por la Infraestructura Mundial de Información en Biodiversidad (GBIF).\nÁreas silvestres protegidas (ASP) de Costa Rica, publicadas por el Sistema Nacional de Áreas de Conservación (Sinac) en el Sistema Nacional de Información Territorial (SNIT).\nCapa raster de WorldClim de altitud de Costa Rica en resolución de 30 x 30 segundos. (Enlace al sitio de WorldClim).\n\nDebe cargar los datos en R y realizar las conversiones y preparaciones necesarias, por ejemplo:\n\nConversiones de tipos (ej. fechas).\nManejo de codificaciones de caracteres (locales).\nEliminación de columnas no necesarias.\nEliminación de filas no necesarias.\nCambio de nombres de columnas.\n\nLuego, debe implementar las siguientes salidas:\n\nUna tabla que muestre los registros de presencia de felinos. Incluya las columnas: especie (species), provincia (stateProvince), localidad (locality), fecha (eventDate).\nUn gráfico de barras apiladas que muestre la cantidad de registros por especie en cada mes del año. El gráfico debe tener 12 barras (una por mes) y cada barra debe estar dividida en un máximo de seis partes (una por especie). Las barras deben estar ordenadas de enero a diciembre.\nUn mapa que muestre las siguientes cinco capas:\n\n\nDos capas base (ej. OpenStreetMap).\nCapa raster de altitud de Costa Rica.\nCapa de polígonos de ASP de Costa Rica. La ventana emergente (popup) debe mostrar el nombre del ASP al hacer clic sobre el polígono.\nCapa de puntos de registros de presencia de felinos. La ventana emergente (popup) debe mostrar el nombre de la especie, la provincia, la localidad y la fecha.\n\nLas tablas deben generarse con DT. Los gráficos deben generarse con ggplot2 y convertirse a plotly con la función ggplotly(), para que sean interactivos en la página web que se entregue. Los mapas deben implementarse con leaflet.\nConsidere este proyecto como un breve artículo de análisis de datos y siga los siguientes lineamientos:\n\nEl código en R y sus salidas deben ser legibles y bien presentados.\nIncluya solamente el código necesario para generar los resultados. No incluya pruebas o resultados intermedios. Puede utilizar opciones en los bloque de código de Quarto como warning, message y code-fold para evitar el despliegue de mensajes y advertencias, así como para ocultar el código, si lo considera conveniente.\nAgregue texto en Markdown para darle estructura al documento e incluir las explicaciones que considere necesarias.\nPara cada gráfico, incluya un título y etiquetas para los ejes x e y.\nLos mapas deben tener un control de capas."
  },
  {
    "objectID": "tarea-03.html#calificación",
    "href": "tarea-03.html#calificación",
    "title": "Tarea 03",
    "section": "Calificación",
    "text": "Calificación\nEntre paréntesis, se muestra el porcentaje correspondiente a cada aspecto que se calificará:\n\nEstructura y legibilidad del documento Quarto (10%).\nInclusión de los archivos de datos en el repositorio (5%).\nInclusión del archivo README.md, con el contenido descrito en la sección Entregables (5%).\nPreparación de los archivos de datos (5%).\nTabla con registros de presencia de especies (10%).\nGráfico de barras apiladas (30%).\nMapa (35%)."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Referencias bibliográficas",
    "section": "",
    "text": "Gandrud, Christopher. 2020. Reproducible Research with\nR and RStudio. Third edition. The\nR Series. Boca Raton, FL: CRC Press.\n\n\nLongley, Paul A., Michael F. Goodchild, David J. Maguire, and David W.\nRhind. 2005. Geographic Information\nSystems and Science. 2nd edition.\nChichester ; Hoboken, NJ: Wiley.\n\n\nOlaya, Víctor. 2020. “Sistemas de Información\nGeográfica.” https://volaya.github.io/libro-sig/.\n\n\nPeng, Roger D. 2011. “Reproducible Research in\nComputational Science.”\nScience 334 (6060): 1226–27. https://doi.org/10.1126/science.1213847.\n\n\nSingleton, Alex David, Seth Spielman, and Chris Brunsdon. 2016.\n“Establishing a Framework for Open\nGeographic Information Science.”\nInternational Journal of Geographical Information Science 30\n(8): 1507–21. https://doi.org/10.1080/13658816.2015.1137579.\n\n\n“Tidyverse.” n.d. Accessed May 14, 2022. https://www.tidyverse.org/.\n\n\nWickham, Hadley, and Garrett Grolemund. 2017. R for\nData Science: Import,\nTidy, Transform, Visualize, and\nModel Data. 1 edition. Sebastopol, CA:\nO’Reilly Media. https://r4ds.had.co.nz/."
  }
]